//
// Generated by Bluespec Compiler, version 2021.07-1-gaf77efcd (build af77efcd)
//
// On Thu Dec  9 08:47:40 IST 2021
//
//
// Ports:
// Name                         I/O  size props
// mv_output                      O    70
// RDY_mv_output                  O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// ma_inputs_in1                  I    64
// ma_inputs_in2                  I    64
// ma_inputs_funct3               I     3
// ma_inputs_word32               I     1 reg
// EN_ma_inputs                   I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkcombo_mul(CLK,
		   RST_N,

		   ma_inputs_in1,
		   ma_inputs_in2,
		   ma_inputs_funct3,
		   ma_inputs_word32,
		   EN_ma_inputs,

		   mv_output,
		   RDY_mv_output);
  input  CLK;
  input  RST_N;

  // action method ma_inputs
  input  [63 : 0] ma_inputs_in1;
  input  [63 : 0] ma_inputs_in2;
  input  [2 : 0] ma_inputs_funct3;
  input  ma_inputs_word32;
  input  EN_ma_inputs;

  // value method mv_output
  output [69 : 0] mv_output;
  output RDY_mv_output;

  // signals for module outputs
  wire [69 : 0] mv_output;
  wire RDY_mv_output;

  // register rg_fn3
  reg [2 : 0] rg_fn3;
  wire [2 : 0] rg_fn3_D_IN;
  wire rg_fn3_EN;

  // register rg_op1_0
  reg [64 : 0] rg_op1_0;
  wire [64 : 0] rg_op1_0_D_IN;
  wire rg_op1_0_EN;

  // register rg_op1_1
  reg [64 : 0] rg_op1_1;
  wire [64 : 0] rg_op1_1_D_IN;
  wire rg_op1_1_EN;

  // register rg_op2_0
  reg [64 : 0] rg_op2_0;
  wire [64 : 0] rg_op2_0_D_IN;
  wire rg_op2_0_EN;

  // register rg_op2_1
  reg [64 : 0] rg_op2_1;
  wire [64 : 0] rg_op2_1_D_IN;
  wire rg_op2_1_EN;

  // register rg_valid_0
  reg rg_valid_0;
  wire rg_valid_0_D_IN, rg_valid_0_EN;

  // register rg_valid_1
  reg rg_valid_1;
  wire rg_valid_1_D_IN, rg_valid_1_EN;

  // register rg_word
  reg rg_word;
  wire rg_word_D_IN, rg_word_EN;

  // ports of submodule signed_mul
  wire [129 : 0] signed_mul_c;
  wire [64 : 0] signed_mul_a, signed_mul_b;

  // rule scheduling signals
  wire CAN_FIRE_RL_rg_valid_0__dreg_update,
       CAN_FIRE_RL_rg_valid_1__dreg_update,
       CAN_FIRE_RL_rl_perform_mul,
       CAN_FIRE_ma_inputs,
       WILL_FIRE_RL_rg_valid_0__dreg_update,
       WILL_FIRE_RL_rg_valid_1__dreg_update,
       WILL_FIRE_RL_rl_perform_mul,
       WILL_FIRE_ma_inputs;

  // remaining internal signals
  wire [63 : 0] IF_rg_fn3_3_BITS_1_TO_0_4_EQ_0_5_THEN_signed_m_ETC___d19,
		default_out__h1493,
		x_wget__h973;
  wire [31 : 0] IF_rg_fn3_3_BITS_1_TO_0_4_EQ_0_5_THEN_signed_m_ETC__q1;
  wire sign1__h1620, sign2__h1621;

  // action method ma_inputs
  assign CAN_FIRE_ma_inputs = 1'd1 ;
  assign WILL_FIRE_ma_inputs = EN_ma_inputs ;

  // value method mv_output
  assign mv_output = { x_wget__h973, rg_valid_1, 5'd0 } ;
  assign RDY_mv_output = 1'd1 ;

  // submodule signed_mul
  signedmul #(.AWIDTH(32'd65), .BWIDTH(32'd65)) signed_mul(.a(signed_mul_a),
							   .b(signed_mul_b),
							   .c(signed_mul_c));

  // rule RL_rl_perform_mul
  assign CAN_FIRE_RL_rl_perform_mul = 1'd1 ;
  assign WILL_FIRE_RL_rl_perform_mul = 1'd1 ;

  // rule RL_rg_valid_0__dreg_update
  assign CAN_FIRE_RL_rg_valid_0__dreg_update = 1'd1 ;
  assign WILL_FIRE_RL_rg_valid_0__dreg_update = 1'd1 ;

  // rule RL_rg_valid_1__dreg_update
  assign CAN_FIRE_RL_rg_valid_1__dreg_update = 1'd1 ;
  assign WILL_FIRE_RL_rg_valid_1__dreg_update = 1'd1 ;

  // register rg_fn3
  assign rg_fn3_D_IN = ma_inputs_funct3 ;
  assign rg_fn3_EN = EN_ma_inputs ;

  // register rg_op1_0
  assign rg_op1_0_D_IN = { sign1__h1620 & ma_inputs_in1[63], ma_inputs_in1 } ;
  assign rg_op1_0_EN = EN_ma_inputs ;

  // register rg_op1_1
  assign rg_op1_1_D_IN = rg_op1_0 ;
  assign rg_op1_1_EN = 1'd1 ;

  // register rg_op2_0
  assign rg_op2_0_D_IN = { sign2__h1621 & ma_inputs_in2[63], ma_inputs_in2 } ;
  assign rg_op2_0_EN = EN_ma_inputs ;

  // register rg_op2_1
  assign rg_op2_1_D_IN = rg_op2_0 ;
  assign rg_op2_1_EN = 1'd1 ;

  // register rg_valid_0
  assign rg_valid_0_D_IN = EN_ma_inputs ;
  assign rg_valid_0_EN = 1'd1 ;

  // register rg_valid_1
  assign rg_valid_1_D_IN = rg_valid_0 ;
  assign rg_valid_1_EN = 1'd1 ;

  // register rg_word
  assign rg_word_D_IN = ma_inputs_word32 ;
  assign rg_word_EN = EN_ma_inputs ;

  // submodule signed_mul
  assign signed_mul_a = rg_op1_1 ;
  assign signed_mul_b = rg_op2_1 ;

  // remaining internal signals
  assign IF_rg_fn3_3_BITS_1_TO_0_4_EQ_0_5_THEN_signed_m_ETC___d19 =
	     (rg_fn3[1:0] == 2'd0) ?
	       signed_mul_c[63:0] :
	       signed_mul_c[127:64] ;
  assign IF_rg_fn3_3_BITS_1_TO_0_4_EQ_0_5_THEN_signed_m_ETC__q1 =
	     IF_rg_fn3_3_BITS_1_TO_0_4_EQ_0_5_THEN_signed_m_ETC___d19[31:0] ;
  assign default_out__h1493 =
	     { {32{IF_rg_fn3_3_BITS_1_TO_0_4_EQ_0_5_THEN_signed_m_ETC__q1[31]}},
	       IF_rg_fn3_3_BITS_1_TO_0_4_EQ_0_5_THEN_signed_m_ETC__q1 } ;
  assign sign1__h1620 = ma_inputs_funct3[1] ^ ma_inputs_funct3[0] ;
  assign sign2__h1621 = ma_inputs_funct3[1:0] == 2'd1 ;
  assign x_wget__h973 =
	     rg_word ?
	       default_out__h1493 :
	       IF_rg_fn3_3_BITS_1_TO_0_4_EQ_0_5_THEN_signed_m_ETC___d19 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        rg_fn3 <= `BSV_ASSIGNMENT_DELAY 3'd0;
	rg_op1_0 <= `BSV_ASSIGNMENT_DELAY 65'd0;
	rg_op1_1 <= `BSV_ASSIGNMENT_DELAY 65'd0;
	rg_op2_0 <= `BSV_ASSIGNMENT_DELAY 65'd0;
	rg_op2_1 <= `BSV_ASSIGNMENT_DELAY 65'd0;
	rg_valid_0 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rg_valid_1 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rg_word <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (rg_fn3_EN) rg_fn3 <= `BSV_ASSIGNMENT_DELAY rg_fn3_D_IN;
	if (rg_op1_0_EN) rg_op1_0 <= `BSV_ASSIGNMENT_DELAY rg_op1_0_D_IN;
	if (rg_op1_1_EN) rg_op1_1 <= `BSV_ASSIGNMENT_DELAY rg_op1_1_D_IN;
	if (rg_op2_0_EN) rg_op2_0 <= `BSV_ASSIGNMENT_DELAY rg_op2_0_D_IN;
	if (rg_op2_1_EN) rg_op2_1 <= `BSV_ASSIGNMENT_DELAY rg_op2_1_D_IN;
	if (rg_valid_0_EN)
	  rg_valid_0 <= `BSV_ASSIGNMENT_DELAY rg_valid_0_D_IN;
	if (rg_valid_1_EN)
	  rg_valid_1 <= `BSV_ASSIGNMENT_DELAY rg_valid_1_D_IN;
	if (rg_word_EN) rg_word <= `BSV_ASSIGNMENT_DELAY rg_word_D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    rg_fn3 = 3'h2;
    rg_op1_0 = 65'h0AAAAAAAAAAAAAAAA;
    rg_op1_1 = 65'h0AAAAAAAAAAAAAAAA;
    rg_op2_0 = 65'h0AAAAAAAAAAAAAAAA;
    rg_op2_1 = 65'h0AAAAAAAAAAAAAAAA;
    rg_valid_0 = 1'h0;
    rg_valid_1 = 1'h0;
    rg_word = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkcombo_mul

