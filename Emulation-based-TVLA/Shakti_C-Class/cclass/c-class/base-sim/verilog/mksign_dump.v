//
// Generated by Bluespec Compiler, version 2021.07-1-gaf77efcd (build af77efcd)
//
// On Tue Dec  7 15:47:27 IST 2021
//
//
// Ports:
// Name                         I/O  size props
// master_AWVALID                 O     1 reg
// master_AWADDR                  O    32 reg
// master_AWPROT                  O     3 reg
// master_AWLEN                   O     8 reg
// master_AWSIZE                  O     3 reg
// master_AWBURST                 O     2 reg
// master_AWID                    O     4 reg
// master_WVALID                  O     1 reg
// master_WDATA                   O    64 reg
// master_WSTRB                   O     8 reg
// master_WLAST                   O     1 reg
// master_WID                     O     4 reg
// master_BREADY                  O     1 reg
// master_ARVALID                 O     1 reg
// master_ARADDR                  O    32 reg
// master_ARPROT                  O     3 reg
// master_ARLEN                   O     8 reg
// master_ARSIZE                  O     3 reg
// master_ARBURST                 O     2 reg
// master_ARID                    O     4 reg
// master_RREADY                  O     1 reg
// slave_AWREADY                  O     1 reg
// slave_WREADY                   O     1 reg
// slave_BVALID                   O     1 reg
// slave_BRESP                    O     2 reg
// slave_BID                      O     4 reg
// slave_ARREADY                  O     1 reg
// slave_RVALID                   O     1 reg
// slave_RRESP                    O     2 reg
// slave_RDATA                    O    64 reg
// slave_RLAST                    O     1 reg
// slave_RID                      O     4 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// master_AWREADY                 I     1
// master_WREADY                  I     1
// master_BVALID                  I     1
// master_BRESP                   I     2 reg
// master_BID                     I     4 reg
// master_ARREADY                 I     1
// master_RVALID                  I     1
// master_RRESP                   I     2 reg
// master_RDATA                   I    64 reg
// master_RLAST                   I     1 reg
// master_RID                     I     4 reg
// slave_AWVALID                  I     1
// slave_AWADDR                   I    32 reg
// slave_AWSIZE                   I     3 reg
// slave_AWPROT                   I     3 reg
// slave_AWLEN                    I     8 reg
// slave_AWBURST                  I     2 reg
// slave_AWID                     I     4 reg
// slave_WVALID                   I     1
// slave_WDATA                    I    64 reg
// slave_WSTRB                    I     8 reg
// slave_WLAST                    I     1 reg
// slave_WID                      I     4 reg
// slave_BREADY                   I     1
// slave_ARVALID                  I     1
// slave_ARADDR                   I    32 reg
// slave_ARSIZE                   I     3 reg
// slave_ARPROT                   I     3 reg
// slave_ARLEN                    I     8 reg
// slave_ARBURST                  I     2 reg
// slave_ARID                     I     4 reg
// slave_RREADY                   I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mksign_dump(CLK,
		   RST_N,

		   master_AWVALID,

		   master_AWADDR,

		   master_AWPROT,

		   master_AWLEN,

		   master_AWSIZE,

		   master_AWBURST,

		   master_AWID,

		   master_AWREADY,

		   master_WVALID,

		   master_WDATA,

		   master_WSTRB,

		   master_WLAST,

		   master_WID,

		   master_WREADY,

		   master_BVALID,
		   master_BRESP,
		   master_BID,

		   master_BREADY,

		   master_ARVALID,

		   master_ARADDR,

		   master_ARPROT,

		   master_ARLEN,

		   master_ARSIZE,

		   master_ARBURST,

		   master_ARID,

		   master_ARREADY,

		   master_RVALID,
		   master_RRESP,
		   master_RDATA,
		   master_RLAST,
		   master_RID,

		   master_RREADY,

		   slave_AWVALID,
		   slave_AWADDR,
		   slave_AWSIZE,
		   slave_AWPROT,
		   slave_AWLEN,
		   slave_AWBURST,
		   slave_AWID,

		   slave_AWREADY,

		   slave_WVALID,
		   slave_WDATA,
		   slave_WSTRB,
		   slave_WLAST,
		   slave_WID,

		   slave_WREADY,

		   slave_BVALID,

		   slave_BRESP,

		   slave_BID,

		   slave_BREADY,

		   slave_ARVALID,
		   slave_ARADDR,
		   slave_ARSIZE,
		   slave_ARPROT,
		   slave_ARLEN,
		   slave_ARBURST,
		   slave_ARID,

		   slave_ARREADY,

		   slave_RVALID,

		   slave_RRESP,

		   slave_RDATA,

		   slave_RLAST,

		   slave_RID,

		   slave_RREADY);
  input  CLK;
  input  RST_N;

  // value method master_m_awvalid
  output master_AWVALID;

  // value method master_m_awaddr
  output [31 : 0] master_AWADDR;

  // value method master_m_awuser

  // value method master_m_awprot
  output [2 : 0] master_AWPROT;

  // value method master_m_awlen
  output [7 : 0] master_AWLEN;

  // value method master_m_awsize
  output [2 : 0] master_AWSIZE;

  // value method master_m_awburst
  output [1 : 0] master_AWBURST;

  // value method master_m_awid
  output [3 : 0] master_AWID;

  // action method master_m_awready
  input  master_AWREADY;

  // value method master_m_wvalid
  output master_WVALID;

  // value method master_m_wdata
  output [63 : 0] master_WDATA;

  // value method master_m_wstrb
  output [7 : 0] master_WSTRB;

  // value method master_m_wlast
  output master_WLAST;

  // value method master_m_wid
  output [3 : 0] master_WID;

  // action method master_m_wready
  input  master_WREADY;

  // action method master_m_bvalid
  input  master_BVALID;
  input  [1 : 0] master_BRESP;
  input  [3 : 0] master_BID;

  // value method master_m_bready
  output master_BREADY;

  // value method master_m_arvalid
  output master_ARVALID;

  // value method master_m_araddr
  output [31 : 0] master_ARADDR;

  // value method master_m_aruser

  // value method master_m_arprot
  output [2 : 0] master_ARPROT;

  // value method master_m_arlen
  output [7 : 0] master_ARLEN;

  // value method master_m_arsize
  output [2 : 0] master_ARSIZE;

  // value method master_m_arburst
  output [1 : 0] master_ARBURST;

  // value method master_m_arid
  output [3 : 0] master_ARID;

  // action method master_m_arready
  input  master_ARREADY;

  // action method master_m_rvalid
  input  master_RVALID;
  input  [1 : 0] master_RRESP;
  input  [63 : 0] master_RDATA;
  input  master_RLAST;
  input  [3 : 0] master_RID;

  // value method master_m_rready
  output master_RREADY;

  // action method slave_m_awvalid
  input  slave_AWVALID;
  input  [31 : 0] slave_AWADDR;
  input  [2 : 0] slave_AWSIZE;
  input  [2 : 0] slave_AWPROT;
  input  [7 : 0] slave_AWLEN;
  input  [1 : 0] slave_AWBURST;
  input  [3 : 0] slave_AWID;

  // value method slave_m_awready
  output slave_AWREADY;

  // action method slave_m_wvalid
  input  slave_WVALID;
  input  [63 : 0] slave_WDATA;
  input  [7 : 0] slave_WSTRB;
  input  slave_WLAST;
  input  [3 : 0] slave_WID;

  // value method slave_m_wready
  output slave_WREADY;

  // value method slave_m_bvalid
  output slave_BVALID;

  // value method slave_m_bresp
  output [1 : 0] slave_BRESP;

  // value method slave_m_buser

  // value method slave_m_bid
  output [3 : 0] slave_BID;

  // action method slave_m_bready
  input  slave_BREADY;

  // action method slave_m_arvalid
  input  slave_ARVALID;
  input  [31 : 0] slave_ARADDR;
  input  [2 : 0] slave_ARSIZE;
  input  [2 : 0] slave_ARPROT;
  input  [7 : 0] slave_ARLEN;
  input  [1 : 0] slave_ARBURST;
  input  [3 : 0] slave_ARID;

  // value method slave_m_arready
  output slave_ARREADY;

  // value method slave_m_rvalid
  output slave_RVALID;

  // value method slave_m_rresp
  output [1 : 0] slave_RRESP;

  // value method slave_m_rdata
  output [63 : 0] slave_RDATA;

  // value method slave_m_rlast
  output slave_RLAST;

  // value method slave_m_ruser

  // value method slave_m_rid
  output [3 : 0] slave_RID;

  // action method slave_m_rready
  input  slave_RREADY;

  // signals for module outputs
  wire [63 : 0] master_WDATA, slave_RDATA;
  wire [31 : 0] master_ARADDR, master_AWADDR;
  wire [7 : 0] master_ARLEN, master_AWLEN, master_WSTRB;
  wire [3 : 0] master_ARID, master_AWID, master_WID, slave_BID, slave_RID;
  wire [2 : 0] master_ARPROT, master_ARSIZE, master_AWPROT, master_AWSIZE;
  wire [1 : 0] master_ARBURST, master_AWBURST, slave_BRESP, slave_RRESP;
  wire master_ARVALID,
       master_AWVALID,
       master_BREADY,
       master_RREADY,
       master_WLAST,
       master_WVALID,
       slave_ARREADY,
       slave_AWREADY,
       slave_BVALID,
       slave_RLAST,
       slave_RVALID,
       slave_WREADY;

  // register dataarray_0
  reg [31 : 0] dataarray_0;
  wire [31 : 0] dataarray_0_D_IN;
  wire dataarray_0_EN;

  // register dataarray_1
  reg [31 : 0] dataarray_1;
  wire [31 : 0] dataarray_1_D_IN;
  wire dataarray_1_EN;

  // register dump
  reg [31 : 0] dump;
  wire [31 : 0] dump_D_IN;
  wire dump_EN;

  // register rg_cnt
  reg [4 : 0] rg_cnt;
  wire [4 : 0] rg_cnt_D_IN;
  wire rg_cnt_EN;

  // register rg_end_address
  reg [31 : 0] rg_end_address;
  wire [31 : 0] rg_end_address_D_IN;
  wire rg_end_address_EN;

  // register rg_start
  reg rg_start;
  wire rg_start_D_IN, rg_start_EN;

  // register rg_start_address
  reg [31 : 0] rg_start_address;
  wire [31 : 0] rg_start_address_D_IN;
  wire rg_start_address_EN;

  // register rg_total_count
  reg [31 : 0] rg_total_count;
  wire [31 : 0] rg_total_count_D_IN;
  wire rg_total_count_EN;

  // register rg_word_count
  reg rg_word_count;
  wire rg_word_count_D_IN, rg_word_count_EN;

  // ports of submodule ff_lower_order_bits
  wire [2 : 0] ff_lower_order_bits_D_IN, ff_lower_order_bits_D_OUT;
  wire ff_lower_order_bits_CLR,
       ff_lower_order_bits_DEQ,
       ff_lower_order_bits_EMPTY_N,
       ff_lower_order_bits_ENQ,
       ff_lower_order_bits_FULL_N;

  // ports of submodule m_xactor_f_rd_addr
  wire [51 : 0] m_xactor_f_rd_addr_D_IN, m_xactor_f_rd_addr_D_OUT;
  wire m_xactor_f_rd_addr_CLR,
       m_xactor_f_rd_addr_DEQ,
       m_xactor_f_rd_addr_EMPTY_N,
       m_xactor_f_rd_addr_ENQ,
       m_xactor_f_rd_addr_FULL_N;

  // ports of submodule m_xactor_f_rd_data
  wire [70 : 0] m_xactor_f_rd_data_D_IN, m_xactor_f_rd_data_D_OUT;
  wire m_xactor_f_rd_data_CLR,
       m_xactor_f_rd_data_DEQ,
       m_xactor_f_rd_data_EMPTY_N,
       m_xactor_f_rd_data_ENQ,
       m_xactor_f_rd_data_FULL_N;

  // ports of submodule m_xactor_f_wr_addr
  wire [51 : 0] m_xactor_f_wr_addr_D_IN, m_xactor_f_wr_addr_D_OUT;
  wire m_xactor_f_wr_addr_CLR,
       m_xactor_f_wr_addr_DEQ,
       m_xactor_f_wr_addr_EMPTY_N,
       m_xactor_f_wr_addr_ENQ;

  // ports of submodule m_xactor_f_wr_data
  wire [76 : 0] m_xactor_f_wr_data_D_IN, m_xactor_f_wr_data_D_OUT;
  wire m_xactor_f_wr_data_CLR,
       m_xactor_f_wr_data_DEQ,
       m_xactor_f_wr_data_EMPTY_N,
       m_xactor_f_wr_data_ENQ;

  // ports of submodule m_xactor_f_wr_resp
  wire [5 : 0] m_xactor_f_wr_resp_D_IN;
  wire m_xactor_f_wr_resp_CLR,
       m_xactor_f_wr_resp_DEQ,
       m_xactor_f_wr_resp_ENQ,
       m_xactor_f_wr_resp_FULL_N;

  // ports of submodule s_xactor_f_rd_addr
  wire [51 : 0] s_xactor_f_rd_addr_D_IN;
  wire s_xactor_f_rd_addr_CLR,
       s_xactor_f_rd_addr_DEQ,
       s_xactor_f_rd_addr_ENQ,
       s_xactor_f_rd_addr_FULL_N;

  // ports of submodule s_xactor_f_rd_data
  wire [70 : 0] s_xactor_f_rd_data_D_IN, s_xactor_f_rd_data_D_OUT;
  wire s_xactor_f_rd_data_CLR,
       s_xactor_f_rd_data_DEQ,
       s_xactor_f_rd_data_EMPTY_N,
       s_xactor_f_rd_data_ENQ;

  // ports of submodule s_xactor_f_wr_addr
  wire [51 : 0] s_xactor_f_wr_addr_D_IN, s_xactor_f_wr_addr_D_OUT;
  wire s_xactor_f_wr_addr_CLR,
       s_xactor_f_wr_addr_DEQ,
       s_xactor_f_wr_addr_EMPTY_N,
       s_xactor_f_wr_addr_ENQ,
       s_xactor_f_wr_addr_FULL_N;

  // ports of submodule s_xactor_f_wr_data
  wire [76 : 0] s_xactor_f_wr_data_D_IN, s_xactor_f_wr_data_D_OUT;
  wire s_xactor_f_wr_data_CLR,
       s_xactor_f_wr_data_DEQ,
       s_xactor_f_wr_data_EMPTY_N,
       s_xactor_f_wr_data_ENQ,
       s_xactor_f_wr_data_FULL_N;

  // ports of submodule s_xactor_f_wr_resp
  wire [5 : 0] s_xactor_f_wr_resp_D_IN, s_xactor_f_wr_resp_D_OUT;
  wire s_xactor_f_wr_resp_CLR,
       s_xactor_f_wr_resp_DEQ,
       s_xactor_f_wr_resp_EMPTY_N,
       s_xactor_f_wr_resp_ENQ,
       s_xactor_f_wr_resp_FULL_N;

  // rule scheduling signals
  wire CAN_FIRE_RL_configure_registers,
       CAN_FIRE_RL_open_file,
       CAN_FIRE_RL_receive_response,
       CAN_FIRE_RL_send_request,
       CAN_FIRE_master_m_arready,
       CAN_FIRE_master_m_awready,
       CAN_FIRE_master_m_bvalid,
       CAN_FIRE_master_m_rvalid,
       CAN_FIRE_master_m_wready,
       CAN_FIRE_slave_m_arvalid,
       CAN_FIRE_slave_m_awvalid,
       CAN_FIRE_slave_m_bready,
       CAN_FIRE_slave_m_rready,
       CAN_FIRE_slave_m_wvalid,
       WILL_FIRE_RL_configure_registers,
       WILL_FIRE_RL_open_file,
       WILL_FIRE_RL_receive_response,
       WILL_FIRE_RL_send_request,
       WILL_FIRE_master_m_arready,
       WILL_FIRE_master_m_awready,
       WILL_FIRE_master_m_bvalid,
       WILL_FIRE_master_m_rvalid,
       WILL_FIRE_master_m_wready,
       WILL_FIRE_slave_m_arvalid,
       WILL_FIRE_slave_m_awvalid,
       WILL_FIRE_slave_m_bready,
       WILL_FIRE_slave_m_rready,
       WILL_FIRE_slave_m_wvalid;

  // inputs to muxes for submodule ports
  wire [31 : 0] MUX_rg_start_address_write_1__VAL_2,
		MUX_rg_total_count_write_1__VAL_1,
		MUX_rg_total_count_write_1__VAL_2;
  wire MUX_rg_start_write_1__SEL_1,
       MUX_rg_start_address_write_1__SEL_1,
       MUX_rg_start_address_write_1__SEL_2,
       MUX_rg_total_count_write_1__SEL_1;

  // declarations used by system tasks
  // synopsys translate_off
  reg [31 : 0] TASK_fopen___d3;
  reg [63 : 0] v__h2845;
  // synopsys translate_on

  // remaining internal signals
  reg [1 : 0] CASE_s_xactor_f_wr_addrD_OUT_BITS_23_TO_20_0x_ETC__q2;
  wire [63 : 0] m_xactor_f_rd_dataD_OUT_BITS_68_TO_5_SRL_lv_s_ETC__q3;
  wire [31 : 0] s_xactor_f_wr_dataD_OUT_BITS_44_TO_13_MINUS_r_ETC__q1;
  wire [5 : 0] lv_shift__h2565;
  wire rg_cnt_ULT_5___d2, rg_start_address_0_ULT_rg_end_address_6___d37;

  // value method master_m_awvalid
  assign master_AWVALID = m_xactor_f_wr_addr_EMPTY_N ;

  // value method master_m_awaddr
  assign master_AWADDR = m_xactor_f_wr_addr_D_OUT[51:20] ;

  // value method master_m_awprot
  assign master_AWPROT = m_xactor_f_wr_addr_D_OUT[19:17] ;

  // value method master_m_awlen
  assign master_AWLEN = m_xactor_f_wr_addr_D_OUT[16:9] ;

  // value method master_m_awsize
  assign master_AWSIZE = m_xactor_f_wr_addr_D_OUT[8:6] ;

  // value method master_m_awburst
  assign master_AWBURST = m_xactor_f_wr_addr_D_OUT[5:4] ;

  // value method master_m_awid
  assign master_AWID = m_xactor_f_wr_addr_D_OUT[3:0] ;

  // action method master_m_awready
  assign CAN_FIRE_master_m_awready = 1'd1 ;
  assign WILL_FIRE_master_m_awready = 1'd1 ;

  // value method master_m_wvalid
  assign master_WVALID = m_xactor_f_wr_data_EMPTY_N ;

  // value method master_m_wdata
  assign master_WDATA = m_xactor_f_wr_data_D_OUT[76:13] ;

  // value method master_m_wstrb
  assign master_WSTRB = m_xactor_f_wr_data_D_OUT[12:5] ;

  // value method master_m_wlast
  assign master_WLAST = m_xactor_f_wr_data_D_OUT[0] ;

  // value method master_m_wid
  assign master_WID = m_xactor_f_wr_data_D_OUT[4:1] ;

  // action method master_m_wready
  assign CAN_FIRE_master_m_wready = 1'd1 ;
  assign WILL_FIRE_master_m_wready = 1'd1 ;

  // action method master_m_bvalid
  assign CAN_FIRE_master_m_bvalid = 1'd1 ;
  assign WILL_FIRE_master_m_bvalid = 1'd1 ;

  // value method master_m_bready
  assign master_BREADY = m_xactor_f_wr_resp_FULL_N ;

  // value method master_m_arvalid
  assign master_ARVALID = m_xactor_f_rd_addr_EMPTY_N ;

  // value method master_m_araddr
  assign master_ARADDR = m_xactor_f_rd_addr_D_OUT[51:20] ;

  // value method master_m_arprot
  assign master_ARPROT = m_xactor_f_rd_addr_D_OUT[19:17] ;

  // value method master_m_arlen
  assign master_ARLEN = m_xactor_f_rd_addr_D_OUT[13:6] ;

  // value method master_m_arsize
  assign master_ARSIZE = m_xactor_f_rd_addr_D_OUT[16:14] ;

  // value method master_m_arburst
  assign master_ARBURST = m_xactor_f_rd_addr_D_OUT[5:4] ;

  // value method master_m_arid
  assign master_ARID = m_xactor_f_rd_addr_D_OUT[3:0] ;

  // action method master_m_arready
  assign CAN_FIRE_master_m_arready = 1'd1 ;
  assign WILL_FIRE_master_m_arready = 1'd1 ;

  // action method master_m_rvalid
  assign CAN_FIRE_master_m_rvalid = 1'd1 ;
  assign WILL_FIRE_master_m_rvalid = 1'd1 ;

  // value method master_m_rready
  assign master_RREADY = m_xactor_f_rd_data_FULL_N ;

  // action method slave_m_awvalid
  assign CAN_FIRE_slave_m_awvalid = 1'd1 ;
  assign WILL_FIRE_slave_m_awvalid = 1'd1 ;

  // value method slave_m_awready
  assign slave_AWREADY = s_xactor_f_wr_addr_FULL_N ;

  // action method slave_m_wvalid
  assign CAN_FIRE_slave_m_wvalid = 1'd1 ;
  assign WILL_FIRE_slave_m_wvalid = 1'd1 ;

  // value method slave_m_wready
  assign slave_WREADY = s_xactor_f_wr_data_FULL_N ;

  // value method slave_m_bvalid
  assign slave_BVALID = s_xactor_f_wr_resp_EMPTY_N ;

  // value method slave_m_bresp
  assign slave_BRESP = s_xactor_f_wr_resp_D_OUT[5:4] ;

  // value method slave_m_bid
  assign slave_BID = s_xactor_f_wr_resp_D_OUT[3:0] ;

  // action method slave_m_bready
  assign CAN_FIRE_slave_m_bready = 1'd1 ;
  assign WILL_FIRE_slave_m_bready = 1'd1 ;

  // action method slave_m_arvalid
  assign CAN_FIRE_slave_m_arvalid = 1'd1 ;
  assign WILL_FIRE_slave_m_arvalid = 1'd1 ;

  // value method slave_m_arready
  assign slave_ARREADY = s_xactor_f_rd_addr_FULL_N ;

  // value method slave_m_rvalid
  assign slave_RVALID = s_xactor_f_rd_data_EMPTY_N ;

  // value method slave_m_rresp
  assign slave_RRESP = s_xactor_f_rd_data_D_OUT[70:69] ;

  // value method slave_m_rdata
  assign slave_RDATA = s_xactor_f_rd_data_D_OUT[68:5] ;

  // value method slave_m_rlast
  assign slave_RLAST = s_xactor_f_rd_data_D_OUT[4] ;

  // value method slave_m_rid
  assign slave_RID = s_xactor_f_rd_data_D_OUT[3:0] ;

  // action method slave_m_rready
  assign CAN_FIRE_slave_m_rready = 1'd1 ;
  assign WILL_FIRE_slave_m_rready = 1'd1 ;

  // submodule ff_lower_order_bits
  SizedFIFO #(.p1width(32'd3),
	      .p2depth(32'd8),
	      .p3cntr_width(32'd3),
	      .guarded(1'd1)) ff_lower_order_bits(.RST(RST_N),
						  .CLK(CLK),
						  .D_IN(ff_lower_order_bits_D_IN),
						  .ENQ(ff_lower_order_bits_ENQ),
						  .DEQ(ff_lower_order_bits_DEQ),
						  .CLR(ff_lower_order_bits_CLR),
						  .D_OUT(ff_lower_order_bits_D_OUT),
						  .FULL_N(ff_lower_order_bits_FULL_N),
						  .EMPTY_N(ff_lower_order_bits_EMPTY_N));

  // submodule m_xactor_f_rd_addr
  FIFO2 #(.width(32'd52), .guarded(1'd1)) m_xactor_f_rd_addr(.RST(RST_N),
							     .CLK(CLK),
							     .D_IN(m_xactor_f_rd_addr_D_IN),
							     .ENQ(m_xactor_f_rd_addr_ENQ),
							     .DEQ(m_xactor_f_rd_addr_DEQ),
							     .CLR(m_xactor_f_rd_addr_CLR),
							     .D_OUT(m_xactor_f_rd_addr_D_OUT),
							     .FULL_N(m_xactor_f_rd_addr_FULL_N),
							     .EMPTY_N(m_xactor_f_rd_addr_EMPTY_N));

  // submodule m_xactor_f_rd_data
  FIFO2 #(.width(32'd71), .guarded(1'd1)) m_xactor_f_rd_data(.RST(RST_N),
							     .CLK(CLK),
							     .D_IN(m_xactor_f_rd_data_D_IN),
							     .ENQ(m_xactor_f_rd_data_ENQ),
							     .DEQ(m_xactor_f_rd_data_DEQ),
							     .CLR(m_xactor_f_rd_data_CLR),
							     .D_OUT(m_xactor_f_rd_data_D_OUT),
							     .FULL_N(m_xactor_f_rd_data_FULL_N),
							     .EMPTY_N(m_xactor_f_rd_data_EMPTY_N));

  // submodule m_xactor_f_wr_addr
  FIFO2 #(.width(32'd52), .guarded(1'd1)) m_xactor_f_wr_addr(.RST(RST_N),
							     .CLK(CLK),
							     .D_IN(m_xactor_f_wr_addr_D_IN),
							     .ENQ(m_xactor_f_wr_addr_ENQ),
							     .DEQ(m_xactor_f_wr_addr_DEQ),
							     .CLR(m_xactor_f_wr_addr_CLR),
							     .D_OUT(m_xactor_f_wr_addr_D_OUT),
							     .FULL_N(),
							     .EMPTY_N(m_xactor_f_wr_addr_EMPTY_N));

  // submodule m_xactor_f_wr_data
  FIFO2 #(.width(32'd77), .guarded(1'd1)) m_xactor_f_wr_data(.RST(RST_N),
							     .CLK(CLK),
							     .D_IN(m_xactor_f_wr_data_D_IN),
							     .ENQ(m_xactor_f_wr_data_ENQ),
							     .DEQ(m_xactor_f_wr_data_DEQ),
							     .CLR(m_xactor_f_wr_data_CLR),
							     .D_OUT(m_xactor_f_wr_data_D_OUT),
							     .FULL_N(),
							     .EMPTY_N(m_xactor_f_wr_data_EMPTY_N));

  // submodule m_xactor_f_wr_resp
  FIFO2 #(.width(32'd6), .guarded(1'd1)) m_xactor_f_wr_resp(.RST(RST_N),
							    .CLK(CLK),
							    .D_IN(m_xactor_f_wr_resp_D_IN),
							    .ENQ(m_xactor_f_wr_resp_ENQ),
							    .DEQ(m_xactor_f_wr_resp_DEQ),
							    .CLR(m_xactor_f_wr_resp_CLR),
							    .D_OUT(),
							    .FULL_N(m_xactor_f_wr_resp_FULL_N),
							    .EMPTY_N());

  // submodule s_xactor_f_rd_addr
  FIFO2 #(.width(32'd52), .guarded(1'd1)) s_xactor_f_rd_addr(.RST(RST_N),
							     .CLK(CLK),
							     .D_IN(s_xactor_f_rd_addr_D_IN),
							     .ENQ(s_xactor_f_rd_addr_ENQ),
							     .DEQ(s_xactor_f_rd_addr_DEQ),
							     .CLR(s_xactor_f_rd_addr_CLR),
							     .D_OUT(),
							     .FULL_N(s_xactor_f_rd_addr_FULL_N),
							     .EMPTY_N());

  // submodule s_xactor_f_rd_data
  FIFO2 #(.width(32'd71), .guarded(1'd1)) s_xactor_f_rd_data(.RST(RST_N),
							     .CLK(CLK),
							     .D_IN(s_xactor_f_rd_data_D_IN),
							     .ENQ(s_xactor_f_rd_data_ENQ),
							     .DEQ(s_xactor_f_rd_data_DEQ),
							     .CLR(s_xactor_f_rd_data_CLR),
							     .D_OUT(s_xactor_f_rd_data_D_OUT),
							     .FULL_N(),
							     .EMPTY_N(s_xactor_f_rd_data_EMPTY_N));

  // submodule s_xactor_f_wr_addr
  FIFO2 #(.width(32'd52), .guarded(1'd1)) s_xactor_f_wr_addr(.RST(RST_N),
							     .CLK(CLK),
							     .D_IN(s_xactor_f_wr_addr_D_IN),
							     .ENQ(s_xactor_f_wr_addr_ENQ),
							     .DEQ(s_xactor_f_wr_addr_DEQ),
							     .CLR(s_xactor_f_wr_addr_CLR),
							     .D_OUT(s_xactor_f_wr_addr_D_OUT),
							     .FULL_N(s_xactor_f_wr_addr_FULL_N),
							     .EMPTY_N(s_xactor_f_wr_addr_EMPTY_N));

  // submodule s_xactor_f_wr_data
  FIFO2 #(.width(32'd77), .guarded(1'd1)) s_xactor_f_wr_data(.RST(RST_N),
							     .CLK(CLK),
							     .D_IN(s_xactor_f_wr_data_D_IN),
							     .ENQ(s_xactor_f_wr_data_ENQ),
							     .DEQ(s_xactor_f_wr_data_DEQ),
							     .CLR(s_xactor_f_wr_data_CLR),
							     .D_OUT(s_xactor_f_wr_data_D_OUT),
							     .FULL_N(s_xactor_f_wr_data_FULL_N),
							     .EMPTY_N(s_xactor_f_wr_data_EMPTY_N));

  // submodule s_xactor_f_wr_resp
  FIFO2 #(.width(32'd6), .guarded(1'd1)) s_xactor_f_wr_resp(.RST(RST_N),
							    .CLK(CLK),
							    .D_IN(s_xactor_f_wr_resp_D_IN),
							    .ENQ(s_xactor_f_wr_resp_ENQ),
							    .DEQ(s_xactor_f_wr_resp_DEQ),
							    .CLR(s_xactor_f_wr_resp_CLR),
							    .D_OUT(s_xactor_f_wr_resp_D_OUT),
							    .FULL_N(s_xactor_f_wr_resp_FULL_N),
							    .EMPTY_N(s_xactor_f_wr_resp_EMPTY_N));

  // rule RL_open_file
  assign CAN_FIRE_RL_open_file = rg_cnt_ULT_5___d2 ;
  assign WILL_FIRE_RL_open_file = rg_cnt_ULT_5___d2 ;

  // rule RL_configure_registers
  assign CAN_FIRE_RL_configure_registers =
	     s_xactor_f_wr_addr_EMPTY_N && s_xactor_f_wr_data_EMPTY_N &&
	     s_xactor_f_wr_resp_FULL_N &&
	     !rg_start ;
  assign WILL_FIRE_RL_configure_registers = CAN_FIRE_RL_configure_registers ;

  // rule RL_send_request
  assign CAN_FIRE_RL_send_request =
	     m_xactor_f_rd_addr_FULL_N && ff_lower_order_bits_FULL_N &&
	     rg_start ;
  assign WILL_FIRE_RL_send_request = CAN_FIRE_RL_send_request ;

  // rule RL_receive_response
  assign CAN_FIRE_RL_receive_response =
	     m_xactor_f_rd_data_EMPTY_N && ff_lower_order_bits_EMPTY_N &&
	     !rg_cnt_ULT_5___d2 &&
	     rg_start ;
  assign WILL_FIRE_RL_receive_response = CAN_FIRE_RL_receive_response ;

  // inputs to muxes for submodule ports
  assign MUX_rg_start_write_1__SEL_1 =
	     WILL_FIRE_RL_configure_registers &&
	     s_xactor_f_wr_addr_D_OUT[23:20] == 4'h8 &&
	     rg_start_address != s_xactor_f_wr_data_D_OUT[44:13] ;
  assign MUX_rg_start_address_write_1__SEL_1 =
	     WILL_FIRE_RL_configure_registers &&
	     s_xactor_f_wr_addr_D_OUT[23:20] == 4'h0 ;
  assign MUX_rg_start_address_write_1__SEL_2 =
	     WILL_FIRE_RL_send_request &&
	     rg_start_address_0_ULT_rg_end_address_6___d37 ;
  assign MUX_rg_total_count_write_1__SEL_1 =
	     WILL_FIRE_RL_configure_registers &&
	     s_xactor_f_wr_addr_D_OUT[23:20] == 4'h8 ;
  assign MUX_rg_start_address_write_1__VAL_2 = rg_start_address + 32'd4 ;
  assign MUX_rg_total_count_write_1__VAL_1 =
	     { 2'd0,
	       s_xactor_f_wr_dataD_OUT_BITS_44_TO_13_MINUS_r_ETC__q1[31:2] } ;
  assign MUX_rg_total_count_write_1__VAL_2 = rg_total_count - 32'd1 ;

  // register dataarray_0
  assign dataarray_0_D_IN = 32'h0 ;
  assign dataarray_0_EN = 1'b0 ;

  // register dataarray_1
  assign dataarray_1_D_IN = 32'h0 ;
  assign dataarray_1_EN = 1'b0 ;

  // register dump
  assign dump_D_IN = TASK_fopen___d3 ;
  assign dump_EN = rg_cnt_ULT_5___d2 ;

  // register rg_cnt
  assign rg_cnt_D_IN = rg_cnt + 5'd1 ;
  assign rg_cnt_EN = rg_cnt_ULT_5___d2 ;

  // register rg_end_address
  assign rg_end_address_D_IN = s_xactor_f_wr_data_D_OUT[44:13] ;
  assign rg_end_address_EN = MUX_rg_total_count_write_1__SEL_1 ;

  // register rg_start
  assign rg_start_D_IN = MUX_rg_start_write_1__SEL_1 ;
  assign rg_start_EN =
	     WILL_FIRE_RL_configure_registers &&
	     s_xactor_f_wr_addr_D_OUT[23:20] == 4'h8 &&
	     rg_start_address != s_xactor_f_wr_data_D_OUT[44:13] ||
	     WILL_FIRE_RL_receive_response && rg_total_count == 32'd1 ;

  // register rg_start_address
  assign rg_start_address_D_IN =
	     MUX_rg_start_address_write_1__SEL_1 ?
	       s_xactor_f_wr_data_D_OUT[44:13] :
	       MUX_rg_start_address_write_1__VAL_2 ;
  assign rg_start_address_EN =
	     WILL_FIRE_RL_configure_registers &&
	     s_xactor_f_wr_addr_D_OUT[23:20] == 4'h0 ||
	     WILL_FIRE_RL_send_request &&
	     rg_start_address_0_ULT_rg_end_address_6___d37 ;

  // register rg_total_count
  assign rg_total_count_D_IN =
	     MUX_rg_total_count_write_1__SEL_1 ?
	       MUX_rg_total_count_write_1__VAL_1 :
	       MUX_rg_total_count_write_1__VAL_2 ;
  assign rg_total_count_EN =
	     WILL_FIRE_RL_configure_registers &&
	     s_xactor_f_wr_addr_D_OUT[23:20] == 4'h8 ||
	     WILL_FIRE_RL_receive_response ;

  // register rg_word_count
  assign rg_word_count_D_IN = 1'b0 ;
  assign rg_word_count_EN = 1'b0 ;

  // submodule ff_lower_order_bits
  assign ff_lower_order_bits_D_IN = rg_start_address[2:0] ;
  assign ff_lower_order_bits_ENQ = MUX_rg_start_address_write_1__SEL_2 ;
  assign ff_lower_order_bits_DEQ = CAN_FIRE_RL_receive_response ;
  assign ff_lower_order_bits_CLR = 1'b0 ;

  // submodule m_xactor_f_rd_addr
  assign m_xactor_f_rd_addr_D_IN =
	     { rg_start_address,
	       3'bxxx /* unspecified value */ ,
	       17'd32786 } ;
  assign m_xactor_f_rd_addr_ENQ = MUX_rg_start_address_write_1__SEL_2 ;
  assign m_xactor_f_rd_addr_DEQ =
	     m_xactor_f_rd_addr_EMPTY_N && master_ARREADY ;
  assign m_xactor_f_rd_addr_CLR = 1'b0 ;

  // submodule m_xactor_f_rd_data
  assign m_xactor_f_rd_data_D_IN =
	     { master_RRESP, master_RDATA, master_RLAST, master_RID } ;
  assign m_xactor_f_rd_data_ENQ = master_RVALID && m_xactor_f_rd_data_FULL_N ;
  assign m_xactor_f_rd_data_DEQ = CAN_FIRE_RL_receive_response ;
  assign m_xactor_f_rd_data_CLR = 1'b0 ;

  // submodule m_xactor_f_wr_addr
  assign m_xactor_f_wr_addr_D_IN = 52'h0 ;
  assign m_xactor_f_wr_addr_ENQ = 1'b0 ;
  assign m_xactor_f_wr_addr_DEQ =
	     m_xactor_f_wr_addr_EMPTY_N && master_AWREADY ;
  assign m_xactor_f_wr_addr_CLR = 1'b0 ;

  // submodule m_xactor_f_wr_data
  assign m_xactor_f_wr_data_D_IN = 77'h0 ;
  assign m_xactor_f_wr_data_ENQ = 1'b0 ;
  assign m_xactor_f_wr_data_DEQ =
	     m_xactor_f_wr_data_EMPTY_N && master_WREADY ;
  assign m_xactor_f_wr_data_CLR = 1'b0 ;

  // submodule m_xactor_f_wr_resp
  assign m_xactor_f_wr_resp_D_IN = { master_BRESP, master_BID } ;
  assign m_xactor_f_wr_resp_ENQ = master_BVALID && m_xactor_f_wr_resp_FULL_N ;
  assign m_xactor_f_wr_resp_DEQ = 1'b0 ;
  assign m_xactor_f_wr_resp_CLR = 1'b0 ;

  // submodule s_xactor_f_rd_addr
  assign s_xactor_f_rd_addr_D_IN =
	     { slave_ARADDR,
	       slave_ARPROT,
	       slave_ARSIZE,
	       slave_ARLEN,
	       slave_ARBURST,
	       slave_ARID } ;
  assign s_xactor_f_rd_addr_ENQ = slave_ARVALID && s_xactor_f_rd_addr_FULL_N ;
  assign s_xactor_f_rd_addr_DEQ = 1'b0 ;
  assign s_xactor_f_rd_addr_CLR = 1'b0 ;

  // submodule s_xactor_f_rd_data
  assign s_xactor_f_rd_data_D_IN = 71'h0 ;
  assign s_xactor_f_rd_data_ENQ = 1'b0 ;
  assign s_xactor_f_rd_data_DEQ = slave_RREADY && s_xactor_f_rd_data_EMPTY_N ;
  assign s_xactor_f_rd_data_CLR = 1'b0 ;

  // submodule s_xactor_f_wr_addr
  assign s_xactor_f_wr_addr_D_IN =
	     { slave_AWADDR,
	       slave_AWPROT,
	       slave_AWLEN,
	       slave_AWSIZE,
	       slave_AWBURST,
	       slave_AWID } ;
  assign s_xactor_f_wr_addr_ENQ = slave_AWVALID && s_xactor_f_wr_addr_FULL_N ;
  assign s_xactor_f_wr_addr_DEQ = CAN_FIRE_RL_configure_registers ;
  assign s_xactor_f_wr_addr_CLR = 1'b0 ;

  // submodule s_xactor_f_wr_data
  assign s_xactor_f_wr_data_D_IN =
	     { slave_WDATA, slave_WSTRB, slave_WID, slave_WLAST } ;
  assign s_xactor_f_wr_data_ENQ = slave_WVALID && s_xactor_f_wr_data_FULL_N ;
  assign s_xactor_f_wr_data_DEQ = CAN_FIRE_RL_configure_registers ;
  assign s_xactor_f_wr_data_CLR = 1'b0 ;

  // submodule s_xactor_f_wr_resp
  assign s_xactor_f_wr_resp_D_IN =
	     { CASE_s_xactor_f_wr_addrD_OUT_BITS_23_TO_20_0x_ETC__q2,
	       s_xactor_f_wr_addr_D_OUT[3:0] } ;
  assign s_xactor_f_wr_resp_ENQ = CAN_FIRE_RL_configure_registers ;
  assign s_xactor_f_wr_resp_DEQ = slave_BREADY && s_xactor_f_wr_resp_EMPTY_N ;
  assign s_xactor_f_wr_resp_CLR = 1'b0 ;

  // remaining internal signals
  assign lv_shift__h2565 = { ff_lower_order_bits_D_OUT, 3'd0 } ;
  assign m_xactor_f_rd_dataD_OUT_BITS_68_TO_5_SRL_lv_s_ETC__q3 =
	     m_xactor_f_rd_data_D_OUT[68:5] >> lv_shift__h2565 ;
  assign rg_cnt_ULT_5___d2 = rg_cnt < 5'd5 ;
  assign rg_start_address_0_ULT_rg_end_address_6___d37 =
	     rg_start_address < rg_end_address ;
  assign s_xactor_f_wr_dataD_OUT_BITS_44_TO_13_MINUS_r_ETC__q1 =
	     s_xactor_f_wr_data_D_OUT[44:13] - rg_start_address ;
  always@(s_xactor_f_wr_addr_D_OUT)
  begin
    case (s_xactor_f_wr_addr_D_OUT[23:20])
      4'h0, 4'h8:
	  CASE_s_xactor_f_wr_addrD_OUT_BITS_23_TO_20_0x_ETC__q2 = 2'd0;
      default: CASE_s_xactor_f_wr_addrD_OUT_BITS_23_TO_20_0x_ETC__q2 = 2'd2;
    endcase
  end

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        dataarray_0 <= `BSV_ASSIGNMENT_DELAY 32'd0;
	dataarray_1 <= `BSV_ASSIGNMENT_DELAY 32'd0;
	dump <= `BSV_ASSIGNMENT_DELAY 32'd0;
	rg_cnt <= `BSV_ASSIGNMENT_DELAY 5'd0;
	rg_end_address <= `BSV_ASSIGNMENT_DELAY 32'd0;
	rg_start <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rg_start_address <= `BSV_ASSIGNMENT_DELAY 32'd0;
	rg_total_count <= `BSV_ASSIGNMENT_DELAY 32'd0;
	rg_word_count <= `BSV_ASSIGNMENT_DELAY 1'd1;
      end
    else
      begin
        if (dataarray_0_EN)
	  dataarray_0 <= `BSV_ASSIGNMENT_DELAY dataarray_0_D_IN;
	if (dataarray_1_EN)
	  dataarray_1 <= `BSV_ASSIGNMENT_DELAY dataarray_1_D_IN;
	if (dump_EN) dump <= `BSV_ASSIGNMENT_DELAY dump_D_IN;
	if (rg_cnt_EN) rg_cnt <= `BSV_ASSIGNMENT_DELAY rg_cnt_D_IN;
	if (rg_end_address_EN)
	  rg_end_address <= `BSV_ASSIGNMENT_DELAY rg_end_address_D_IN;
	if (rg_start_EN) rg_start <= `BSV_ASSIGNMENT_DELAY rg_start_D_IN;
	if (rg_start_address_EN)
	  rg_start_address <= `BSV_ASSIGNMENT_DELAY rg_start_address_D_IN;
	if (rg_total_count_EN)
	  rg_total_count <= `BSV_ASSIGNMENT_DELAY rg_total_count_D_IN;
	if (rg_word_count_EN)
	  rg_word_count <= `BSV_ASSIGNMENT_DELAY rg_word_count_D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    dataarray_0 = 32'hAAAAAAAA;
    dataarray_1 = 32'hAAAAAAAA;
    dump = 32'hAAAAAAAA;
    rg_cnt = 5'h0A;
    rg_end_address = 32'hAAAAAAAA;
    rg_start = 1'h0;
    rg_start_address = 32'hAAAAAAAA;
    rg_total_count = 32'hAAAAAAAA;
    rg_word_count = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_open_file)
	begin
	  TASK_fopen___d3 = $fopen("signature", "w");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_open_file && TASK_fopen___d3 == 32'd0)
	$display("cannot open %s", "signature");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_open_file && TASK_fopen___d3 == 32'd0) $finish(32'd0);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_configure_registers &&
	  s_xactor_f_wr_addr_D_OUT[23:20] == 4'hC)
	$finish(32'd0);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_receive_response)
	$fwrite(dump,
		"%4h\n",
		m_xactor_f_rd_dataD_OUT_BITS_68_TO_5_SRL_lv_s_ETC__q3[31:0]);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_receive_response &&
	  m_xactor_f_rd_data_D_OUT[70:69] != 2'd0)
	begin
	  v__h2845 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_receive_response &&
	  m_xactor_f_rd_data_D_OUT[70:69] != 2'd0)
	$display(v__h2845, "\tSIGNATUREDUMP got Bus Error");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_receive_response &&
	  m_xactor_f_rd_data_D_OUT[70:69] != 2'd0)
	$finish(32'd0);
  end
  // synopsys translate_on
endmodule  // mksign_dump

