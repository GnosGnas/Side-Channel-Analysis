//
// Generated by Bluespec Compiler, version 2018.10.beta1 (build e1df8052c, 2018-10-17)
//
// On Wed Jul  3 23:07:43 IST 2019
//
//
// Ports:
// Name                         I/O  size props
// coe_rs232_modem_output_stx     O     1 reg
// coe_rs232_modem_output_rts     O     1 reg
// coe_rs232_modem_output_dtr     O     1 reg
// RDY_slave_axi_uart_m_awvalid   O     1
// slave_axi_uart_awready         O     1
// RDY_slave_axi_uart_m_wvalid    O     1
// slave_axi_uart_wready          O     1
// slave_axi_uart_bvalid          O     1 reg
// slave_axi_uart_bresp           O     2 reg
// slave_axi_uart_buser           O    10 reg
// slave_axi_uart_bid             O     4 reg
// slave_axi_uart_arready         O     1
// slave_axi_uart_rvalid          O     1 reg
// slave_axi_uart_rresp           O     2 reg
// slave_axi_uart_rdata           O    64 reg
// slave_axi_uart_rlast           O     1 reg
// slave_axi_uart_ruser           O    10 reg
// slave_axi_uart_rid             O     4 reg
// irq                            O     1
// csi_clockreset_clk             I     1 clock
// csi_clockreset_reset_n         I     1 reset
// coe_rs232_modem_input_srx      I     1 reg
// coe_rs232_modem_input_cts      I     1 reg
// coe_rs232_modem_input_dsr      I     1 reg
// coe_rs232_modem_input_ri       I     1 reg
// coe_rs232_modem_input_dcd      I     1 reg
// slave_axi_uart_m_awvalid_awvalid  I     1
// slave_axi_uart_m_awvalid_awaddr  I    32 reg
// slave_axi_uart_m_awvalid_awprot  I     3 reg
// slave_axi_uart_m_awvalid_awuser  I    10 reg
// slave_axi_uart_m_awvalid_awlen  I     8 reg
// slave_axi_uart_m_awvalid_awsize  I     3 reg
// slave_axi_uart_m_awvalid_awburst  I     2 reg
// slave_axi_uart_m_awvalid_awlock  I     1 reg
// slave_axi_uart_m_awvalid_awcache  I     4 reg
// slave_axi_uart_m_awvalid_awqos  I     4 reg
// slave_axi_uart_m_awvalid_awregion  I     4 reg
// slave_axi_uart_m_awvalid_awid  I     4 reg
// slave_axi_uart_m_wvalid_wvalid  I     1
// slave_axi_uart_m_wvalid_wdata  I    64 reg
// slave_axi_uart_m_wvalid_wstrb  I     8 reg
// slave_axi_uart_m_wvalid_wlast  I     1 reg
// slave_axi_uart_m_wvalid_wid    I     4 reg
// slave_axi_uart_m_bready_bready  I     1
// slave_axi_uart_m_arvalid_arvalid  I     1
// slave_axi_uart_m_arvalid_araddr  I    32 reg
// slave_axi_uart_m_arvalid_arprot  I     3 reg
// slave_axi_uart_m_arvalid_aruser  I    10 reg
// slave_axi_uart_m_arvalid_arlen  I     8 reg
// slave_axi_uart_m_arvalid_arsize  I     3 reg
// slave_axi_uart_m_arvalid_arburst  I     2 reg
// slave_axi_uart_m_arvalid_arlock  I     1 reg
// slave_axi_uart_m_arvalid_arcache  I     4 reg
// slave_axi_uart_m_arvalid_arqos  I     4 reg
// slave_axi_uart_m_arvalid_arregion  I     4 reg
// slave_axi_uart_m_arvalid_arid  I     4 reg
// slave_axi_uart_m_rready_rready  I     1
// EN_slave_axi_uart_m_awvalid    I     1
// EN_slave_axi_uart_m_wvalid     I     1
//
// Combinational paths from inputs to outputs:
//   slave_axi_uart_m_bready_bready -> RDY_slave_axi_uart_m_awvalid
//   slave_axi_uart_m_bready_bready -> slave_axi_uart_awready
//   slave_axi_uart_m_bready_bready -> RDY_slave_axi_uart_m_wvalid
//   slave_axi_uart_m_bready_bready -> slave_axi_uart_wready
//   slave_axi_uart_m_rready_rready -> slave_axi_uart_arready
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkUart16550(csi_clockreset_clk,
		   csi_clockreset_reset_n,

		   coe_rs232_modem_input_srx,
		   coe_rs232_modem_input_cts,
		   coe_rs232_modem_input_dsr,
		   coe_rs232_modem_input_ri,
		   coe_rs232_modem_input_dcd,

		   coe_rs232_modem_output_stx,

		   coe_rs232_modem_output_rts,

		   coe_rs232_modem_output_dtr,

		   slave_axi_uart_m_awvalid_awvalid,
		   slave_axi_uart_m_awvalid_awaddr,
		   slave_axi_uart_m_awvalid_awprot,
		   slave_axi_uart_m_awvalid_awuser,
		   slave_axi_uart_m_awvalid_awlen,
		   slave_axi_uart_m_awvalid_awsize,
		   slave_axi_uart_m_awvalid_awburst,
		   slave_axi_uart_m_awvalid_awlock,
		   slave_axi_uart_m_awvalid_awcache,
		   slave_axi_uart_m_awvalid_awqos,
		   slave_axi_uart_m_awvalid_awregion,
		   slave_axi_uart_m_awvalid_awid,
		   EN_slave_axi_uart_m_awvalid,
		   RDY_slave_axi_uart_m_awvalid,

		   slave_axi_uart_awready,

		   slave_axi_uart_m_wvalid_wvalid,
		   slave_axi_uart_m_wvalid_wdata,
		   slave_axi_uart_m_wvalid_wstrb,
		   slave_axi_uart_m_wvalid_wlast,
		   slave_axi_uart_m_wvalid_wid,
		   EN_slave_axi_uart_m_wvalid,
		   RDY_slave_axi_uart_m_wvalid,

		   slave_axi_uart_wready,

		   slave_axi_uart_bvalid,

		   slave_axi_uart_bresp,

		   slave_axi_uart_buser,

		   slave_axi_uart_bid,

		   slave_axi_uart_m_bready_bready,

		   slave_axi_uart_m_arvalid_arvalid,
		   slave_axi_uart_m_arvalid_araddr,
		   slave_axi_uart_m_arvalid_arprot,
		   slave_axi_uart_m_arvalid_aruser,
		   slave_axi_uart_m_arvalid_arlen,
		   slave_axi_uart_m_arvalid_arsize,
		   slave_axi_uart_m_arvalid_arburst,
		   slave_axi_uart_m_arvalid_arlock,
		   slave_axi_uart_m_arvalid_arcache,
		   slave_axi_uart_m_arvalid_arqos,
		   slave_axi_uart_m_arvalid_arregion,
		   slave_axi_uart_m_arvalid_arid,

		   slave_axi_uart_arready,

		   slave_axi_uart_rvalid,

		   slave_axi_uart_rresp,

		   slave_axi_uart_rdata,

		   slave_axi_uart_rlast,

		   slave_axi_uart_ruser,

		   slave_axi_uart_rid,

		   slave_axi_uart_m_rready_rready,

		   irq);
  input  csi_clockreset_clk;
  input  csi_clockreset_reset_n;

  // action method coe_rs232_modem_input
  input  coe_rs232_modem_input_srx;
  input  coe_rs232_modem_input_cts;
  input  coe_rs232_modem_input_dsr;
  input  coe_rs232_modem_input_ri;
  input  coe_rs232_modem_input_dcd;

  // value method coe_rs232_modem_output_stx
  output coe_rs232_modem_output_stx;

  // value method coe_rs232_modem_output_rts
  output coe_rs232_modem_output_rts;

  // value method coe_rs232_modem_output_dtr
  output coe_rs232_modem_output_dtr;

  // action method slave_axi_uart_m_awvalid
  input  slave_axi_uart_m_awvalid_awvalid;
  input  [31 : 0] slave_axi_uart_m_awvalid_awaddr;
  input  [2 : 0] slave_axi_uart_m_awvalid_awprot;
  input  [9 : 0] slave_axi_uart_m_awvalid_awuser;
  input  [7 : 0] slave_axi_uart_m_awvalid_awlen;
  input  [2 : 0] slave_axi_uart_m_awvalid_awsize;
  input  [1 : 0] slave_axi_uart_m_awvalid_awburst;
  input  slave_axi_uart_m_awvalid_awlock;
  input  [3 : 0] slave_axi_uart_m_awvalid_awcache;
  input  [3 : 0] slave_axi_uart_m_awvalid_awqos;
  input  [3 : 0] slave_axi_uart_m_awvalid_awregion;
  input  [3 : 0] slave_axi_uart_m_awvalid_awid;
  input  EN_slave_axi_uart_m_awvalid;
  output RDY_slave_axi_uart_m_awvalid;

  // value method slave_axi_uart_m_awready
  output slave_axi_uart_awready;

  // action method slave_axi_uart_m_wvalid
  input  slave_axi_uart_m_wvalid_wvalid;
  input  [63 : 0] slave_axi_uart_m_wvalid_wdata;
  input  [7 : 0] slave_axi_uart_m_wvalid_wstrb;
  input  slave_axi_uart_m_wvalid_wlast;
  input  [3 : 0] slave_axi_uart_m_wvalid_wid;
  input  EN_slave_axi_uart_m_wvalid;
  output RDY_slave_axi_uart_m_wvalid;

  // value method slave_axi_uart_m_wready
  output slave_axi_uart_wready;

  // value method slave_axi_uart_m_bvalid
  output slave_axi_uart_bvalid;

  // value method slave_axi_uart_m_bresp
  output [1 : 0] slave_axi_uart_bresp;

  // value method slave_axi_uart_m_buser
  output [9 : 0] slave_axi_uart_buser;

  // value method slave_axi_uart_m_bid
  output [3 : 0] slave_axi_uart_bid;

  // action method slave_axi_uart_m_bready
  input  slave_axi_uart_m_bready_bready;

  // action method slave_axi_uart_m_arvalid
  input  slave_axi_uart_m_arvalid_arvalid;
  input  [31 : 0] slave_axi_uart_m_arvalid_araddr;
  input  [2 : 0] slave_axi_uart_m_arvalid_arprot;
  input  [9 : 0] slave_axi_uart_m_arvalid_aruser;
  input  [7 : 0] slave_axi_uart_m_arvalid_arlen;
  input  [2 : 0] slave_axi_uart_m_arvalid_arsize;
  input  [1 : 0] slave_axi_uart_m_arvalid_arburst;
  input  slave_axi_uart_m_arvalid_arlock;
  input  [3 : 0] slave_axi_uart_m_arvalid_arcache;
  input  [3 : 0] slave_axi_uart_m_arvalid_arqos;
  input  [3 : 0] slave_axi_uart_m_arvalid_arregion;
  input  [3 : 0] slave_axi_uart_m_arvalid_arid;

  // value method slave_axi_uart_m_arready
  output slave_axi_uart_arready;

  // value method slave_axi_uart_m_rvalid
  output slave_axi_uart_rvalid;

  // value method slave_axi_uart_m_rresp
  output [1 : 0] slave_axi_uart_rresp;

  // value method slave_axi_uart_m_rdata
  output [63 : 0] slave_axi_uart_rdata;

  // value method slave_axi_uart_m_rlast
  output slave_axi_uart_rlast;

  // value method slave_axi_uart_m_ruser
  output [9 : 0] slave_axi_uart_ruser;

  // value method slave_axi_uart_m_rid
  output [3 : 0] slave_axi_uart_rid;

  // action method slave_axi_uart_m_rready
  input  slave_axi_uart_m_rready_rready;

  // value method irq
  output irq;

  // signals for module outputs
  wire [63 : 0] slave_axi_uart_rdata;
  wire [9 : 0] slave_axi_uart_buser, slave_axi_uart_ruser;
  wire [3 : 0] slave_axi_uart_bid, slave_axi_uart_rid;
  wire [1 : 0] slave_axi_uart_bresp, slave_axi_uart_rresp;
  wire RDY_slave_axi_uart_m_awvalid,
       RDY_slave_axi_uart_m_wvalid,
       coe_rs232_modem_output_dtr,
       coe_rs232_modem_output_rts,
       coe_rs232_modem_output_stx,
       irq,
       slave_axi_uart_arready,
       slave_axi_uart_awready,
       slave_axi_uart_bvalid,
       slave_axi_uart_rlast,
       slave_axi_uart_rvalid,
       slave_axi_uart_wready;

  // inlined wires
  wire [16 : 0] dl_update$wget;
  wire [10 : 0] rx_fifo_first$wget;
  wire count_error_down$whas,
       count_error_up$whas,
       dl_update$whas,
       ms_int_r$whas,
       ms_int_s$whas,
       msr_save_pin_state$whas,
       rda_int_r$whas,
       rls_int_r$whas,
       rls_int_s$whas,
       rx_fifo_clear_pw$whas,
       rx_fifo_r_clr$whas,
       rx_fifo_r_deq$whas,
       rx_fifo_r_enq$whas,
       thre_int_edge_s$whas,
       thre_int_r$whas,
       thre_int_s$whas,
       ti_int_edge_s$whas,
       ti_int_r$whas,
       ti_int_s$whas,
       uart_rx_counter_t_preset$whas;

  // register count_error
  reg [16 : 0] count_error;
  wire [16 : 0] count_error$D_IN;
  wire count_error$EN;

  // register dl
  reg [15 : 0] dl;
  wire [15 : 0] dl$D_IN;
  wire dl$EN;

  // register dl1r
  reg [7 : 0] dl1r;
  wire [7 : 0] dl1r$D_IN;
  wire dl1r$EN;

  // register dl2r
  reg [7 : 0] dl2r;
  wire [7 : 0] dl2r$D_IN;
  wire dl2r$EN;

  // register dlc
  reg [15 : 0] dlc;
  wire [15 : 0] dlc$D_IN;
  wire dlc$EN;

  // register enable
  reg enable;
  wire enable$D_IN, enable$EN;

  // register fcr
  reg [1 : 0] fcr;
  wire [1 : 0] fcr$D_IN;
  wire fcr$EN;

  // register ier
  reg [3 : 0] ier;
  wire [3 : 0] ier$D_IN;
  wire ier$EN;

  // register lcr
  reg [7 : 0] lcr;
  wire [7 : 0] lcr$D_IN;
  wire lcr$EN;

  // register lsr
  reg [7 : 0] lsr;
  wire [7 : 0] lsr$D_IN;
  wire lsr$EN;

  // register mcr
  reg [4 : 0] mcr;
  wire [4 : 0] mcr$D_IN;
  wire mcr$EN;

  // register ms_int_q
  reg ms_int_q;
  wire ms_int_q$D_IN, ms_int_q$EN;

  // register ms_int_r_prev
  reg ms_int_r_prev;
  wire ms_int_r_prev$D_IN, ms_int_r_prev$EN;

  // register ms_int_s_prev
  reg ms_int_s_prev;
  wire ms_int_s_prev$D_IN, ms_int_s_prev$EN;

  // register msr
  reg [7 : 0] msr;
  wire [7 : 0] msr$D_IN;
  wire msr$EN;

  // register pin_cts
  reg pin_cts;
  wire pin_cts$D_IN, pin_cts$EN;

  // register pin_cts_c
  reg pin_cts_c;
  wire pin_cts_c$D_IN, pin_cts_c$EN;

  // register pin_cts_sync
  reg pin_cts_sync;
  wire pin_cts_sync$D_IN, pin_cts_sync$EN;

  // register pin_dcd
  reg pin_dcd;
  wire pin_dcd$D_IN, pin_dcd$EN;

  // register pin_dcd_c
  reg pin_dcd_c;
  wire pin_dcd_c$D_IN, pin_dcd_c$EN;

  // register pin_dcd_sync
  reg pin_dcd_sync;
  wire pin_dcd_sync$D_IN, pin_dcd_sync$EN;

  // register pin_dsr
  reg pin_dsr;
  wire pin_dsr$D_IN, pin_dsr$EN;

  // register pin_dsr_c
  reg pin_dsr_c;
  wire pin_dsr_c$D_IN, pin_dsr_c$EN;

  // register pin_dsr_sync
  reg pin_dsr_sync;
  wire pin_dsr_sync$D_IN, pin_dsr_sync$EN;

  // register pin_dtr
  reg pin_dtr;
  wire pin_dtr$D_IN, pin_dtr$EN;

  // register pin_ri
  reg pin_ri;
  wire pin_ri$D_IN, pin_ri$EN;

  // register pin_ri_c
  reg pin_ri_c;
  wire pin_ri_c$D_IN, pin_ri_c$EN;

  // register pin_ri_sync
  reg pin_ri_sync;
  wire pin_ri_sync$D_IN, pin_ri_sync$EN;

  // register pin_rts
  reg pin_rts;
  wire pin_rts$D_IN, pin_rts$EN;

  // register pin_srx
  reg pin_srx;
  wire pin_srx$D_IN, pin_srx$EN;

  // register pin_srx_c
  reg pin_srx_c;
  wire pin_srx_c$D_IN, pin_srx_c$EN;

  // register pin_srx_sync
  reg pin_srx_sync;
  wire pin_srx_sync$D_IN, pin_srx_sync$EN;

  // register pin_stx
  reg pin_stx;
  wire pin_stx$D_IN, pin_stx$EN;

  // register prev_cts
  reg prev_cts;
  wire prev_cts$D_IN, prev_cts$EN;

  // register prev_dcd
  reg prev_dcd;
  wire prev_dcd$D_IN, prev_dcd$EN;

  // register prev_dsr
  reg prev_dsr;
  wire prev_dsr$D_IN, prev_dsr$EN;

  // register prev_ri
  reg prev_ri;
  wire prev_ri$D_IN, prev_ri$EN;

  // register rda_int_q
  reg rda_int_q;
  wire rda_int_q$D_IN, rda_int_q$EN;

  // register rda_int_r_prev
  reg rda_int_r_prev;
  wire rda_int_r_prev$D_IN, rda_int_r_prev$EN;

  // register rda_int_s_prev
  reg rda_int_s_prev;
  wire rda_int_s_prev$D_IN, rda_int_s_prev$EN;

  // register rls_int_q
  reg rls_int_q;
  wire rls_int_q$D_IN, rls_int_q$EN;

  // register rls_int_r_prev
  reg rls_int_r_prev;
  wire rls_int_r_prev$D_IN, rls_int_r_prev$EN;

  // register rls_int_s_prev
  reg rls_int_s_prev;
  wire rls_int_s_prev$D_IN, rls_int_s_prev$EN;

  // register rx_fifo_countReg
  reg [4 : 0] rx_fifo_countReg;
  wire [4 : 0] rx_fifo_countReg$D_IN;
  wire rx_fifo_countReg$EN;

  // register scratch
  reg [7 : 0] scratch;
  wire [7 : 0] scratch$D_IN;
  wire scratch$EN;

  // register thre_int_q
  reg thre_int_q;
  wire thre_int_q$D_IN, thre_int_q$EN;

  // register thre_int_r_prev
  reg thre_int_r_prev;
  wire thre_int_r_prev$D_IN, thre_int_r_prev$EN;

  // register thre_int_s_prev
  reg thre_int_s_prev;
  wire thre_int_s_prev$D_IN, thre_int_s_prev$EN;

  // register ti_int_q
  reg ti_int_q;
  wire ti_int_q$D_IN, ti_int_q$EN;

  // register ti_int_r_prev
  reg ti_int_r_prev;
  wire ti_int_r_prev$D_IN, ti_int_r_prev$EN;

  // register ti_int_s_prev
  reg ti_int_s_prev;
  wire ti_int_s_prev$D_IN, ti_int_s_prev$EN;

  // register uart_rx_counter_b
  reg [7 : 0] uart_rx_counter_b;
  wire [7 : 0] uart_rx_counter_b$D_IN;
  wire uart_rx_counter_b$EN;

  // register uart_rx_counter_t
  reg [9 : 0] uart_rx_counter_t;
  wire [9 : 0] uart_rx_counter_t$D_IN;
  wire uart_rx_counter_t$EN;

  // register uart_rx_last_rstate
  reg [3 : 0] uart_rx_last_rstate;
  wire [3 : 0] uart_rx_last_rstate$D_IN;
  wire uart_rx_last_rstate$EN;

  // register uart_rx_rbit_counter
  reg [2 : 0] uart_rx_rbit_counter;
  wire [2 : 0] uart_rx_rbit_counter$D_IN;
  wire uart_rx_rbit_counter$EN;

  // register uart_rx_rcounter
  reg [3 : 0] uart_rx_rcounter;
  reg [3 : 0] uart_rx_rcounter$D_IN;
  wire uart_rx_rcounter$EN;

  // register uart_rx_rframing_error
  reg uart_rx_rframing_error;
  wire uart_rx_rframing_error$D_IN, uart_rx_rframing_error$EN;

  // register uart_rx_rparity
  reg uart_rx_rparity;
  wire uart_rx_rparity$D_IN, uart_rx_rparity$EN;

  // register uart_rx_rparity_error
  reg uart_rx_rparity_error;
  wire uart_rx_rparity_error$D_IN, uart_rx_rparity_error$EN;

  // register uart_rx_rparity_xor
  reg uart_rx_rparity_xor;
  wire uart_rx_rparity_xor$D_IN, uart_rx_rparity_xor$EN;

  // register uart_rx_rshift
  reg [7 : 0] uart_rx_rshift;
  wire [7 : 0] uart_rx_rshift$D_IN;
  wire uart_rx_rshift$EN;

  // register uart_rx_rstate
  reg [3 : 0] uart_rx_rstate;
  reg [3 : 0] uart_rx_rstate$D_IN;
  wire uart_rx_rstate$EN;

  // register uart_rx_rx_stable
  reg uart_rx_rx_stable;
  wire uart_rx_rx_stable$D_IN, uart_rx_rx_stable$EN;

  // register uart_tx_bit_counter
  reg [2 : 0] uart_tx_bit_counter;
  wire [2 : 0] uart_tx_bit_counter$D_IN;
  wire uart_tx_bit_counter$EN;

  // register uart_tx_bit_out
  reg uart_tx_bit_out;
  wire uart_tx_bit_out$D_IN, uart_tx_bit_out$EN;

  // register uart_tx_counter
  reg [4 : 0] uart_tx_counter;
  wire [4 : 0] uart_tx_counter$D_IN;
  wire uart_tx_counter$EN;

  // register uart_tx_last_tstate
  reg [2 : 0] uart_tx_last_tstate;
  wire [2 : 0] uart_tx_last_tstate$D_IN;
  wire uart_tx_last_tstate$EN;

  // register uart_tx_parity_xor
  reg uart_tx_parity_xor;
  reg uart_tx_parity_xor$D_IN;
  wire uart_tx_parity_xor$EN;

  // register uart_tx_shift_out
  reg [6 : 0] uart_tx_shift_out;
  wire [6 : 0] uart_tx_shift_out$D_IN;
  wire uart_tx_shift_out$EN;

  // register uart_tx_stx_o_tmp
  reg uart_tx_stx_o_tmp;
  reg uart_tx_stx_o_tmp$D_IN;
  wire uart_tx_stx_o_tmp$EN;

  // register uart_tx_tstate
  reg [2 : 0] uart_tx_tstate;
  reg [2 : 0] uart_tx_tstate$D_IN;
  wire uart_tx_tstate$EN;

  // ports of submodule rx_fifo
  wire [10 : 0] rx_fifo$D_IN, rx_fifo$D_OUT;
  wire rx_fifo$CLR, rx_fifo$DEQ, rx_fifo$EMPTY_N, rx_fifo$ENQ, rx_fifo$FULL_N;

  // ports of submodule s_xactor_f_rd_addr
  wire [74 : 0] s_xactor_f_rd_addr$D_IN, s_xactor_f_rd_addr$D_OUT;
  wire s_xactor_f_rd_addr$CLR,
       s_xactor_f_rd_addr$DEQ,
       s_xactor_f_rd_addr$EMPTY_N,
       s_xactor_f_rd_addr$ENQ,
       s_xactor_f_rd_addr$FULL_N;

  // ports of submodule s_xactor_f_rd_data
  wire [80 : 0] s_xactor_f_rd_data$D_IN, s_xactor_f_rd_data$D_OUT;
  wire s_xactor_f_rd_data$CLR,
       s_xactor_f_rd_data$DEQ,
       s_xactor_f_rd_data$EMPTY_N,
       s_xactor_f_rd_data$ENQ,
       s_xactor_f_rd_data$FULL_N;

  // ports of submodule s_xactor_f_wr_addr
  wire [74 : 0] s_xactor_f_wr_addr$D_IN, s_xactor_f_wr_addr$D_OUT;
  wire s_xactor_f_wr_addr$CLR,
       s_xactor_f_wr_addr$DEQ,
       s_xactor_f_wr_addr$EMPTY_N,
       s_xactor_f_wr_addr$ENQ,
       s_xactor_f_wr_addr$FULL_N;

  // ports of submodule s_xactor_f_wr_data
  wire [76 : 0] s_xactor_f_wr_data$D_IN, s_xactor_f_wr_data$D_OUT;
  wire s_xactor_f_wr_data$CLR,
       s_xactor_f_wr_data$DEQ,
       s_xactor_f_wr_data$EMPTY_N,
       s_xactor_f_wr_data$ENQ,
       s_xactor_f_wr_data$FULL_N;

  // ports of submodule s_xactor_f_wr_resp
  wire [15 : 0] s_xactor_f_wr_resp$D_IN, s_xactor_f_wr_resp$D_OUT;
  wire s_xactor_f_wr_resp$CLR,
       s_xactor_f_wr_resp$DEQ,
       s_xactor_f_wr_resp$EMPTY_N,
       s_xactor_f_wr_resp$ENQ,
       s_xactor_f_wr_resp$FULL_N;

  // ports of submodule tx_fifo
  wire [7 : 0] tx_fifo$D_IN, tx_fifo$D_OUT;
  wire tx_fifo$CLR, tx_fifo$DEQ, tx_fifo$EMPTY_N, tx_fifo$ENQ, tx_fifo$FULL_N;

  // ports of submodule uart_rx_rx_fifo
  wire [10 : 0] uart_rx_rx_fifo$D_IN, uart_rx_rx_fifo$D_OUT;
  wire uart_rx_rx_fifo$CLR,
       uart_rx_rx_fifo$DEQ,
       uart_rx_rx_fifo$EMPTY_N,
       uart_rx_rx_fifo$ENQ,
       uart_rx_rx_fifo$FULL_N;

  // ports of submodule uart_tx_tx_fifo
  wire [7 : 0] uart_tx_tx_fifo$D_IN, uart_tx_tx_fifo$D_OUT;
  wire uart_tx_tx_fifo$CLR,
       uart_tx_tx_fifo$DEQ,
       uart_tx_tx_fifo$EMPTY_N,
       uart_tx_tx_fifo$ENQ,
       uart_tx_tx_fifo$FULL_N;

  // rule scheduling signals
  wire CAN_FIRE_RL_bypass_mrc_to_avoid_scheduling_loop,
       CAN_FIRE_RL_connect_pins_rx,
       CAN_FIRE_RL_connect_pins_tx,
       CAN_FIRE_RL_count_rx_errors,
       CAN_FIRE_RL_divisor_counter,
       CAN_FIRE_RL_fifo_status_bypass_to_avoid_scheduling_loop,
       CAN_FIRE_RL_forward_rx,
       CAN_FIRE_RL_forward_tx,
       CAN_FIRE_RL_forward_tx_clear,
       CAN_FIRE_RL_foward_lc_enable,
       CAN_FIRE_RL_handle_axi4_read,
       CAN_FIRE_RL_handle_axi4_write,
       CAN_FIRE_RL_handle_loopback_mode,
       CAN_FIRE_RL_interrupt_sources,
       CAN_FIRE_RL_loopback_mode_select,
       CAN_FIRE_RL_ms_int_handle_edges_history,
       CAN_FIRE_RL_ms_int_handle_edges_set,
       CAN_FIRE_RL_ms_int_handle_state_update,
       CAN_FIRE_RL_output_rts_dtr,
       CAN_FIRE_RL_rda_int_handle_edges_history,
       CAN_FIRE_RL_rda_int_handle_edges_set,
       CAN_FIRE_RL_rda_int_handle_state_update,
       CAN_FIRE_RL_rls_int_handle_edges_history,
       CAN_FIRE_RL_rls_int_handle_edges_set,
       CAN_FIRE_RL_rls_int_handle_state_update,
       CAN_FIRE_RL_rx_fifo__updateLevelCounter,
       CAN_FIRE_RL_rx_first_item_if_any,
       CAN_FIRE_RL_synchronise_input_pins,
       CAN_FIRE_RL_thre_int_handle_edges_history,
       CAN_FIRE_RL_thre_int_handle_edges_set,
       CAN_FIRE_RL_thre_int_handle_state_update,
       CAN_FIRE_RL_ti_int_handle_edges_history,
       CAN_FIRE_RL_ti_int_handle_edges_set,
       CAN_FIRE_RL_ti_int_handle_state_update,
       CAN_FIRE_RL_uart_rx_calc_parity,
       CAN_FIRE_RL_uart_rx_check_parity,
       CAN_FIRE_RL_uart_rx_couter_t_preset_on_fifo_empty,
       CAN_FIRE_RL_uart_rx_end_bit,
       CAN_FIRE_RL_uart_rx_idle,
       CAN_FIRE_RL_uart_rx_monitor_state_for_debug,
       CAN_FIRE_RL_uart_rx_push,
       CAN_FIRE_RL_uart_rx_rec_bit,
       CAN_FIRE_RL_uart_rx_rec_parity,
       CAN_FIRE_RL_uart_rx_rec_prepare,
       CAN_FIRE_RL_uart_rx_rec_start,
       CAN_FIRE_RL_uart_rx_rec_stop,
       CAN_FIRE_RL_uart_rx_receive_status_counters,
       CAN_FIRE_RL_uart_rx_wait1,
       CAN_FIRE_RL_uart_tx_forward_tx_fifo_empty,
       CAN_FIRE_RL_uart_tx_idle,
       CAN_FIRE_RL_uart_tx_monitor_state_for_debug,
       CAN_FIRE_RL_uart_tx_pop_byte,
       CAN_FIRE_RL_uart_tx_send_byte,
       CAN_FIRE_RL_uart_tx_send_parity,
       CAN_FIRE_RL_uart_tx_send_start,
       CAN_FIRE_RL_uart_tx_send_stop,
       CAN_FIRE_coe_rs232_modem_input,
       CAN_FIRE_slave_axi_uart_m_arvalid,
       CAN_FIRE_slave_axi_uart_m_awvalid,
       CAN_FIRE_slave_axi_uart_m_bready,
       CAN_FIRE_slave_axi_uart_m_rready,
       CAN_FIRE_slave_axi_uart_m_wvalid,
       WILL_FIRE_RL_bypass_mrc_to_avoid_scheduling_loop,
       WILL_FIRE_RL_connect_pins_rx,
       WILL_FIRE_RL_connect_pins_tx,
       WILL_FIRE_RL_count_rx_errors,
       WILL_FIRE_RL_divisor_counter,
       WILL_FIRE_RL_fifo_status_bypass_to_avoid_scheduling_loop,
       WILL_FIRE_RL_forward_rx,
       WILL_FIRE_RL_forward_tx,
       WILL_FIRE_RL_forward_tx_clear,
       WILL_FIRE_RL_foward_lc_enable,
       WILL_FIRE_RL_handle_axi4_read,
       WILL_FIRE_RL_handle_axi4_write,
       WILL_FIRE_RL_handle_loopback_mode,
       WILL_FIRE_RL_interrupt_sources,
       WILL_FIRE_RL_loopback_mode_select,
       WILL_FIRE_RL_ms_int_handle_edges_history,
       WILL_FIRE_RL_ms_int_handle_edges_set,
       WILL_FIRE_RL_ms_int_handle_state_update,
       WILL_FIRE_RL_output_rts_dtr,
       WILL_FIRE_RL_rda_int_handle_edges_history,
       WILL_FIRE_RL_rda_int_handle_edges_set,
       WILL_FIRE_RL_rda_int_handle_state_update,
       WILL_FIRE_RL_rls_int_handle_edges_history,
       WILL_FIRE_RL_rls_int_handle_edges_set,
       WILL_FIRE_RL_rls_int_handle_state_update,
       WILL_FIRE_RL_rx_fifo__updateLevelCounter,
       WILL_FIRE_RL_rx_first_item_if_any,
       WILL_FIRE_RL_synchronise_input_pins,
       WILL_FIRE_RL_thre_int_handle_edges_history,
       WILL_FIRE_RL_thre_int_handle_edges_set,
       WILL_FIRE_RL_thre_int_handle_state_update,
       WILL_FIRE_RL_ti_int_handle_edges_history,
       WILL_FIRE_RL_ti_int_handle_edges_set,
       WILL_FIRE_RL_ti_int_handle_state_update,
       WILL_FIRE_RL_uart_rx_calc_parity,
       WILL_FIRE_RL_uart_rx_check_parity,
       WILL_FIRE_RL_uart_rx_couter_t_preset_on_fifo_empty,
       WILL_FIRE_RL_uart_rx_end_bit,
       WILL_FIRE_RL_uart_rx_idle,
       WILL_FIRE_RL_uart_rx_monitor_state_for_debug,
       WILL_FIRE_RL_uart_rx_push,
       WILL_FIRE_RL_uart_rx_rec_bit,
       WILL_FIRE_RL_uart_rx_rec_parity,
       WILL_FIRE_RL_uart_rx_rec_prepare,
       WILL_FIRE_RL_uart_rx_rec_start,
       WILL_FIRE_RL_uart_rx_rec_stop,
       WILL_FIRE_RL_uart_rx_receive_status_counters,
       WILL_FIRE_RL_uart_rx_wait1,
       WILL_FIRE_RL_uart_tx_forward_tx_fifo_empty,
       WILL_FIRE_RL_uart_tx_idle,
       WILL_FIRE_RL_uart_tx_monitor_state_for_debug,
       WILL_FIRE_RL_uart_tx_pop_byte,
       WILL_FIRE_RL_uart_tx_send_byte,
       WILL_FIRE_RL_uart_tx_send_parity,
       WILL_FIRE_RL_uart_tx_send_start,
       WILL_FIRE_RL_uart_tx_send_stop,
       WILL_FIRE_coe_rs232_modem_input,
       WILL_FIRE_slave_axi_uart_m_arvalid,
       WILL_FIRE_slave_axi_uart_m_awvalid,
       WILL_FIRE_slave_axi_uart_m_bready,
       WILL_FIRE_slave_axi_uart_m_rready,
       WILL_FIRE_slave_axi_uart_m_wvalid;

  // inputs to muxes for submodule ports
  reg [7 : 0] MUX_uart_rx_rshift$write_1__VAL_2;
  reg [4 : 0] MUX_uart_tx_counter$write_1__VAL_1,
	      MUX_uart_tx_counter$write_1__VAL_2;
  reg [2 : 0] MUX_uart_tx_bit_counter$write_1__VAL_1;
  reg MUX_uart_rx_rparity_error$write_1__VAL_2;
  wire [6 : 0] MUX_uart_tx_shift_out$write_1__VAL_1;
  wire [3 : 0] MUX_uart_rx_rcounter$write_1__VAL_1,
	       MUX_uart_rx_rcounter$write_1__VAL_2,
	       MUX_uart_rx_rstate$write_1__VAL_4,
	       MUX_uart_rx_rstate$write_1__VAL_9;
  wire [2 : 0] MUX_uart_rx_rbit_counter$write_1__VAL_1,
	       MUX_uart_rx_rbit_counter$write_1__VAL_2,
	       MUX_uart_tx_bit_counter$write_1__VAL_2,
	       MUX_uart_tx_tstate$write_1__VAL_4;
  wire MUX_uart_rx_rcounter$write_1__SEL_1,
       MUX_uart_rx_rcounter$write_1__SEL_2,
       MUX_uart_rx_rparity_error$write_1__SEL_1,
       MUX_uart_rx_rshift$write_1__SEL_1,
       MUX_uart_rx_rstate$write_1__SEL_2,
       MUX_uart_rx_rstate$write_1__SEL_3,
       MUX_uart_rx_rstate$write_1__SEL_4,
       MUX_uart_rx_rstate$write_1__SEL_5,
       MUX_uart_rx_rstate$write_1__SEL_6,
       MUX_uart_rx_rstate$write_1__SEL_7,
       MUX_uart_rx_rstate$write_1__SEL_8,
       MUX_uart_tx_bit_counter$write_1__SEL_2,
       MUX_uart_tx_bit_out$write_1__SEL_1,
       MUX_uart_tx_bit_out$write_1__VAL_1,
       MUX_uart_tx_counter$write_1__SEL_1,
       MUX_uart_tx_stx_o_tmp$write_1__SEL_1,
       MUX_uart_tx_stx_o_tmp$write_1__SEL_3,
       MUX_uart_tx_tstate$write_1__SEL_1,
       MUX_uart_tx_tstate$write_1__SEL_2,
       MUX_uart_tx_tstate$write_1__SEL_3,
       MUX_uart_tx_tstate$write_1__SEL_4;

  // declarations used by system tasks
  // synopsys translate_off
  reg [63 : 0] v__h1087;
  reg [63 : 0] v__h4707;
  // synopsys translate_on

  // remaining internal signals
  reg [9 : 0] IF_uart_rx_lc_wget__53_BITS_3_TO_0_54_EQ_0b0_5_ETC___d186;
  reg [7 : 0] x__h14637;
  reg [4 : 0] CASE_fcr_0_1_0b1_4_0b10_8_0b11_14_1__q1;
  wire [63 : 0] x_rdata__h14630;
  wire [15 : 0] x__h13400, x__h13444, x__h13465;
  wire [7 : 0] rtn__h14164,
	       rtn__h14171,
	       rtn__h14185,
	       x__h12475,
	       x__h5652,
	       x__h5740,
	       x__h5827,
	       x__h5914,
	       y_avValue_snd__h14441,
	       y_avValue_snd__h14576;
  wire [6 : 0] spliced_bits__h5839;
  wire [5 : 0] spliced_bits__h5752;
  wire [4 : 0] spliced_bits__h5664, uart_tx_counter_3_MINUS_1___d66;
  wire [3 : 0] IF_NOT_rls_int_q_28_95_AND_NOT_rda_int_q_42_96_ETC___d614,
	       IF_NOT_rls_int_q_28_95_AND_NOT_rda_int_q_42_96_ETC___d616;
  wire [1 : 0] x__h3152, x__h6728;
  wire IF_uart_tx_lc_wget__9_BIT_4_2_CONCAT_uart_tx_l_ETC___d92,
       _dand2rda_int_s$EN_wset,
       _dfoo1,
       count_error_clear_whas__40_OR_count_error_up_w_ETC___d548,
       ier_51_BIT_2_52_AND_rx_fifo_full_wget__53_OR_r_ETC___d461,
       ier_51_BIT_3_87_AND_NOT_msr_88_BIT_0_89_CONCAT_ETC___d497,
       rx_fifo_countReg_12_ULT_IF_fcr_67_EQ_0b1_68_TH_ETC___d474,
       uart_tx_lc_wget__9_BIT_3_1_AND_uart_tx_lc_wget_ETC___d86,
       x__h12280,
       x__h12282,
       x__h12284,
       x__h12286,
       x__h2159,
       x__h3203,
       x__h6779,
       x__h6807,
       z__h2183,
       z__h2190,
       z__h2197,
       z__h2204,
       z__h2211,
       z__h2218,
       z__h6432,
       z__h6439,
       z__h6446,
       z__h6453,
       z__h6460,
       z__h6467,
       z__h6474;

  // action method coe_rs232_modem_input
  assign CAN_FIRE_coe_rs232_modem_input = 1'd1 ;
  assign WILL_FIRE_coe_rs232_modem_input = 1'd1 ;

  // value method coe_rs232_modem_output_stx
  assign coe_rs232_modem_output_stx = pin_stx ;

  // value method coe_rs232_modem_output_rts
  assign coe_rs232_modem_output_rts = pin_rts ;

  // value method coe_rs232_modem_output_dtr
  assign coe_rs232_modem_output_dtr = pin_dtr ;

  // action method slave_axi_uart_m_awvalid
  assign RDY_slave_axi_uart_m_awvalid = s_xactor_f_wr_addr$FULL_N ;
  assign CAN_FIRE_slave_axi_uart_m_awvalid = s_xactor_f_wr_addr$FULL_N ;
  assign WILL_FIRE_slave_axi_uart_m_awvalid = EN_slave_axi_uart_m_awvalid ;

  // value method slave_axi_uart_m_awready
  assign slave_axi_uart_awready = s_xactor_f_wr_addr$FULL_N ;

  // action method slave_axi_uart_m_wvalid
  assign RDY_slave_axi_uart_m_wvalid = s_xactor_f_wr_data$FULL_N ;
  assign CAN_FIRE_slave_axi_uart_m_wvalid = s_xactor_f_wr_data$FULL_N ;
  assign WILL_FIRE_slave_axi_uart_m_wvalid = EN_slave_axi_uart_m_wvalid ;

  // value method slave_axi_uart_m_wready
  assign slave_axi_uart_wready = s_xactor_f_wr_data$FULL_N ;

  // value method slave_axi_uart_m_bvalid
  assign slave_axi_uart_bvalid = s_xactor_f_wr_resp$EMPTY_N ;

  // value method slave_axi_uart_m_bresp
  assign slave_axi_uart_bresp = s_xactor_f_wr_resp$D_OUT[15:14] ;

  // value method slave_axi_uart_m_buser
  assign slave_axi_uart_buser = s_xactor_f_wr_resp$D_OUT[13:4] ;

  // value method slave_axi_uart_m_bid
  assign slave_axi_uart_bid = s_xactor_f_wr_resp$D_OUT[3:0] ;

  // action method slave_axi_uart_m_bready
  assign CAN_FIRE_slave_axi_uart_m_bready = 1'd1 ;
  assign WILL_FIRE_slave_axi_uart_m_bready = 1'd1 ;

  // action method slave_axi_uart_m_arvalid
  assign CAN_FIRE_slave_axi_uart_m_arvalid = 1'd1 ;
  assign WILL_FIRE_slave_axi_uart_m_arvalid = 1'd1 ;

  // value method slave_axi_uart_m_arready
  assign slave_axi_uart_arready = s_xactor_f_rd_addr$FULL_N ;

  // value method slave_axi_uart_m_rvalid
  assign slave_axi_uart_rvalid = s_xactor_f_rd_data$EMPTY_N ;

  // value method slave_axi_uart_m_rresp
  assign slave_axi_uart_rresp = s_xactor_f_rd_data$D_OUT[80:79] ;

  // value method slave_axi_uart_m_rdata
  assign slave_axi_uart_rdata = s_xactor_f_rd_data$D_OUT[78:15] ;

  // value method slave_axi_uart_m_rlast
  assign slave_axi_uart_rlast = s_xactor_f_rd_data$D_OUT[14] ;

  // value method slave_axi_uart_m_ruser
  assign slave_axi_uart_ruser = s_xactor_f_rd_data$D_OUT[13:4] ;

  // value method slave_axi_uart_m_rid
  assign slave_axi_uart_rid = s_xactor_f_rd_data$D_OUT[3:0] ;

  // action method slave_axi_uart_m_rready
  assign CAN_FIRE_slave_axi_uart_m_rready = 1'd1 ;
  assign WILL_FIRE_slave_axi_uart_m_rready = 1'd1 ;

  // value method irq
  assign irq = rda_int_q || rls_int_q || thre_int_q || ms_int_q || ti_int_q ;

  // submodule rx_fifo
  SizedFIFO #(.p1width(32'd11),
	      .p2depth(32'd16),
	      .p3cntr_width(32'd4),
	      .guarded(32'd1)) rx_fifo(.RST(csi_clockreset_reset_n),
				       .CLK(csi_clockreset_clk),
				       .D_IN(rx_fifo$D_IN),
				       .ENQ(rx_fifo$ENQ),
				       .DEQ(rx_fifo$DEQ),
				       .CLR(rx_fifo$CLR),
				       .D_OUT(rx_fifo$D_OUT),
				       .FULL_N(rx_fifo$FULL_N),
				       .EMPTY_N(rx_fifo$EMPTY_N));

  // submodule s_xactor_f_rd_addr
  FIFOL1 #(.width(32'd75)) s_xactor_f_rd_addr(.RST(csi_clockreset_reset_n),
					      .CLK(csi_clockreset_clk),
					      .D_IN(s_xactor_f_rd_addr$D_IN),
					      .ENQ(s_xactor_f_rd_addr$ENQ),
					      .DEQ(s_xactor_f_rd_addr$DEQ),
					      .CLR(s_xactor_f_rd_addr$CLR),
					      .D_OUT(s_xactor_f_rd_addr$D_OUT),
					      .FULL_N(s_xactor_f_rd_addr$FULL_N),
					      .EMPTY_N(s_xactor_f_rd_addr$EMPTY_N));

  // submodule s_xactor_f_rd_data
  FIFOL1 #(.width(32'd81)) s_xactor_f_rd_data(.RST(csi_clockreset_reset_n),
					      .CLK(csi_clockreset_clk),
					      .D_IN(s_xactor_f_rd_data$D_IN),
					      .ENQ(s_xactor_f_rd_data$ENQ),
					      .DEQ(s_xactor_f_rd_data$DEQ),
					      .CLR(s_xactor_f_rd_data$CLR),
					      .D_OUT(s_xactor_f_rd_data$D_OUT),
					      .FULL_N(s_xactor_f_rd_data$FULL_N),
					      .EMPTY_N(s_xactor_f_rd_data$EMPTY_N));

  // submodule s_xactor_f_wr_addr
  FIFOL1 #(.width(32'd75)) s_xactor_f_wr_addr(.RST(csi_clockreset_reset_n),
					      .CLK(csi_clockreset_clk),
					      .D_IN(s_xactor_f_wr_addr$D_IN),
					      .ENQ(s_xactor_f_wr_addr$ENQ),
					      .DEQ(s_xactor_f_wr_addr$DEQ),
					      .CLR(s_xactor_f_wr_addr$CLR),
					      .D_OUT(s_xactor_f_wr_addr$D_OUT),
					      .FULL_N(s_xactor_f_wr_addr$FULL_N),
					      .EMPTY_N(s_xactor_f_wr_addr$EMPTY_N));

  // submodule s_xactor_f_wr_data
  FIFOL1 #(.width(32'd77)) s_xactor_f_wr_data(.RST(csi_clockreset_reset_n),
					      .CLK(csi_clockreset_clk),
					      .D_IN(s_xactor_f_wr_data$D_IN),
					      .ENQ(s_xactor_f_wr_data$ENQ),
					      .DEQ(s_xactor_f_wr_data$DEQ),
					      .CLR(s_xactor_f_wr_data$CLR),
					      .D_OUT(s_xactor_f_wr_data$D_OUT),
					      .FULL_N(s_xactor_f_wr_data$FULL_N),
					      .EMPTY_N(s_xactor_f_wr_data$EMPTY_N));

  // submodule s_xactor_f_wr_resp
  FIFOL1 #(.width(32'd16)) s_xactor_f_wr_resp(.RST(csi_clockreset_reset_n),
					      .CLK(csi_clockreset_clk),
					      .D_IN(s_xactor_f_wr_resp$D_IN),
					      .ENQ(s_xactor_f_wr_resp$ENQ),
					      .DEQ(s_xactor_f_wr_resp$DEQ),
					      .CLR(s_xactor_f_wr_resp$CLR),
					      .D_OUT(s_xactor_f_wr_resp$D_OUT),
					      .FULL_N(s_xactor_f_wr_resp$FULL_N),
					      .EMPTY_N(s_xactor_f_wr_resp$EMPTY_N));

  // submodule tx_fifo
  FIFO1 #(.width(32'd8),
	  .guarded(32'd1)) tx_fifo(.RST(csi_clockreset_reset_n),
				   .CLK(csi_clockreset_clk),
				   .D_IN(tx_fifo$D_IN),
				   .ENQ(tx_fifo$ENQ),
				   .DEQ(tx_fifo$DEQ),
				   .CLR(tx_fifo$CLR),
				   .D_OUT(tx_fifo$D_OUT),
				   .FULL_N(tx_fifo$FULL_N),
				   .EMPTY_N(tx_fifo$EMPTY_N));

  // submodule uart_rx_rx_fifo
  FIFOL1 #(.width(32'd11)) uart_rx_rx_fifo(.RST(csi_clockreset_reset_n),
					   .CLK(csi_clockreset_clk),
					   .D_IN(uart_rx_rx_fifo$D_IN),
					   .ENQ(uart_rx_rx_fifo$ENQ),
					   .DEQ(uart_rx_rx_fifo$DEQ),
					   .CLR(uart_rx_rx_fifo$CLR),
					   .D_OUT(uart_rx_rx_fifo$D_OUT),
					   .FULL_N(uart_rx_rx_fifo$FULL_N),
					   .EMPTY_N(uart_rx_rx_fifo$EMPTY_N));

  // submodule uart_tx_tx_fifo
  FIFOL1 #(.width(32'd8)) uart_tx_tx_fifo(.RST(csi_clockreset_reset_n),
					  .CLK(csi_clockreset_clk),
					  .D_IN(uart_tx_tx_fifo$D_IN),
					  .ENQ(uart_tx_tx_fifo$ENQ),
					  .DEQ(uart_tx_tx_fifo$DEQ),
					  .CLR(uart_tx_tx_fifo$CLR),
					  .D_OUT(uart_tx_tx_fifo$D_OUT),
					  .FULL_N(uart_tx_tx_fifo$FULL_N),
					  .EMPTY_N(uart_tx_tx_fifo$EMPTY_N));

  // rule RL_bypass_mrc_to_avoid_scheduling_loop
  assign CAN_FIRE_RL_bypass_mrc_to_avoid_scheduling_loop = 1'd1 ;
  assign WILL_FIRE_RL_bypass_mrc_to_avoid_scheduling_loop = 1'd1 ;

  // rule RL_output_rts_dtr
  assign CAN_FIRE_RL_output_rts_dtr = 1'd1 ;
  assign WILL_FIRE_RL_output_rts_dtr = 1'd1 ;

  // rule RL_loopback_mode_select
  assign CAN_FIRE_RL_loopback_mode_select = 1'd1 ;
  assign WILL_FIRE_RL_loopback_mode_select = 1'd1 ;

  // rule RL_rx_first_item_if_any
  assign CAN_FIRE_RL_rx_first_item_if_any = 1'd1 ;
  assign WILL_FIRE_RL_rx_first_item_if_any = 1'd1 ;

  // rule RL_foward_lc_enable
  assign CAN_FIRE_RL_foward_lc_enable = 1'd1 ;
  assign WILL_FIRE_RL_foward_lc_enable = 1'd1 ;

  // rule RL_fifo_status_bypass_to_avoid_scheduling_loop
  assign CAN_FIRE_RL_fifo_status_bypass_to_avoid_scheduling_loop = 1'd1 ;
  assign WILL_FIRE_RL_fifo_status_bypass_to_avoid_scheduling_loop = 1'd1 ;

  // rule RL_interrupt_sources
  assign CAN_FIRE_RL_interrupt_sources = 1'd1 ;
  assign WILL_FIRE_RL_interrupt_sources = 1'd1 ;

  // rule RL_uart_tx_monitor_state_for_debug
  assign CAN_FIRE_RL_uart_tx_monitor_state_for_debug =
	     uart_tx_last_tstate != uart_tx_tstate ;
  assign WILL_FIRE_RL_uart_tx_monitor_state_for_debug =
	     CAN_FIRE_RL_uart_tx_monitor_state_for_debug ;

  // rule RL_uart_tx_forward_tx_fifo_empty
  assign CAN_FIRE_RL_uart_tx_forward_tx_fifo_empty = 1'd1 ;
  assign WILL_FIRE_RL_uart_tx_forward_tx_fifo_empty = 1'd1 ;

  // rule RL_handle_axi4_read
  assign CAN_FIRE_RL_handle_axi4_read =
	     s_xactor_f_rd_data$FULL_N && s_xactor_f_rd_addr$EMPTY_N ;
  assign WILL_FIRE_RL_handle_axi4_read =
	     CAN_FIRE_RL_handle_axi4_read && !uart_rx_rx_fifo$EMPTY_N ;

  // rule RL_handle_axi4_write
  assign CAN_FIRE_RL_handle_axi4_write =
	     s_xactor_f_wr_data$EMPTY_N && s_xactor_f_wr_resp$FULL_N &&
	     s_xactor_f_wr_addr$EMPTY_N ;
  assign WILL_FIRE_RL_handle_axi4_write = CAN_FIRE_RL_handle_axi4_write ;

  // rule RL_divisor_counter
  assign CAN_FIRE_RL_divisor_counter = 1'd1 ;
  assign WILL_FIRE_RL_divisor_counter = 1'd1 ;

  // rule RL_forward_tx_clear
  assign CAN_FIRE_RL_forward_tx_clear =
	     WILL_FIRE_RL_handle_axi4_write &&
	     s_xactor_f_wr_addr$D_OUT[48:46] == 3'd2 &&
	     s_xactor_f_wr_data$D_OUT[15] ;
  assign WILL_FIRE_RL_forward_tx_clear = CAN_FIRE_RL_forward_tx_clear ;

  // rule RL_forward_rx
  assign CAN_FIRE_RL_forward_rx = uart_rx_rx_fifo$EMPTY_N ;
  assign WILL_FIRE_RL_forward_rx = uart_rx_rx_fifo$EMPTY_N ;

  // rule RL_count_rx_errors
  assign CAN_FIRE_RL_count_rx_errors = 1'd1 ;
  assign WILL_FIRE_RL_count_rx_errors = 1'd1 ;

  // rule RL_uart_tx_pop_byte
  assign CAN_FIRE_RL_uart_tx_pop_byte =
	     uart_tx_tx_fifo$EMPTY_N && enable && uart_tx_tstate == 3'd1 ;
  assign WILL_FIRE_RL_uart_tx_pop_byte = CAN_FIRE_RL_uart_tx_pop_byte ;

  // rule RL_uart_rx_monitor_state_for_debug
  assign CAN_FIRE_RL_uart_rx_monitor_state_for_debug =
	     uart_rx_last_rstate != uart_rx_rstate ;
  assign WILL_FIRE_RL_uart_rx_monitor_state_for_debug =
	     CAN_FIRE_RL_uart_rx_monitor_state_for_debug ;

  // rule RL_uart_rx_couter_t_preset_on_fifo_empty
  assign CAN_FIRE_RL_uart_rx_couter_t_preset_on_fifo_empty =
	     !uart_rx_rx_fifo$EMPTY_N ;
  assign WILL_FIRE_RL_uart_rx_couter_t_preset_on_fifo_empty =
	     CAN_FIRE_RL_uart_rx_couter_t_preset_on_fifo_empty ;

  // rule RL_uart_rx_idle
  assign CAN_FIRE_RL_uart_rx_idle = enable && uart_rx_rstate == 4'd0 ;
  assign WILL_FIRE_RL_uart_rx_idle = CAN_FIRE_RL_uart_rx_idle ;

  // rule RL_uart_rx_rec_start
  assign CAN_FIRE_RL_uart_rx_rec_start = enable && uart_rx_rstate == 4'd1 ;
  assign WILL_FIRE_RL_uart_rx_rec_start = CAN_FIRE_RL_uart_rx_rec_start ;

  // rule RL_uart_rx_rec_prepare
  assign CAN_FIRE_RL_uart_rx_rec_prepare = enable && uart_rx_rstate == 4'd6 ;
  assign WILL_FIRE_RL_uart_rx_rec_prepare = CAN_FIRE_RL_uart_rx_rec_prepare ;

  // rule RL_uart_rx_rec_bit
  assign CAN_FIRE_RL_uart_rx_rec_bit = enable && uart_rx_rstate == 4'd2 ;
  assign WILL_FIRE_RL_uart_rx_rec_bit = CAN_FIRE_RL_uart_rx_rec_bit ;

  // rule RL_uart_rx_end_bit
  assign CAN_FIRE_RL_uart_rx_end_bit = enable && uart_rx_rstate == 4'd7 ;
  assign WILL_FIRE_RL_uart_rx_end_bit = CAN_FIRE_RL_uart_rx_end_bit ;

  // rule RL_uart_rx_rec_parity
  assign CAN_FIRE_RL_uart_rx_rec_parity = enable && uart_rx_rstate == 4'd3 ;
  assign WILL_FIRE_RL_uart_rx_rec_parity = CAN_FIRE_RL_uart_rx_rec_parity ;

  // rule RL_uart_rx_calc_parity
  assign CAN_FIRE_RL_uart_rx_calc_parity = enable && uart_rx_rstate == 4'd9 ;
  assign WILL_FIRE_RL_uart_rx_calc_parity = CAN_FIRE_RL_uart_rx_calc_parity ;

  // rule RL_uart_rx_check_parity
  assign CAN_FIRE_RL_uart_rx_check_parity = enable && uart_rx_rstate == 4'd5 ;
  assign WILL_FIRE_RL_uart_rx_check_parity =
	     CAN_FIRE_RL_uart_rx_check_parity ;

  // rule RL_uart_rx_wait1
  assign CAN_FIRE_RL_uart_rx_wait1 = enable && uart_rx_rstate == 4'd8 ;
  assign WILL_FIRE_RL_uart_rx_wait1 = CAN_FIRE_RL_uart_rx_wait1 ;

  // rule RL_uart_rx_rec_stop
  assign CAN_FIRE_RL_uart_rx_rec_stop = enable && uart_rx_rstate == 4'd4 ;
  assign WILL_FIRE_RL_uart_rx_rec_stop = CAN_FIRE_RL_uart_rx_rec_stop ;

  // rule RL_uart_rx_push
  assign CAN_FIRE_RL_uart_rx_push =
	     uart_rx_rx_fifo$FULL_N && enable && uart_rx_rstate == 4'd10 ;
  assign WILL_FIRE_RL_uart_rx_push = CAN_FIRE_RL_uart_rx_push ;

  // rule RL_uart_rx_receive_status_counters
  assign CAN_FIRE_RL_uart_rx_receive_status_counters = 1'd1 ;
  assign WILL_FIRE_RL_uart_rx_receive_status_counters = 1'd1 ;

  // rule RL_connect_pins_rx
  assign CAN_FIRE_RL_connect_pins_rx = 1'd1 ;
  assign WILL_FIRE_RL_connect_pins_rx = 1'd1 ;

  // rule RL_handle_loopback_mode
  assign CAN_FIRE_RL_handle_loopback_mode = 1'd1 ;
  assign WILL_FIRE_RL_handle_loopback_mode = 1'd1 ;

  // rule RL_synchronise_input_pins
  assign CAN_FIRE_RL_synchronise_input_pins = 1'd1 ;
  assign WILL_FIRE_RL_synchronise_input_pins = 1'd1 ;

  // rule RL_connect_pins_tx
  assign CAN_FIRE_RL_connect_pins_tx = 1'd1 ;
  assign WILL_FIRE_RL_connect_pins_tx = 1'd1 ;

  // rule RL_uart_tx_idle
  assign CAN_FIRE_RL_uart_tx_idle = enable && uart_tx_tstate == 3'd0 ;
  assign WILL_FIRE_RL_uart_tx_idle = CAN_FIRE_RL_uart_tx_idle ;

  // rule RL_uart_tx_send_start
  assign CAN_FIRE_RL_uart_tx_send_start = enable && uart_tx_tstate == 3'd2 ;
  assign WILL_FIRE_RL_uart_tx_send_start = CAN_FIRE_RL_uart_tx_send_start ;

  // rule RL_uart_tx_send_byte
  assign CAN_FIRE_RL_uart_tx_send_byte = enable && uart_tx_tstate == 3'd3 ;
  assign WILL_FIRE_RL_uart_tx_send_byte = CAN_FIRE_RL_uart_tx_send_byte ;

  // rule RL_uart_tx_send_parity
  assign CAN_FIRE_RL_uart_tx_send_parity = enable && uart_tx_tstate == 3'd4 ;
  assign WILL_FIRE_RL_uart_tx_send_parity = CAN_FIRE_RL_uart_tx_send_parity ;

  // rule RL_uart_tx_send_stop
  assign CAN_FIRE_RL_uart_tx_send_stop =
	     uart_tx_tx_fifo$EMPTY_N && enable && uart_tx_tstate == 3'd5 ;
  assign WILL_FIRE_RL_uart_tx_send_stop = CAN_FIRE_RL_uart_tx_send_stop ;

  // rule RL_forward_tx
  assign CAN_FIRE_RL_forward_tx =
	     tx_fifo$EMPTY_N && uart_tx_tx_fifo$FULL_N &&
	     !CAN_FIRE_RL_forward_tx_clear ;
  assign WILL_FIRE_RL_forward_tx = CAN_FIRE_RL_forward_tx ;

  // rule RL_rx_fifo__updateLevelCounter
  assign CAN_FIRE_RL_rx_fifo__updateLevelCounter =
	     rx_fifo_r_enq$whas != rx_fifo_r_deq$whas || rx_fifo_r_clr$whas ;
  assign WILL_FIRE_RL_rx_fifo__updateLevelCounter =
	     CAN_FIRE_RL_rx_fifo__updateLevelCounter ;

  // rule RL_rls_int_handle_edges_set
  assign CAN_FIRE_RL_rls_int_handle_edges_set = 1'd1 ;
  assign WILL_FIRE_RL_rls_int_handle_edges_set = 1'd1 ;

  // rule RL_rls_int_handle_edges_history
  assign CAN_FIRE_RL_rls_int_handle_edges_history = 1'd1 ;
  assign WILL_FIRE_RL_rls_int_handle_edges_history = 1'd1 ;

  // rule RL_rls_int_handle_state_update
  assign CAN_FIRE_RL_rls_int_handle_state_update = 1'd1 ;
  assign WILL_FIRE_RL_rls_int_handle_state_update = 1'd1 ;

  // rule RL_rda_int_handle_edges_set
  assign CAN_FIRE_RL_rda_int_handle_edges_set = 1'd1 ;
  assign WILL_FIRE_RL_rda_int_handle_edges_set = 1'd1 ;

  // rule RL_rda_int_handle_edges_history
  assign CAN_FIRE_RL_rda_int_handle_edges_history = 1'd1 ;
  assign WILL_FIRE_RL_rda_int_handle_edges_history = 1'd1 ;

  // rule RL_rda_int_handle_state_update
  assign CAN_FIRE_RL_rda_int_handle_state_update = 1'd1 ;
  assign WILL_FIRE_RL_rda_int_handle_state_update = 1'd1 ;

  // rule RL_thre_int_handle_edges_set
  assign CAN_FIRE_RL_thre_int_handle_edges_set = 1'd1 ;
  assign WILL_FIRE_RL_thre_int_handle_edges_set = 1'd1 ;

  // rule RL_thre_int_handle_edges_history
  assign CAN_FIRE_RL_thre_int_handle_edges_history = 1'd1 ;
  assign WILL_FIRE_RL_thre_int_handle_edges_history = 1'd1 ;

  // rule RL_thre_int_handle_state_update
  assign CAN_FIRE_RL_thre_int_handle_state_update = 1'd1 ;
  assign WILL_FIRE_RL_thre_int_handle_state_update = 1'd1 ;

  // rule RL_ms_int_handle_edges_set
  assign CAN_FIRE_RL_ms_int_handle_edges_set = 1'd1 ;
  assign WILL_FIRE_RL_ms_int_handle_edges_set = 1'd1 ;

  // rule RL_ms_int_handle_edges_history
  assign CAN_FIRE_RL_ms_int_handle_edges_history = 1'd1 ;
  assign WILL_FIRE_RL_ms_int_handle_edges_history = 1'd1 ;

  // rule RL_ms_int_handle_state_update
  assign CAN_FIRE_RL_ms_int_handle_state_update = 1'd1 ;
  assign WILL_FIRE_RL_ms_int_handle_state_update = 1'd1 ;

  // rule RL_ti_int_handle_edges_set
  assign CAN_FIRE_RL_ti_int_handle_edges_set = 1'd1 ;
  assign WILL_FIRE_RL_ti_int_handle_edges_set = 1'd1 ;

  // rule RL_ti_int_handle_edges_history
  assign CAN_FIRE_RL_ti_int_handle_edges_history = 1'd1 ;
  assign WILL_FIRE_RL_ti_int_handle_edges_history = 1'd1 ;

  // rule RL_ti_int_handle_state_update
  assign CAN_FIRE_RL_ti_int_handle_state_update = 1'd1 ;
  assign WILL_FIRE_RL_ti_int_handle_state_update = 1'd1 ;

  // inputs to muxes for submodule ports
  assign MUX_uart_rx_rcounter$write_1__SEL_1 =
	     WILL_FIRE_RL_uart_rx_rec_stop ||
	     WILL_FIRE_RL_uart_rx_check_parity ||
	     WILL_FIRE_RL_uart_rx_calc_parity ||
	     WILL_FIRE_RL_uart_rx_rec_parity ||
	     WILL_FIRE_RL_uart_rx_end_bit ||
	     WILL_FIRE_RL_uart_rx_rec_bit ||
	     WILL_FIRE_RL_uart_rx_rec_start ;
  assign MUX_uart_rx_rcounter$write_1__SEL_2 =
	     WILL_FIRE_RL_uart_rx_wait1 || WILL_FIRE_RL_uart_rx_rec_prepare ;
  assign MUX_uart_rx_rparity_error$write_1__SEL_1 =
	     WILL_FIRE_RL_uart_rx_end_bit && uart_rx_rbit_counter == 3'd0 ;
  assign MUX_uart_rx_rshift$write_1__SEL_1 =
	     WILL_FIRE_RL_uart_rx_rec_prepare && uart_rx_rcounter == 4'd0 ;
  assign MUX_uart_rx_rstate$write_1__SEL_2 =
	     WILL_FIRE_RL_uart_rx_wait1 && uart_rx_rcounter == 4'd0 ;
  assign MUX_uart_rx_rstate$write_1__SEL_3 =
	     WILL_FIRE_RL_uart_rx_rec_bit && uart_rx_rcounter == 4'd0 ;
  assign MUX_uart_rx_rstate$write_1__SEL_4 =
	     WILL_FIRE_RL_uart_rx_rec_start && uart_rx_rcounter == 4'd7 ;
  assign MUX_uart_rx_rstate$write_1__SEL_5 =
	     WILL_FIRE_RL_uart_rx_rec_parity && uart_rx_rcounter == 4'd7 ;
  assign MUX_uart_rx_rstate$write_1__SEL_6 =
	     WILL_FIRE_RL_uart_rx_rec_stop && uart_rx_rcounter == 4'd7 ;
  assign MUX_uart_rx_rstate$write_1__SEL_7 =
	     WILL_FIRE_RL_uart_rx_idle && !uart_rx_rx_stable &&
	     uart_rx_counter_b != 8'd0 ;
  assign MUX_uart_rx_rstate$write_1__SEL_8 =
	     WILL_FIRE_RL_uart_rx_push &&
	     (uart_rx_rx_stable || uart_rx_counter_b == 8'd0) ;
  assign MUX_uart_tx_bit_counter$write_1__SEL_2 =
	     WILL_FIRE_RL_uart_tx_send_byte && uart_tx_counter == 5'd1 &&
	     uart_tx_bit_counter != 3'd0 ;
  assign MUX_uart_tx_bit_out$write_1__SEL_1 =
	     WILL_FIRE_RL_uart_tx_send_byte && uart_tx_counter == 5'd1 &&
	     uart_tx_lc_wget__9_BIT_3_1_AND_uart_tx_lc_wget_ETC___d86 ;
  assign MUX_uart_tx_counter$write_1__SEL_1 =
	     WILL_FIRE_RL_uart_tx_send_parity ||
	     WILL_FIRE_RL_uart_tx_send_byte ||
	     WILL_FIRE_RL_uart_tx_send_start ;
  assign MUX_uart_tx_stx_o_tmp$write_1__SEL_1 =
	     WILL_FIRE_RL_uart_tx_send_parity ||
	     WILL_FIRE_RL_uart_tx_send_byte ;
  assign MUX_uart_tx_stx_o_tmp$write_1__SEL_3 =
	     WILL_FIRE_RL_uart_tx_send_stop || WILL_FIRE_RL_uart_tx_idle ;
  assign MUX_uart_tx_tstate$write_1__SEL_1 =
	     WILL_FIRE_RL_uart_tx_send_stop && uart_tx_counter == 5'd1 ;
  assign MUX_uart_tx_tstate$write_1__SEL_2 =
	     WILL_FIRE_RL_uart_tx_send_start && uart_tx_counter == 5'd1 ;
  assign MUX_uart_tx_tstate$write_1__SEL_3 =
	     WILL_FIRE_RL_uart_tx_send_parity && uart_tx_counter == 5'd1 ;
  assign MUX_uart_tx_tstate$write_1__SEL_4 =
	     WILL_FIRE_RL_uart_tx_send_byte && uart_tx_counter == 5'd1 &&
	     uart_tx_bit_counter == 3'd0 ;
  assign MUX_uart_rx_rbit_counter$write_1__VAL_1 = { 1'd0, lcr[1:0] } + 3'd4 ;
  assign MUX_uart_rx_rbit_counter$write_1__VAL_2 =
	     uart_rx_rbit_counter - 3'd1 ;
  assign MUX_uart_rx_rcounter$write_1__VAL_1 = uart_rx_rcounter - 4'd1 ;
  assign MUX_uart_rx_rcounter$write_1__VAL_2 =
	     (uart_rx_rcounter == 4'd0) ? 4'b1110 : uart_rx_rcounter - 4'd1 ;
  always@(x__h6728 or
	  uart_rx_rparity or x__h6779 or x__h6807 or uart_rx_rparity_xor)
  begin
    case (x__h6728)
      2'b0: MUX_uart_rx_rparity_error$write_1__VAL_2 = x__h6779;
      2'b01: MUX_uart_rx_rparity_error$write_1__VAL_2 = x__h6807;
      2'b10: MUX_uart_rx_rparity_error$write_1__VAL_2 = uart_rx_rparity_xor;
      2'd3: MUX_uart_rx_rparity_error$write_1__VAL_2 = uart_rx_rparity;
    endcase
  end
  always@(lcr or x__h5914 or x__h5652 or x__h5740 or x__h5827)
  begin
    case (lcr[1:0])
      2'd0: MUX_uart_rx_rshift$write_1__VAL_2 = x__h5652;
      2'd1: MUX_uart_rx_rshift$write_1__VAL_2 = x__h5740;
      2'd2: MUX_uart_rx_rshift$write_1__VAL_2 = x__h5827;
      2'd3: MUX_uart_rx_rshift$write_1__VAL_2 = x__h5914;
    endcase
  end
  assign MUX_uart_rx_rstate$write_1__VAL_4 = uart_rx_rx_stable ? 4'd0 : 4'd6 ;
  assign MUX_uart_rx_rstate$write_1__VAL_9 =
	     (uart_rx_rbit_counter == 3'd0) ? (lcr[3] ? 4'd3 : 4'd4) : 4'd2 ;
  always@(lcr)
  begin
    case (lcr[1:0])
      2'd0: MUX_uart_tx_bit_counter$write_1__VAL_1 = 3'd4;
      2'd1: MUX_uart_tx_bit_counter$write_1__VAL_1 = 3'd5;
      2'd2: MUX_uart_tx_bit_counter$write_1__VAL_1 = 3'd6;
      2'd3: MUX_uart_tx_bit_counter$write_1__VAL_1 = 3'd7;
    endcase
  end
  assign MUX_uart_tx_bit_counter$write_1__VAL_2 = uart_tx_bit_counter - 3'd1 ;
  assign MUX_uart_tx_bit_out$write_1__VAL_1 =
	     (uart_tx_bit_counter == 3'd0) ?
	       IF_uart_tx_lc_wget__9_BIT_4_2_CONCAT_uart_tx_l_ETC___d92 :
	       uart_tx_shift_out[0] ;
  always@(uart_tx_counter or uart_tx_counter_3_MINUS_1___d66)
  begin
    case (uart_tx_counter)
      5'd0: MUX_uart_tx_counter$write_1__VAL_1 = 5'b01111;
      5'd1: MUX_uart_tx_counter$write_1__VAL_1 = 5'd0;
      default: MUX_uart_tx_counter$write_1__VAL_1 =
		   uart_tx_counter_3_MINUS_1___d66;
    endcase
  end
  always@(uart_tx_counter or uart_tx_counter_3_MINUS_1___d66 or lcr)
  begin
    case (uart_tx_counter)
      5'd0:
	  MUX_uart_tx_counter$write_1__VAL_2 =
	      lcr[2] ? ((lcr[1:0] == 2'd0) ? 5'b10101 : 5'b11101) : 5'b01101;
      5'd1: MUX_uart_tx_counter$write_1__VAL_2 = 5'd0;
      default: MUX_uart_tx_counter$write_1__VAL_2 =
		   uart_tx_counter_3_MINUS_1___d66;
    endcase
  end
  assign MUX_uart_tx_shift_out$write_1__VAL_1 =
	     { 1'b0, uart_tx_shift_out[6:1] } ;
  assign MUX_uart_tx_tstate$write_1__VAL_4 = lcr[3] ? 3'd4 : 3'd5 ;

  // inlined wires
  assign dl_update$wget = { 1'd1, dl2r, s_xactor_f_wr_data$D_OUT[20:13] } ;
  assign dl_update$whas =
	     WILL_FIRE_RL_handle_axi4_write &&
	     s_xactor_f_wr_addr$D_OUT[48:46] == 3'd0 &&
	     lcr[7] ;
  assign uart_rx_counter_t_preset$whas =
	     WILL_FIRE_RL_uart_rx_push &&
	     (uart_rx_rx_stable || uart_rx_counter_b == 8'd0) ||
	     uart_rx_rx_fifo$EMPTY_N && !rx_fifo_clear_pw$whas &&
	     rx_fifo$FULL_N ||
	     WILL_FIRE_RL_uart_rx_couter_t_preset_on_fifo_empty ;
  assign rx_fifo_r_enq$whas =
	     uart_rx_rx_fifo$EMPTY_N && !rx_fifo_clear_pw$whas &&
	     rx_fifo$FULL_N ;
  assign rx_fifo_r_deq$whas =
	     WILL_FIRE_RL_handle_axi4_read &&
	     s_xactor_f_rd_addr$D_OUT[48:46] == 3'd0 &&
	     !lcr[7] &&
	     !(!rx_fifo$EMPTY_N) ;
  assign rx_fifo_r_clr$whas =
	     uart_rx_rx_fifo$EMPTY_N && rx_fifo_clear_pw$whas ;
  assign rx_fifo_clear_pw$whas =
	     WILL_FIRE_RL_handle_axi4_write &&
	     s_xactor_f_wr_addr$D_OUT[48:46] == 3'd2 &&
	     s_xactor_f_wr_data$D_OUT[14] ;
  assign count_error_up$whas =
	     uart_rx_rx_fifo$EMPTY_N && !rx_fifo_clear_pw$whas &&
	     rx_fifo$FULL_N &&
	     (uart_rx_rx_fifo$D_OUT[2] || uart_rx_rx_fifo$D_OUT[1] ||
	      uart_rx_rx_fifo$D_OUT[0]) ;
  assign count_error_down$whas =
	     WILL_FIRE_RL_handle_axi4_read &&
	     s_xactor_f_rd_addr$D_OUT[48:46] == 3'd0 &&
	     !lcr[7] &&
	     !(!rx_fifo$EMPTY_N) &&
	     (rx_fifo$D_OUT[2] || rx_fifo$D_OUT[1] || rx_fifo$D_OUT[0]) ;
  assign rls_int_s$whas =
	     ier_51_BIT_2_52_AND_rx_fifo_full_wget__53_OR_r_ETC___d461 &&
	     !rls_int_s_prev ;
  assign rls_int_r$whas =
	     WILL_FIRE_RL_handle_axi4_read &&
	     s_xactor_f_rd_addr$D_OUT[48:46] == 3'd5 ||
	     !ier[2] ;
  assign rda_int_r$whas =
	     !ier[0] || !rx_fifo$EMPTY_N ||
	     rx_fifo_countReg_12_ULT_IF_fcr_67_EQ_0b1_68_TH_ETC___d474 ||
	     WILL_FIRE_RL_handle_axi4_read &&
	     s_xactor_f_rd_addr$D_OUT[48:46] == 3'd0 &&
	     !lcr[7] &&
	     !(!rx_fifo$EMPTY_N) ;
  assign thre_int_s$whas = thre_int_edge_s$whas && !thre_int_s_prev ;
  assign thre_int_r$whas =
	     !ier[1] || !(!tx_fifo$EMPTY_N) ||
	     WILL_FIRE_RL_handle_axi4_write &&
	     s_xactor_f_wr_addr$D_OUT[48:46] == 3'd0 &&
	     !lcr[7] &&
	     tx_fifo$FULL_N ;
  assign thre_int_edge_s$whas = ier[1] && !tx_fifo$EMPTY_N ;
  assign ms_int_s$whas =
	     ier_51_BIT_3_87_AND_NOT_msr_88_BIT_0_89_CONCAT_ETC___d497 &&
	     !ms_int_s_prev ;
  assign ms_int_r$whas =
	     WILL_FIRE_RL_handle_axi4_read &&
	     s_xactor_f_rd_addr$D_OUT[48:46] == 3'd6 ||
	     !ier[3] ;
  assign ti_int_s$whas = ti_int_edge_s$whas && !ti_int_s_prev ;
  assign ti_int_r$whas =
	     !ier[0] ||
	     WILL_FIRE_RL_handle_axi4_read &&
	     s_xactor_f_rd_addr$D_OUT[48:46] == 3'd0 &&
	     !lcr[7] &&
	     !(!rx_fifo$EMPTY_N) ;
  assign ti_int_edge_s$whas = ier[0] && uart_rx_counter_t == 10'd0 ;
  assign msr_save_pin_state$whas =
	     WILL_FIRE_RL_handle_axi4_read &&
	     s_xactor_f_rd_addr$D_OUT[48:46] == 3'd6 ;
  assign rx_fifo_first$wget =
	     { x__h12475,
	       rx_fifo$EMPTY_N && rx_fifo$D_OUT[2],
	       rx_fifo$EMPTY_N && rx_fifo$D_OUT[1],
	       rx_fifo$EMPTY_N && rx_fifo$D_OUT[0] } ;

  // register count_error
  assign count_error$D_IN =
	     count_error_clear_whas__40_OR_count_error_up_w_ETC___d548 ?
	       (rx_fifo_clear_pw$whas ? 17'd0 : count_error + 17'd1) :
	       count_error - 17'd1 ;
  assign count_error$EN = _dfoo1 ;

  // register dl
  assign dl$D_IN = dl_update$wget[15:0] ;
  assign dl$EN = dl_update$whas && dl_update$wget[16] ;

  // register dl1r
  assign dl1r$D_IN = s_xactor_f_wr_data$D_OUT[20:13] ;
  assign dl1r$EN = dl_update$whas ;

  // register dl2r
  assign dl2r$D_IN = s_xactor_f_wr_data$D_OUT[20:13] ;
  assign dl2r$EN =
	     WILL_FIRE_RL_handle_axi4_write &&
	     s_xactor_f_wr_addr$D_OUT[48:46] == 3'd1 &&
	     lcr[7] ;

  // register dlc
  assign dlc$D_IN =
	     (dl_update$whas && dl_update$wget[16]) ? x__h13444 : x__h13400 ;
  assign dlc$EN = 1'd1 ;

  // register enable
  assign enable$D_IN = dlc == 16'd0 && dl != 16'd0 ;
  assign enable$EN = 1'd1 ;

  // register fcr
  assign fcr$D_IN = s_xactor_f_wr_data$D_OUT[20:19] ;
  assign fcr$EN =
	     WILL_FIRE_RL_handle_axi4_write &&
	     s_xactor_f_wr_addr$D_OUT[48:46] == 3'd2 ;

  // register ier
  assign ier$D_IN = s_xactor_f_wr_data$D_OUT[16:13] ;
  assign ier$EN =
	     WILL_FIRE_RL_handle_axi4_write &&
	     s_xactor_f_wr_addr$D_OUT[48:46] == 3'd1 &&
	     !lcr[7] ;

  // register lcr
  assign lcr$D_IN = s_xactor_f_wr_data$D_OUT[20:13] ;
  assign lcr$EN =
	     WILL_FIRE_RL_handle_axi4_write &&
	     s_xactor_f_wr_addr$D_OUT[48:46] == 3'd3 ;

  // register lsr
  assign lsr$D_IN =
	     { !rx_fifo$FULL_N || count_error != 17'd0,
	       !tx_fifo$EMPTY_N && !uart_tx_tx_fifo$EMPTY_N,
	       !tx_fifo$EMPTY_N,
	       rx_fifo_first$wget[2],
	       rx_fifo_first$wget[0],
	       rx_fifo_first$wget[1],
	       !rx_fifo$FULL_N,
	       !(!rx_fifo$EMPTY_N) } ;
  assign lsr$EN =
	     WILL_FIRE_RL_handle_axi4_write || WILL_FIRE_RL_handle_axi4_read ;

  // register mcr
  assign mcr$D_IN = s_xactor_f_wr_data$D_OUT[17:13] ;
  assign mcr$EN =
	     WILL_FIRE_RL_handle_axi4_write &&
	     s_xactor_f_wr_addr$D_OUT[48:46] == 3'd4 ;

  // register ms_int_q
  assign ms_int_q$D_IN = !ms_int_r$whas && (ms_int_q || ms_int_s$whas) ;
  assign ms_int_q$EN = 1'd1 ;

  // register ms_int_r_prev
  assign ms_int_r_prev$D_IN = ms_int_r$whas ;
  assign ms_int_r_prev$EN = 1'd1 ;

  // register ms_int_s_prev
  assign ms_int_s_prev$D_IN = ms_int_s$whas ;
  assign ms_int_s_prev$EN = 1'd1 ;

  // register msr
  assign msr$D_IN =
	     { pin_dcd,
	       pin_ri,
	       pin_dsr,
	       pin_cts,
	       x__h12280,
	       x__h12282,
	       x__h12284,
	       x__h12286 } ;
  assign msr$EN = 1'd1 ;

  // register pin_cts
  assign pin_cts$D_IN = mcr[4] ? mcr[1] : pin_cts_c ;
  assign pin_cts$EN = 1'd1 ;

  // register pin_cts_c
  assign pin_cts_c$D_IN = pin_cts_sync ;
  assign pin_cts_c$EN = 1'd1 ;

  // register pin_cts_sync
  assign pin_cts_sync$D_IN = coe_rs232_modem_input_cts ;
  assign pin_cts_sync$EN = 1'd1 ;

  // register pin_dcd
  assign pin_dcd$D_IN = mcr[4] ? mcr[3] : pin_dcd_c ;
  assign pin_dcd$EN = 1'd1 ;

  // register pin_dcd_c
  assign pin_dcd_c$D_IN = pin_dcd_sync ;
  assign pin_dcd_c$EN = 1'd1 ;

  // register pin_dcd_sync
  assign pin_dcd_sync$D_IN = coe_rs232_modem_input_dcd ;
  assign pin_dcd_sync$EN = 1'd1 ;

  // register pin_dsr
  assign pin_dsr$D_IN = mcr[4] ? mcr[0] : pin_dsr_c ;
  assign pin_dsr$EN = 1'd1 ;

  // register pin_dsr_c
  assign pin_dsr_c$D_IN = pin_dsr_sync ;
  assign pin_dsr_c$EN = 1'd1 ;

  // register pin_dsr_sync
  assign pin_dsr_sync$D_IN = coe_rs232_modem_input_dsr ;
  assign pin_dsr_sync$EN = 1'd1 ;

  // register pin_dtr
  assign pin_dtr$D_IN = mcr[0] ;
  assign pin_dtr$EN = 1'd1 ;

  // register pin_ri
  assign pin_ri$D_IN = mcr[4] ? mcr[2] : pin_ri_c ;
  assign pin_ri$EN = 1'd1 ;

  // register pin_ri_c
  assign pin_ri_c$D_IN = pin_ri_sync ;
  assign pin_ri_c$EN = 1'd1 ;

  // register pin_ri_sync
  assign pin_ri_sync$D_IN = coe_rs232_modem_input_ri ;
  assign pin_ri_sync$EN = 1'd1 ;

  // register pin_rts
  assign pin_rts$D_IN = mcr[1] ;
  assign pin_rts$EN = 1'd1 ;

  // register pin_srx
  assign pin_srx$D_IN = mcr[4] ? pin_stx : pin_srx_c ;
  assign pin_srx$EN = 1'd1 ;

  // register pin_srx_c
  assign pin_srx_c$D_IN = pin_srx_sync ;
  assign pin_srx_c$EN = 1'd1 ;

  // register pin_srx_sync
  assign pin_srx_sync$D_IN = coe_rs232_modem_input_srx ;
  assign pin_srx_sync$EN = 1'd1 ;

  // register pin_stx
  assign pin_stx$D_IN = !lcr[6] && uart_tx_stx_o_tmp ;
  assign pin_stx$EN = 1'd1 ;

  // register prev_cts
  assign prev_cts$D_IN = pin_cts ;
  assign prev_cts$EN = msr_save_pin_state$whas ;

  // register prev_dcd
  assign prev_dcd$D_IN = pin_dcd ;
  assign prev_dcd$EN = msr_save_pin_state$whas ;

  // register prev_dsr
  assign prev_dsr$D_IN = pin_dsr ;
  assign prev_dsr$EN = msr_save_pin_state$whas ;

  // register prev_ri
  assign prev_ri$D_IN = pin_ri ;
  assign prev_ri$EN = msr_save_pin_state$whas ;

  // register rda_int_q
  assign rda_int_q$D_IN =
	     !rda_int_r$whas && (rda_int_q || _dand2rda_int_s$EN_wset) ;
  assign rda_int_q$EN = 1'd1 ;

  // register rda_int_r_prev
  assign rda_int_r_prev$D_IN = rda_int_r$whas ;
  assign rda_int_r_prev$EN = 1'd1 ;

  // register rda_int_s_prev
  assign rda_int_s_prev$D_IN = _dand2rda_int_s$EN_wset ;
  assign rda_int_s_prev$EN = 1'd1 ;

  // register rls_int_q
  assign rls_int_q$D_IN = !rls_int_r$whas && (rls_int_q || rls_int_s$whas) ;
  assign rls_int_q$EN = 1'd1 ;

  // register rls_int_r_prev
  assign rls_int_r_prev$D_IN = rls_int_r$whas ;
  assign rls_int_r_prev$EN = 1'd1 ;

  // register rls_int_s_prev
  assign rls_int_s_prev$D_IN = rls_int_s$whas ;
  assign rls_int_s_prev$EN = 1'd1 ;

  // register rx_fifo_countReg
  assign rx_fifo_countReg$D_IN =
	     rx_fifo_r_clr$whas ?
	       5'd0 :
	       (rx_fifo_r_enq$whas ?
		  rx_fifo_countReg + 5'd1 :
		  rx_fifo_countReg - 5'd1) ;
  assign rx_fifo_countReg$EN = CAN_FIRE_RL_rx_fifo__updateLevelCounter ;

  // register scratch
  assign scratch$D_IN = s_xactor_f_wr_data$D_OUT[20:13] ;
  assign scratch$EN =
	     WILL_FIRE_RL_handle_axi4_write &&
	     s_xactor_f_wr_addr$D_OUT[48:46] == 3'd7 ;

  // register thre_int_q
  assign thre_int_q$D_IN =
	     !thre_int_r$whas && (thre_int_q || thre_int_s$whas) ;
  assign thre_int_q$EN = 1'd1 ;

  // register thre_int_r_prev
  assign thre_int_r_prev$D_IN = thre_int_r$whas ;
  assign thre_int_r_prev$EN = 1'd1 ;

  // register thre_int_s_prev
  assign thre_int_s_prev$D_IN = thre_int_s$whas ;
  assign thre_int_s_prev$EN = 1'd1 ;

  // register ti_int_q
  assign ti_int_q$D_IN = !ti_int_r$whas && (ti_int_q || ti_int_s$whas) ;
  assign ti_int_q$EN = 1'd1 ;

  // register ti_int_r_prev
  assign ti_int_r_prev$D_IN = ti_int_r$whas ;
  assign ti_int_r_prev$EN = 1'd1 ;

  // register ti_int_s_prev
  assign ti_int_s_prev$D_IN = ti_int_s$whas ;
  assign ti_int_s_prev$EN = 1'd1 ;

  // register uart_rx_counter_b
  assign uart_rx_counter_b$D_IN =
	     uart_rx_rx_stable ?
	       IF_uart_rx_lc_wget__53_BITS_3_TO_0_54_EQ_0b0_5_ETC___d186[9:2] :
	       uart_rx_counter_b - 8'd1 ;
  assign uart_rx_counter_b$EN =
	     uart_rx_rx_stable || uart_rx_counter_b != 8'd0 && enable ;

  // register uart_rx_counter_t
  assign uart_rx_counter_t$D_IN =
	     uart_rx_counter_t_preset$whas ?
	       IF_uart_rx_lc_wget__53_BITS_3_TO_0_54_EQ_0b0_5_ETC___d186 :
	       uart_rx_counter_t - 10'd1 ;
  assign uart_rx_counter_t$EN =
	     uart_rx_counter_t_preset$whas ||
	     enable && uart_rx_counter_t != 10'd0 ;

  // register uart_rx_last_rstate
  assign uart_rx_last_rstate$D_IN = uart_rx_rstate ;
  assign uart_rx_last_rstate$EN =
	     CAN_FIRE_RL_uart_rx_monitor_state_for_debug ;

  // register uart_rx_rbit_counter
  assign uart_rx_rbit_counter$D_IN =
	     WILL_FIRE_RL_uart_rx_rec_prepare ?
	       MUX_uart_rx_rbit_counter$write_1__VAL_1 :
	       MUX_uart_rx_rbit_counter$write_1__VAL_2 ;
  assign uart_rx_rbit_counter$EN =
	     WILL_FIRE_RL_uart_rx_rec_prepare ||
	     WILL_FIRE_RL_uart_rx_end_bit ;

  // register uart_rx_rcounter
  always@(MUX_uart_rx_rcounter$write_1__SEL_1 or
	  MUX_uart_rx_rcounter$write_1__VAL_1 or
	  MUX_uart_rx_rcounter$write_1__SEL_2 or
	  MUX_uart_rx_rcounter$write_1__VAL_2 or WILL_FIRE_RL_uart_rx_idle)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_uart_rx_rcounter$write_1__SEL_1:
	  uart_rx_rcounter$D_IN = MUX_uart_rx_rcounter$write_1__VAL_1;
      MUX_uart_rx_rcounter$write_1__SEL_2:
	  uart_rx_rcounter$D_IN = MUX_uart_rx_rcounter$write_1__VAL_2;
      WILL_FIRE_RL_uart_rx_idle: uart_rx_rcounter$D_IN = 4'b1110;
      default: uart_rx_rcounter$D_IN = 4'b1010 /* unspecified value */ ;
    endcase
  end
  assign uart_rx_rcounter$EN =
	     WILL_FIRE_RL_uart_rx_rec_stop ||
	     WILL_FIRE_RL_uart_rx_check_parity ||
	     WILL_FIRE_RL_uart_rx_calc_parity ||
	     WILL_FIRE_RL_uart_rx_rec_parity ||
	     WILL_FIRE_RL_uart_rx_end_bit ||
	     WILL_FIRE_RL_uart_rx_rec_bit ||
	     WILL_FIRE_RL_uart_rx_rec_start ||
	     WILL_FIRE_RL_uart_rx_wait1 ||
	     WILL_FIRE_RL_uart_rx_rec_prepare ||
	     WILL_FIRE_RL_uart_rx_idle ;

  // register uart_rx_rframing_error
  assign uart_rx_rframing_error$D_IN = ~uart_rx_rx_stable ;
  assign uart_rx_rframing_error$EN = MUX_uart_rx_rstate$write_1__SEL_6 ;

  // register uart_rx_rparity
  assign uart_rx_rparity$D_IN = uart_rx_rx_stable ;
  assign uart_rx_rparity$EN = MUX_uart_rx_rstate$write_1__SEL_5 ;

  // register uart_rx_rparity_error
  assign uart_rx_rparity_error$D_IN =
	     !MUX_uart_rx_rparity_error$write_1__SEL_1 &&
	     MUX_uart_rx_rparity_error$write_1__VAL_2 ;
  assign uart_rx_rparity_error$EN =
	     WILL_FIRE_RL_uart_rx_end_bit && uart_rx_rbit_counter == 3'd0 ||
	     WILL_FIRE_RL_uart_rx_check_parity ;

  // register uart_rx_rparity_xor
  assign uart_rx_rparity_xor$D_IN = z__h6474 ^ uart_rx_rshift[7] ;
  assign uart_rx_rparity_xor$EN = CAN_FIRE_RL_uart_rx_calc_parity ;

  // register uart_rx_rshift
  assign uart_rx_rshift$D_IN =
	     MUX_uart_rx_rshift$write_1__SEL_1 ?
	       8'd0 :
	       MUX_uart_rx_rshift$write_1__VAL_2 ;
  assign uart_rx_rshift$EN =
	     WILL_FIRE_RL_uart_rx_rec_prepare && uart_rx_rcounter == 4'd0 ||
	     WILL_FIRE_RL_uart_rx_rec_bit && uart_rx_rcounter == 4'd7 ;

  // register uart_rx_rstate
  always@(MUX_uart_rx_rshift$write_1__SEL_1 or
	  MUX_uart_rx_rstate$write_1__SEL_2 or
	  MUX_uart_rx_rstate$write_1__SEL_3 or
	  MUX_uart_rx_rstate$write_1__SEL_4 or
	  MUX_uart_rx_rstate$write_1__VAL_4 or
	  MUX_uart_rx_rstate$write_1__SEL_5 or
	  MUX_uart_rx_rstate$write_1__SEL_6 or
	  MUX_uart_rx_rstate$write_1__SEL_7 or
	  MUX_uart_rx_rstate$write_1__SEL_8 or
	  WILL_FIRE_RL_uart_rx_end_bit or
	  MUX_uart_rx_rstate$write_1__VAL_9 or
	  WILL_FIRE_RL_uart_rx_calc_parity or
	  WILL_FIRE_RL_uart_rx_check_parity)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_uart_rx_rshift$write_1__SEL_1: uart_rx_rstate$D_IN = 4'd2;
      MUX_uart_rx_rstate$write_1__SEL_2: uart_rx_rstate$D_IN = 4'd4;
      MUX_uart_rx_rstate$write_1__SEL_3: uart_rx_rstate$D_IN = 4'd7;
      MUX_uart_rx_rstate$write_1__SEL_4:
	  uart_rx_rstate$D_IN = MUX_uart_rx_rstate$write_1__VAL_4;
      MUX_uart_rx_rstate$write_1__SEL_5: uart_rx_rstate$D_IN = 4'd9;
      MUX_uart_rx_rstate$write_1__SEL_6: uart_rx_rstate$D_IN = 4'd10;
      MUX_uart_rx_rstate$write_1__SEL_7: uart_rx_rstate$D_IN = 4'd1;
      MUX_uart_rx_rstate$write_1__SEL_8: uart_rx_rstate$D_IN = 4'd0;
      WILL_FIRE_RL_uart_rx_end_bit:
	  uart_rx_rstate$D_IN = MUX_uart_rx_rstate$write_1__VAL_9;
      WILL_FIRE_RL_uart_rx_calc_parity: uart_rx_rstate$D_IN = 4'd5;
      WILL_FIRE_RL_uart_rx_check_parity: uart_rx_rstate$D_IN = 4'd8;
      default: uart_rx_rstate$D_IN = 4'b1010 /* unspecified value */ ;
    endcase
  end
  assign uart_rx_rstate$EN =
	     WILL_FIRE_RL_uart_rx_rec_prepare && uart_rx_rcounter == 4'd0 ||
	     WILL_FIRE_RL_uart_rx_wait1 && uart_rx_rcounter == 4'd0 ||
	     WILL_FIRE_RL_uart_rx_rec_bit && uart_rx_rcounter == 4'd0 ||
	     WILL_FIRE_RL_uart_rx_rec_start && uart_rx_rcounter == 4'd7 ||
	     WILL_FIRE_RL_uart_rx_rec_parity && uart_rx_rcounter == 4'd7 ||
	     WILL_FIRE_RL_uart_rx_rec_stop && uart_rx_rcounter == 4'd7 ||
	     WILL_FIRE_RL_uart_rx_idle && !uart_rx_rx_stable &&
	     uart_rx_counter_b != 8'd0 ||
	     WILL_FIRE_RL_uart_rx_push &&
	     (uart_rx_rx_stable || uart_rx_counter_b == 8'd0) ||
	     WILL_FIRE_RL_uart_rx_end_bit ||
	     WILL_FIRE_RL_uart_rx_calc_parity ||
	     WILL_FIRE_RL_uart_rx_check_parity ;

  // register uart_rx_rx_stable
  assign uart_rx_rx_stable$D_IN = pin_srx ;
  assign uart_rx_rx_stable$EN = 1'd1 ;

  // register uart_tx_bit_counter
  assign uart_tx_bit_counter$D_IN =
	     WILL_FIRE_RL_uart_tx_pop_byte ?
	       MUX_uart_tx_bit_counter$write_1__VAL_1 :
	       MUX_uart_tx_bit_counter$write_1__VAL_2 ;
  assign uart_tx_bit_counter$EN =
	     WILL_FIRE_RL_uart_tx_pop_byte ||
	     WILL_FIRE_RL_uart_tx_send_byte && uart_tx_counter == 5'd1 &&
	     uart_tx_bit_counter != 3'd0 ;

  // register uart_tx_bit_out
  assign uart_tx_bit_out$D_IN =
	     MUX_uart_tx_bit_out$write_1__SEL_1 ?
	       MUX_uart_tx_bit_out$write_1__VAL_1 :
	       uart_tx_tx_fifo$D_OUT[0] ;
  assign uart_tx_bit_out$EN =
	     WILL_FIRE_RL_uart_tx_send_byte && uart_tx_counter == 5'd1 &&
	     uart_tx_lc_wget__9_BIT_3_1_AND_uart_tx_lc_wget_ETC___d86 ||
	     WILL_FIRE_RL_uart_tx_pop_byte ;

  // register uart_tx_counter
  assign uart_tx_counter$D_IN =
	     MUX_uart_tx_counter$write_1__SEL_1 ?
	       MUX_uart_tx_counter$write_1__VAL_1 :
	       MUX_uart_tx_counter$write_1__VAL_2 ;
  assign uart_tx_counter$EN =
	     WILL_FIRE_RL_uart_tx_send_parity ||
	     WILL_FIRE_RL_uart_tx_send_byte ||
	     WILL_FIRE_RL_uart_tx_send_start ||
	     WILL_FIRE_RL_uart_tx_send_stop ;

  // register uart_tx_last_tstate
  assign uart_tx_last_tstate$D_IN = uart_tx_tstate ;
  assign uart_tx_last_tstate$EN =
	     CAN_FIRE_RL_uart_tx_monitor_state_for_debug ;

  // register uart_tx_parity_xor
  always@(lcr or x__h2159 or z__h2204 or z__h2211 or z__h2218)
  begin
    case (lcr[1:0])
      2'd0: uart_tx_parity_xor$D_IN = z__h2204;
      2'd1: uart_tx_parity_xor$D_IN = z__h2211;
      2'd2: uart_tx_parity_xor$D_IN = z__h2218;
      2'd3: uart_tx_parity_xor$D_IN = x__h2159;
    endcase
  end
  assign uart_tx_parity_xor$EN = WILL_FIRE_RL_uart_tx_pop_byte ;

  // register uart_tx_shift_out
  assign uart_tx_shift_out$D_IN =
	     MUX_uart_tx_bit_counter$write_1__SEL_2 ?
	       MUX_uart_tx_shift_out$write_1__VAL_1 :
	       uart_tx_tx_fifo$D_OUT[7:1] ;
  assign uart_tx_shift_out$EN =
	     WILL_FIRE_RL_uart_tx_send_byte && uart_tx_counter == 5'd1 &&
	     uart_tx_bit_counter != 3'd0 ||
	     WILL_FIRE_RL_uart_tx_pop_byte ;

  // register uart_tx_stx_o_tmp
  always@(MUX_uart_tx_stx_o_tmp$write_1__SEL_1 or
	  uart_tx_bit_out or
	  WILL_FIRE_RL_uart_tx_send_start or
	  MUX_uart_tx_stx_o_tmp$write_1__SEL_3)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_uart_tx_stx_o_tmp$write_1__SEL_1:
	  uart_tx_stx_o_tmp$D_IN = uart_tx_bit_out;
      WILL_FIRE_RL_uart_tx_send_start: uart_tx_stx_o_tmp$D_IN = 1'd0;
      MUX_uart_tx_stx_o_tmp$write_1__SEL_3: uart_tx_stx_o_tmp$D_IN = 1'd1;
      default: uart_tx_stx_o_tmp$D_IN = 1'b0 /* unspecified value */ ;
    endcase
  end
  assign uart_tx_stx_o_tmp$EN =
	     WILL_FIRE_RL_uart_tx_send_parity ||
	     WILL_FIRE_RL_uart_tx_send_byte ||
	     WILL_FIRE_RL_uart_tx_send_start ||
	     WILL_FIRE_RL_uart_tx_send_stop ||
	     WILL_FIRE_RL_uart_tx_idle ;

  // register uart_tx_tstate
  always@(MUX_uart_tx_tstate$write_1__SEL_1 or
	  MUX_uart_tx_tstate$write_1__SEL_2 or
	  MUX_uart_tx_tstate$write_1__SEL_3 or
	  MUX_uart_tx_tstate$write_1__SEL_4 or
	  MUX_uart_tx_tstate$write_1__VAL_4 or
	  WILL_FIRE_RL_uart_tx_idle or WILL_FIRE_RL_uart_tx_pop_byte)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_uart_tx_tstate$write_1__SEL_1: uart_tx_tstate$D_IN = 3'd0;
      MUX_uart_tx_tstate$write_1__SEL_2: uart_tx_tstate$D_IN = 3'd3;
      MUX_uart_tx_tstate$write_1__SEL_3: uart_tx_tstate$D_IN = 3'd5;
      MUX_uart_tx_tstate$write_1__SEL_4:
	  uart_tx_tstate$D_IN = MUX_uart_tx_tstate$write_1__VAL_4;
      WILL_FIRE_RL_uart_tx_idle: uart_tx_tstate$D_IN = 3'd1;
      WILL_FIRE_RL_uart_tx_pop_byte: uart_tx_tstate$D_IN = 3'd2;
      default: uart_tx_tstate$D_IN = 3'b010 /* unspecified value */ ;
    endcase
  end
  assign uart_tx_tstate$EN =
	     WILL_FIRE_RL_uart_tx_send_stop && uart_tx_counter == 5'd1 ||
	     WILL_FIRE_RL_uart_tx_send_start && uart_tx_counter == 5'd1 ||
	     WILL_FIRE_RL_uart_tx_send_parity && uart_tx_counter == 5'd1 ||
	     WILL_FIRE_RL_uart_tx_send_byte && uart_tx_counter == 5'd1 &&
	     uart_tx_bit_counter == 3'd0 ||
	     WILL_FIRE_RL_uart_tx_idle ||
	     WILL_FIRE_RL_uart_tx_pop_byte ;

  // submodule rx_fifo
  assign rx_fifo$D_IN = uart_rx_rx_fifo$D_OUT ;
  assign rx_fifo$ENQ = rx_fifo_r_enq$whas ;
  assign rx_fifo$DEQ = rx_fifo_r_deq$whas ;
  assign rx_fifo$CLR = rx_fifo_r_clr$whas ;

  // submodule s_xactor_f_rd_addr
  assign s_xactor_f_rd_addr$D_IN =
	     { slave_axi_uart_m_arvalid_araddr,
	       slave_axi_uart_m_arvalid_arprot,
	       slave_axi_uart_m_arvalid_aruser,
	       slave_axi_uart_m_arvalid_arlen,
	       slave_axi_uart_m_arvalid_arsize,
	       slave_axi_uart_m_arvalid_arburst,
	       slave_axi_uart_m_arvalid_arlock,
	       slave_axi_uart_m_arvalid_arcache,
	       slave_axi_uart_m_arvalid_arqos,
	       slave_axi_uart_m_arvalid_arregion,
	       slave_axi_uart_m_arvalid_arid } ;
  assign s_xactor_f_rd_addr$ENQ =
	     slave_axi_uart_m_arvalid_arvalid && s_xactor_f_rd_addr$FULL_N ;
  assign s_xactor_f_rd_addr$DEQ =
	     CAN_FIRE_RL_handle_axi4_read && !uart_rx_rx_fifo$EMPTY_N ;
  assign s_xactor_f_rd_addr$CLR = 1'b0 ;

  // submodule s_xactor_f_rd_data
  assign s_xactor_f_rd_data$D_IN =
	     { 2'd0,
	       x_rdata__h14630,
	       11'd1024,
	       s_xactor_f_rd_addr$D_OUT[3:0] } ;
  assign s_xactor_f_rd_data$ENQ =
	     CAN_FIRE_RL_handle_axi4_read && !uart_rx_rx_fifo$EMPTY_N ;
  assign s_xactor_f_rd_data$DEQ =
	     slave_axi_uart_m_rready_rready && s_xactor_f_rd_data$EMPTY_N ;
  assign s_xactor_f_rd_data$CLR = 1'b0 ;

  // submodule s_xactor_f_wr_addr
  assign s_xactor_f_wr_addr$D_IN =
	     { slave_axi_uart_m_awvalid_awaddr,
	       slave_axi_uart_m_awvalid_awprot,
	       slave_axi_uart_m_awvalid_awuser,
	       slave_axi_uart_m_awvalid_awlen,
	       slave_axi_uart_m_awvalid_awsize,
	       slave_axi_uart_m_awvalid_awburst,
	       slave_axi_uart_m_awvalid_awlock,
	       slave_axi_uart_m_awvalid_awcache,
	       slave_axi_uart_m_awvalid_awqos,
	       slave_axi_uart_m_awvalid_awregion,
	       slave_axi_uart_m_awvalid_awid } ;
  assign s_xactor_f_wr_addr$ENQ =
	     EN_slave_axi_uart_m_awvalid && slave_axi_uart_m_awvalid_awvalid ;
  assign s_xactor_f_wr_addr$DEQ =
	     s_xactor_f_wr_data$EMPTY_N && s_xactor_f_wr_resp$FULL_N &&
	     s_xactor_f_wr_addr$EMPTY_N ;
  assign s_xactor_f_wr_addr$CLR = 1'b0 ;

  // submodule s_xactor_f_wr_data
  assign s_xactor_f_wr_data$D_IN =
	     { slave_axi_uart_m_wvalid_wdata,
	       slave_axi_uart_m_wvalid_wstrb,
	       slave_axi_uart_m_wvalid_wid,
	       slave_axi_uart_m_wvalid_wlast } ;
  assign s_xactor_f_wr_data$ENQ =
	     EN_slave_axi_uart_m_wvalid && slave_axi_uart_m_wvalid_wvalid ;
  assign s_xactor_f_wr_data$DEQ =
	     s_xactor_f_wr_data$EMPTY_N && s_xactor_f_wr_resp$FULL_N &&
	     s_xactor_f_wr_addr$EMPTY_N ;
  assign s_xactor_f_wr_data$CLR = 1'b0 ;

  // submodule s_xactor_f_wr_resp
  assign s_xactor_f_wr_resp$D_IN = { 12'd0, s_xactor_f_wr_addr$D_OUT[3:0] } ;
  assign s_xactor_f_wr_resp$ENQ =
	     s_xactor_f_wr_data$EMPTY_N && s_xactor_f_wr_resp$FULL_N &&
	     s_xactor_f_wr_addr$EMPTY_N ;
  assign s_xactor_f_wr_resp$DEQ =
	     slave_axi_uart_m_bready_bready && s_xactor_f_wr_resp$EMPTY_N ;
  assign s_xactor_f_wr_resp$CLR = 1'b0 ;

  // submodule tx_fifo
  assign tx_fifo$D_IN = s_xactor_f_wr_data$D_OUT[20:13] ;
  assign tx_fifo$ENQ =
	     WILL_FIRE_RL_handle_axi4_write &&
	     s_xactor_f_wr_addr$D_OUT[48:46] == 3'd0 &&
	     !lcr[7] &&
	     tx_fifo$FULL_N ;
  assign tx_fifo$DEQ = CAN_FIRE_RL_forward_tx ;
  assign tx_fifo$CLR = CAN_FIRE_RL_forward_tx_clear ;

  // submodule uart_rx_rx_fifo
  assign uart_rx_rx_fifo$D_IN =
	     (uart_rx_counter_b == 8'd0) ?
	       11'd6 :
	       { uart_rx_rshift,
		 1'd0,
		 uart_rx_rparity_error,
		 uart_rx_rframing_error } ;
  assign uart_rx_rx_fifo$ENQ = MUX_uart_rx_rstate$write_1__SEL_8 ;
  assign uart_rx_rx_fifo$DEQ = rx_fifo_r_enq$whas ;
  assign uart_rx_rx_fifo$CLR = 1'b0 ;

  // submodule uart_tx_tx_fifo
  assign uart_tx_tx_fifo$D_IN = tx_fifo$D_OUT ;
  assign uart_tx_tx_fifo$ENQ = CAN_FIRE_RL_forward_tx ;
  assign uart_tx_tx_fifo$DEQ = MUX_uart_tx_tstate$write_1__SEL_1 ;
  assign uart_tx_tx_fifo$CLR = 1'b0 ;

  // remaining internal signals
  assign IF_NOT_rls_int_q_28_95_AND_NOT_rda_int_q_42_96_ETC___d614 =
	     (!rls_int_q && !rda_int_q && !ti_int_q && thre_int_q) ?
	       4'd2 :
	       ((!rls_int_q && rda_int_q) ?
		  4'd4 :
		  (rls_int_q ? 4'd6 : 4'd12)) ;
  assign IF_NOT_rls_int_q_28_95_AND_NOT_rda_int_q_42_96_ETC___d616 =
	     (!rls_int_q && !rda_int_q && !ti_int_q && !thre_int_q &&
	      ms_int_q) ?
	       4'd0 :
	       ((!rls_int_q && !rda_int_q && !ti_int_q && !thre_int_q &&
		 !ms_int_q) ?
		  4'd1 :
		  IF_NOT_rls_int_q_28_95_AND_NOT_rda_int_q_42_96_ETC___d614) ;
  assign IF_uart_tx_lc_wget__9_BIT_4_2_CONCAT_uart_tx_l_ETC___d92 =
	     (x__h3152 == 2'b0) ?
	       x__h3203 :
	       x__h3152 == 2'b01 || x__h3152 == 2'b10 && uart_tx_parity_xor ;
  assign _dand2rda_int_s$EN_wset =
	     ier[0] && !(!rx_fifo$EMPTY_N) &&
	     !rx_fifo_countReg_12_ULT_IF_fcr_67_EQ_0b1_68_TH_ETC___d474 ;
  assign _dfoo1 =
	     count_error_clear_whas__40_OR_count_error_up_w_ETC___d548 ||
	     !rx_fifo_clear_pw$whas && !count_error_up$whas &&
	     count_error_down$whas &&
	     count_error != 17'd0 ;
  assign count_error_clear_whas__40_OR_count_error_up_w_ETC___d548 =
	     rx_fifo_clear_pw$whas ||
	     count_error_up$whas && !count_error_down$whas &&
	     count_error < 17'd16 ;
  assign ier_51_BIT_2_52_AND_rx_fifo_full_wget__53_OR_r_ETC___d461 =
	     ier[2] &&
	     (!rx_fifo$FULL_N || rx_fifo_first$wget[1] ||
	      rx_fifo_first$wget[0] ||
	      rx_fifo_first$wget[2]) ;
  assign ier_51_BIT_3_87_AND_NOT_msr_88_BIT_0_89_CONCAT_ETC___d497 =
	     ier[3] && { msr[0], msr[1], msr[2], msr[3] } != 4'd0 ;
  assign rtn__h14164 = lcr[7] ? dl2r : { 4'd0, ier } ;
  assign rtn__h14171 =
	     { 4'b1100,
	       IF_NOT_rls_int_q_28_95_AND_NOT_rda_int_q_42_96_ETC___d616 } ;
  assign rtn__h14185 = { 3'd0, mcr } ;
  assign rx_fifo_countReg_12_ULT_IF_fcr_67_EQ_0b1_68_TH_ETC___d474 =
	     rx_fifo_countReg < CASE_fcr_0_1_0b1_4_0b10_8_0b11_14_1__q1 ;
  assign spliced_bits__h5664 = { uart_rx_rx_stable, uart_rx_rshift[4:1] } ;
  assign spliced_bits__h5752 = { uart_rx_rx_stable, uart_rx_rshift[5:1] } ;
  assign spliced_bits__h5839 = { uart_rx_rx_stable, uart_rx_rshift[6:1] } ;
  assign uart_tx_counter_3_MINUS_1___d66 = uart_tx_counter - 5'd1 ;
  assign uart_tx_lc_wget__9_BIT_3_1_AND_uart_tx_lc_wget_ETC___d86 =
	     lcr[3] || uart_tx_bit_counter != 3'd0 ;
  assign x__h12280 = pin_dcd ^ prev_dcd ;
  assign x__h12282 = pin_ri ^ prev_ri ;
  assign x__h12284 = pin_dsr ^ prev_dsr ;
  assign x__h12286 = pin_cts ^ prev_cts ;
  assign x__h12475 = rx_fifo$EMPTY_N ? rx_fifo$D_OUT[10:3] : 8'd0 ;
  assign x__h13400 = x__h13465 - 16'd1 ;
  assign x__h13444 = dl_update$wget[15:0] - 16'd1 ;
  assign x__h13465 = (dlc == 16'd0) ? dl : dlc ;
  assign x__h2159 = z__h2218 ^ uart_tx_tx_fifo$D_OUT[7] ;
  assign x__h3152 = { lcr[4], lcr[5] } ;
  assign x__h3203 = ~uart_tx_parity_xor ;
  assign x__h5652 = { uart_rx_rshift[7:5], spliced_bits__h5664 } ;
  assign x__h5740 = { uart_rx_rshift[7:6], spliced_bits__h5752 } ;
  assign x__h5827 = { uart_rx_rshift[7], spliced_bits__h5839 } ;
  assign x__h5914 = { uart_rx_rx_stable, uart_rx_rshift[7:1] } ;
  assign x__h6728 = x__h3152 ;
  assign x__h6779 = ~uart_rx_rparity_xor ;
  assign x__h6807 = ~uart_rx_rparity ;
  assign x_rdata__h14630 =
	     (s_xactor_f_rd_addr$D_OUT[48:46] != 3'd0 || lcr[7] ||
	      !(!rx_fifo$EMPTY_N)) ?
	       { 56'd0, x__h14637 } :
	       64'hFFFFFFFFFFFFFFFF ;
  assign y_avValue_snd__h14441 =
	     (!rx_fifo$EMPTY_N) ? 8'd0 : rx_fifo$D_OUT[10:3] ;
  assign y_avValue_snd__h14576 = lcr[7] ? dl1r : y_avValue_snd__h14441 ;
  assign z__h2183 = uart_tx_tx_fifo$D_OUT[0] ^ uart_tx_tx_fifo$D_OUT[1] ;
  assign z__h2190 = z__h2183 ^ uart_tx_tx_fifo$D_OUT[2] ;
  assign z__h2197 = z__h2190 ^ uart_tx_tx_fifo$D_OUT[3] ;
  assign z__h2204 = z__h2197 ^ uart_tx_tx_fifo$D_OUT[4] ;
  assign z__h2211 = z__h2204 ^ uart_tx_tx_fifo$D_OUT[5] ;
  assign z__h2218 = z__h2211 ^ uart_tx_tx_fifo$D_OUT[6] ;
  assign z__h6432 = uart_rx_rparity ^ uart_rx_rshift[0] ;
  assign z__h6439 = z__h6432 ^ uart_rx_rshift[1] ;
  assign z__h6446 = z__h6439 ^ uart_rx_rshift[2] ;
  assign z__h6453 = z__h6446 ^ uart_rx_rshift[3] ;
  assign z__h6460 = z__h6453 ^ uart_rx_rshift[4] ;
  assign z__h6467 = z__h6460 ^ uart_rx_rshift[5] ;
  assign z__h6474 = z__h6467 ^ uart_rx_rshift[6] ;
  always@(fcr)
  begin
    case (fcr)
      2'd0: CASE_fcr_0_1_0b1_4_0b10_8_0b11_14_1__q1 = 5'd1;
      2'b01: CASE_fcr_0_1_0b1_4_0b10_8_0b11_14_1__q1 = 5'd4;
      2'b10: CASE_fcr_0_1_0b1_4_0b10_8_0b11_14_1__q1 = 5'd8;
      2'b11: CASE_fcr_0_1_0b1_4_0b10_8_0b11_14_1__q1 = 5'd14;
    endcase
  end
  always@(lcr)
  begin
    case (lcr[3:0])
      4'b0:
	  IF_uart_rx_lc_wget__53_BITS_3_TO_0_54_EQ_0b0_5_ETC___d186 = 10'd447;
      4'b0001, 4'b1000:
	  IF_uart_rx_lc_wget__53_BITS_3_TO_0_54_EQ_0b0_5_ETC___d186 = 10'd511;
      4'b0010, 4'b0101, 4'b1001:
	  IF_uart_rx_lc_wget__53_BITS_3_TO_0_54_EQ_0b0_5_ETC___d186 = 10'd575;
      4'b0011, 4'b0110, 4'b1010, 4'b1101:
	  IF_uart_rx_lc_wget__53_BITS_3_TO_0_54_EQ_0b0_5_ETC___d186 = 10'd639;
      4'b0100:
	  IF_uart_rx_lc_wget__53_BITS_3_TO_0_54_EQ_0b0_5_ETC___d186 = 10'd479;
      4'b0111, 4'b1011, 4'b1110:
	  IF_uart_rx_lc_wget__53_BITS_3_TO_0_54_EQ_0b0_5_ETC___d186 = 10'd703;
      4'b1100:
	  IF_uart_rx_lc_wget__53_BITS_3_TO_0_54_EQ_0b0_5_ETC___d186 = 10'd543;
      4'b1111:
	  IF_uart_rx_lc_wget__53_BITS_3_TO_0_54_EQ_0b0_5_ETC___d186 = 10'd767;
    endcase
  end
  always@(s_xactor_f_rd_addr$D_OUT or
	  y_avValue_snd__h14576 or
	  rtn__h14164 or
	  rtn__h14171 or
	  lcr or
	  rtn__h14185 or
	  rx_fifo$FULL_N or
	  count_error or
	  tx_fifo$EMPTY_N or
	  uart_tx_tx_fifo$EMPTY_N or
	  rx_fifo_first$wget or rx_fifo$EMPTY_N or msr or scratch)
  begin
    case (s_xactor_f_rd_addr$D_OUT[48:46])
      3'd0: x__h14637 = y_avValue_snd__h14576;
      3'd1: x__h14637 = rtn__h14164;
      3'd2: x__h14637 = rtn__h14171;
      3'd3: x__h14637 = lcr;
      3'd4: x__h14637 = rtn__h14185;
      3'd5:
	  x__h14637 =
	      { !rx_fifo$FULL_N || count_error != 17'd0,
		!tx_fifo$EMPTY_N && !uart_tx_tx_fifo$EMPTY_N,
		!tx_fifo$EMPTY_N,
		rx_fifo_first$wget[2],
		rx_fifo_first$wget[0],
		rx_fifo_first$wget[1],
		!rx_fifo$FULL_N,
		!(!rx_fifo$EMPTY_N) };
      3'd6: x__h14637 = msr;
      3'd7: x__h14637 = scratch;
    endcase
  end

  // handling of inlined registers

  always@(posedge csi_clockreset_clk)
  begin
    if (csi_clockreset_reset_n == `BSV_RESET_VALUE)
      begin
        count_error <= `BSV_ASSIGNMENT_DELAY 17'd0;
	dl <= `BSV_ASSIGNMENT_DELAY 16'd0;
	dl1r <= `BSV_ASSIGNMENT_DELAY 8'd0;
	dl2r <= `BSV_ASSIGNMENT_DELAY 8'd0;
	dlc <= `BSV_ASSIGNMENT_DELAY 16'd0;
	enable <= `BSV_ASSIGNMENT_DELAY 1'd0;
	fcr <= `BSV_ASSIGNMENT_DELAY 2'b11;
	ier <= `BSV_ASSIGNMENT_DELAY 4'd0;
	lcr <= `BSV_ASSIGNMENT_DELAY 8'd3;
	lsr <= `BSV_ASSIGNMENT_DELAY 8'd0;
	mcr <= `BSV_ASSIGNMENT_DELAY 5'd0;
	ms_int_q <= `BSV_ASSIGNMENT_DELAY 1'd0;
	ms_int_r_prev <= `BSV_ASSIGNMENT_DELAY 1'd0;
	ms_int_s_prev <= `BSV_ASSIGNMENT_DELAY 1'd0;
	msr <= `BSV_ASSIGNMENT_DELAY 8'd0;
	pin_cts <= `BSV_ASSIGNMENT_DELAY 1'd0;
	pin_cts_c <= `BSV_ASSIGNMENT_DELAY 1'd0;
	pin_cts_sync <= `BSV_ASSIGNMENT_DELAY 1'd0;
	pin_dcd <= `BSV_ASSIGNMENT_DELAY 1'd0;
	pin_dcd_c <= `BSV_ASSIGNMENT_DELAY 1'd0;
	pin_dcd_sync <= `BSV_ASSIGNMENT_DELAY 1'd0;
	pin_dsr <= `BSV_ASSIGNMENT_DELAY 1'd0;
	pin_dsr_c <= `BSV_ASSIGNMENT_DELAY 1'd0;
	pin_dsr_sync <= `BSV_ASSIGNMENT_DELAY 1'd0;
	pin_dtr <= `BSV_ASSIGNMENT_DELAY 1'd0;
	pin_ri <= `BSV_ASSIGNMENT_DELAY 1'd0;
	pin_ri_c <= `BSV_ASSIGNMENT_DELAY 1'd0;
	pin_ri_sync <= `BSV_ASSIGNMENT_DELAY 1'd0;
	pin_rts <= `BSV_ASSIGNMENT_DELAY 1'd0;
	pin_srx <= `BSV_ASSIGNMENT_DELAY 1'd0;
	pin_srx_c <= `BSV_ASSIGNMENT_DELAY 1'd0;
	pin_srx_sync <= `BSV_ASSIGNMENT_DELAY 1'd0;
	pin_stx <= `BSV_ASSIGNMENT_DELAY 1'd0;
	prev_cts <= `BSV_ASSIGNMENT_DELAY 1'd0;
	prev_dcd <= `BSV_ASSIGNMENT_DELAY 1'd0;
	prev_dsr <= `BSV_ASSIGNMENT_DELAY 1'd0;
	prev_ri <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rda_int_q <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rda_int_r_prev <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rda_int_s_prev <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rls_int_q <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rls_int_r_prev <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rls_int_s_prev <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rx_fifo_countReg <= `BSV_ASSIGNMENT_DELAY 5'd0;
	scratch <= `BSV_ASSIGNMENT_DELAY 8'd0;
	thre_int_q <= `BSV_ASSIGNMENT_DELAY 1'd0;
	thre_int_r_prev <= `BSV_ASSIGNMENT_DELAY 1'd0;
	thre_int_s_prev <= `BSV_ASSIGNMENT_DELAY 1'd0;
	ti_int_q <= `BSV_ASSIGNMENT_DELAY 1'd0;
	ti_int_r_prev <= `BSV_ASSIGNMENT_DELAY 1'd0;
	ti_int_s_prev <= `BSV_ASSIGNMENT_DELAY 1'd0;
	uart_rx_counter_b <= `BSV_ASSIGNMENT_DELAY 8'd159;
	uart_rx_counter_t <= `BSV_ASSIGNMENT_DELAY 10'd511;
	uart_rx_last_rstate <= `BSV_ASSIGNMENT_DELAY 4'd0;
	uart_rx_rbit_counter <= `BSV_ASSIGNMENT_DELAY 3'd0;
	uart_rx_rcounter <= `BSV_ASSIGNMENT_DELAY 4'd0;
	uart_rx_rframing_error <= `BSV_ASSIGNMENT_DELAY 1'd0;
	uart_rx_rparity <= `BSV_ASSIGNMENT_DELAY 1'd0;
	uart_rx_rparity_error <= `BSV_ASSIGNMENT_DELAY 1'd0;
	uart_rx_rparity_xor <= `BSV_ASSIGNMENT_DELAY 1'd0;
	uart_rx_rshift <= `BSV_ASSIGNMENT_DELAY 8'd0;
	uart_rx_rstate <= `BSV_ASSIGNMENT_DELAY 4'd0;
	uart_rx_rx_stable <= `BSV_ASSIGNMENT_DELAY 1'd1;
	uart_tx_bit_counter <= `BSV_ASSIGNMENT_DELAY 3'd0;
	uart_tx_bit_out <= `BSV_ASSIGNMENT_DELAY 1'd0;
	uart_tx_counter <= `BSV_ASSIGNMENT_DELAY 5'd0;
	uart_tx_last_tstate <= `BSV_ASSIGNMENT_DELAY 3'd0;
	uart_tx_parity_xor <= `BSV_ASSIGNMENT_DELAY 1'd0;
	uart_tx_shift_out <= `BSV_ASSIGNMENT_DELAY 7'd0;
	uart_tx_stx_o_tmp <= `BSV_ASSIGNMENT_DELAY 1'd1;
	uart_tx_tstate <= `BSV_ASSIGNMENT_DELAY 3'd0;
      end
    else
      begin
        if (count_error$EN)
	  count_error <= `BSV_ASSIGNMENT_DELAY count_error$D_IN;
	if (dl$EN) dl <= `BSV_ASSIGNMENT_DELAY dl$D_IN;
	if (dl1r$EN) dl1r <= `BSV_ASSIGNMENT_DELAY dl1r$D_IN;
	if (dl2r$EN) dl2r <= `BSV_ASSIGNMENT_DELAY dl2r$D_IN;
	if (dlc$EN) dlc <= `BSV_ASSIGNMENT_DELAY dlc$D_IN;
	if (enable$EN) enable <= `BSV_ASSIGNMENT_DELAY enable$D_IN;
	if (fcr$EN) fcr <= `BSV_ASSIGNMENT_DELAY fcr$D_IN;
	if (ier$EN) ier <= `BSV_ASSIGNMENT_DELAY ier$D_IN;
	if (lcr$EN) lcr <= `BSV_ASSIGNMENT_DELAY lcr$D_IN;
	if (lsr$EN) lsr <= `BSV_ASSIGNMENT_DELAY lsr$D_IN;
	if (mcr$EN) mcr <= `BSV_ASSIGNMENT_DELAY mcr$D_IN;
	if (ms_int_q$EN) ms_int_q <= `BSV_ASSIGNMENT_DELAY ms_int_q$D_IN;
	if (ms_int_r_prev$EN)
	  ms_int_r_prev <= `BSV_ASSIGNMENT_DELAY ms_int_r_prev$D_IN;
	if (ms_int_s_prev$EN)
	  ms_int_s_prev <= `BSV_ASSIGNMENT_DELAY ms_int_s_prev$D_IN;
	if (msr$EN) msr <= `BSV_ASSIGNMENT_DELAY msr$D_IN;
	if (pin_cts$EN) pin_cts <= `BSV_ASSIGNMENT_DELAY pin_cts$D_IN;
	if (pin_cts_c$EN) pin_cts_c <= `BSV_ASSIGNMENT_DELAY pin_cts_c$D_IN;
	if (pin_cts_sync$EN)
	  pin_cts_sync <= `BSV_ASSIGNMENT_DELAY pin_cts_sync$D_IN;
	if (pin_dcd$EN) pin_dcd <= `BSV_ASSIGNMENT_DELAY pin_dcd$D_IN;
	if (pin_dcd_c$EN) pin_dcd_c <= `BSV_ASSIGNMENT_DELAY pin_dcd_c$D_IN;
	if (pin_dcd_sync$EN)
	  pin_dcd_sync <= `BSV_ASSIGNMENT_DELAY pin_dcd_sync$D_IN;
	if (pin_dsr$EN) pin_dsr <= `BSV_ASSIGNMENT_DELAY pin_dsr$D_IN;
	if (pin_dsr_c$EN) pin_dsr_c <= `BSV_ASSIGNMENT_DELAY pin_dsr_c$D_IN;
	if (pin_dsr_sync$EN)
	  pin_dsr_sync <= `BSV_ASSIGNMENT_DELAY pin_dsr_sync$D_IN;
	if (pin_dtr$EN) pin_dtr <= `BSV_ASSIGNMENT_DELAY pin_dtr$D_IN;
	if (pin_ri$EN) pin_ri <= `BSV_ASSIGNMENT_DELAY pin_ri$D_IN;
	if (pin_ri_c$EN) pin_ri_c <= `BSV_ASSIGNMENT_DELAY pin_ri_c$D_IN;
	if (pin_ri_sync$EN)
	  pin_ri_sync <= `BSV_ASSIGNMENT_DELAY pin_ri_sync$D_IN;
	if (pin_rts$EN) pin_rts <= `BSV_ASSIGNMENT_DELAY pin_rts$D_IN;
	if (pin_srx$EN) pin_srx <= `BSV_ASSIGNMENT_DELAY pin_srx$D_IN;
	if (pin_srx_c$EN) pin_srx_c <= `BSV_ASSIGNMENT_DELAY pin_srx_c$D_IN;
	if (pin_srx_sync$EN)
	  pin_srx_sync <= `BSV_ASSIGNMENT_DELAY pin_srx_sync$D_IN;
	if (pin_stx$EN) pin_stx <= `BSV_ASSIGNMENT_DELAY pin_stx$D_IN;
	if (prev_cts$EN) prev_cts <= `BSV_ASSIGNMENT_DELAY prev_cts$D_IN;
	if (prev_dcd$EN) prev_dcd <= `BSV_ASSIGNMENT_DELAY prev_dcd$D_IN;
	if (prev_dsr$EN) prev_dsr <= `BSV_ASSIGNMENT_DELAY prev_dsr$D_IN;
	if (prev_ri$EN) prev_ri <= `BSV_ASSIGNMENT_DELAY prev_ri$D_IN;
	if (rda_int_q$EN) rda_int_q <= `BSV_ASSIGNMENT_DELAY rda_int_q$D_IN;
	if (rda_int_r_prev$EN)
	  rda_int_r_prev <= `BSV_ASSIGNMENT_DELAY rda_int_r_prev$D_IN;
	if (rda_int_s_prev$EN)
	  rda_int_s_prev <= `BSV_ASSIGNMENT_DELAY rda_int_s_prev$D_IN;
	if (rls_int_q$EN) rls_int_q <= `BSV_ASSIGNMENT_DELAY rls_int_q$D_IN;
	if (rls_int_r_prev$EN)
	  rls_int_r_prev <= `BSV_ASSIGNMENT_DELAY rls_int_r_prev$D_IN;
	if (rls_int_s_prev$EN)
	  rls_int_s_prev <= `BSV_ASSIGNMENT_DELAY rls_int_s_prev$D_IN;
	if (rx_fifo_countReg$EN)
	  rx_fifo_countReg <= `BSV_ASSIGNMENT_DELAY rx_fifo_countReg$D_IN;
	if (scratch$EN) scratch <= `BSV_ASSIGNMENT_DELAY scratch$D_IN;
	if (thre_int_q$EN)
	  thre_int_q <= `BSV_ASSIGNMENT_DELAY thre_int_q$D_IN;
	if (thre_int_r_prev$EN)
	  thre_int_r_prev <= `BSV_ASSIGNMENT_DELAY thre_int_r_prev$D_IN;
	if (thre_int_s_prev$EN)
	  thre_int_s_prev <= `BSV_ASSIGNMENT_DELAY thre_int_s_prev$D_IN;
	if (ti_int_q$EN) ti_int_q <= `BSV_ASSIGNMENT_DELAY ti_int_q$D_IN;
	if (ti_int_r_prev$EN)
	  ti_int_r_prev <= `BSV_ASSIGNMENT_DELAY ti_int_r_prev$D_IN;
	if (ti_int_s_prev$EN)
	  ti_int_s_prev <= `BSV_ASSIGNMENT_DELAY ti_int_s_prev$D_IN;
	if (uart_rx_counter_b$EN)
	  uart_rx_counter_b <= `BSV_ASSIGNMENT_DELAY uart_rx_counter_b$D_IN;
	if (uart_rx_counter_t$EN)
	  uart_rx_counter_t <= `BSV_ASSIGNMENT_DELAY uart_rx_counter_t$D_IN;
	if (uart_rx_last_rstate$EN)
	  uart_rx_last_rstate <= `BSV_ASSIGNMENT_DELAY
	      uart_rx_last_rstate$D_IN;
	if (uart_rx_rbit_counter$EN)
	  uart_rx_rbit_counter <= `BSV_ASSIGNMENT_DELAY
	      uart_rx_rbit_counter$D_IN;
	if (uart_rx_rcounter$EN)
	  uart_rx_rcounter <= `BSV_ASSIGNMENT_DELAY uart_rx_rcounter$D_IN;
	if (uart_rx_rframing_error$EN)
	  uart_rx_rframing_error <= `BSV_ASSIGNMENT_DELAY
	      uart_rx_rframing_error$D_IN;
	if (uart_rx_rparity$EN)
	  uart_rx_rparity <= `BSV_ASSIGNMENT_DELAY uart_rx_rparity$D_IN;
	if (uart_rx_rparity_error$EN)
	  uart_rx_rparity_error <= `BSV_ASSIGNMENT_DELAY
	      uart_rx_rparity_error$D_IN;
	if (uart_rx_rparity_xor$EN)
	  uart_rx_rparity_xor <= `BSV_ASSIGNMENT_DELAY
	      uart_rx_rparity_xor$D_IN;
	if (uart_rx_rshift$EN)
	  uart_rx_rshift <= `BSV_ASSIGNMENT_DELAY uart_rx_rshift$D_IN;
	if (uart_rx_rstate$EN)
	  uart_rx_rstate <= `BSV_ASSIGNMENT_DELAY uart_rx_rstate$D_IN;
	if (uart_rx_rx_stable$EN)
	  uart_rx_rx_stable <= `BSV_ASSIGNMENT_DELAY uart_rx_rx_stable$D_IN;
	if (uart_tx_bit_counter$EN)
	  uart_tx_bit_counter <= `BSV_ASSIGNMENT_DELAY
	      uart_tx_bit_counter$D_IN;
	if (uart_tx_bit_out$EN)
	  uart_tx_bit_out <= `BSV_ASSIGNMENT_DELAY uart_tx_bit_out$D_IN;
	if (uart_tx_counter$EN)
	  uart_tx_counter <= `BSV_ASSIGNMENT_DELAY uart_tx_counter$D_IN;
	if (uart_tx_last_tstate$EN)
	  uart_tx_last_tstate <= `BSV_ASSIGNMENT_DELAY
	      uart_tx_last_tstate$D_IN;
	if (uart_tx_parity_xor$EN)
	  uart_tx_parity_xor <= `BSV_ASSIGNMENT_DELAY uart_tx_parity_xor$D_IN;
	if (uart_tx_shift_out$EN)
	  uart_tx_shift_out <= `BSV_ASSIGNMENT_DELAY uart_tx_shift_out$D_IN;
	if (uart_tx_stx_o_tmp$EN)
	  uart_tx_stx_o_tmp <= `BSV_ASSIGNMENT_DELAY uart_tx_stx_o_tmp$D_IN;
	if (uart_tx_tstate$EN)
	  uart_tx_tstate <= `BSV_ASSIGNMENT_DELAY uart_tx_tstate$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    count_error = 17'h0AAAA;
    dl = 16'hAAAA;
    dl1r = 8'hAA;
    dl2r = 8'hAA;
    dlc = 16'hAAAA;
    enable = 1'h0;
    fcr = 2'h2;
    ier = 4'hA;
    lcr = 8'hAA;
    lsr = 8'hAA;
    mcr = 5'h0A;
    ms_int_q = 1'h0;
    ms_int_r_prev = 1'h0;
    ms_int_s_prev = 1'h0;
    msr = 8'hAA;
    pin_cts = 1'h0;
    pin_cts_c = 1'h0;
    pin_cts_sync = 1'h0;
    pin_dcd = 1'h0;
    pin_dcd_c = 1'h0;
    pin_dcd_sync = 1'h0;
    pin_dsr = 1'h0;
    pin_dsr_c = 1'h0;
    pin_dsr_sync = 1'h0;
    pin_dtr = 1'h0;
    pin_ri = 1'h0;
    pin_ri_c = 1'h0;
    pin_ri_sync = 1'h0;
    pin_rts = 1'h0;
    pin_srx = 1'h0;
    pin_srx_c = 1'h0;
    pin_srx_sync = 1'h0;
    pin_stx = 1'h0;
    prev_cts = 1'h0;
    prev_dcd = 1'h0;
    prev_dsr = 1'h0;
    prev_ri = 1'h0;
    rda_int_q = 1'h0;
    rda_int_r_prev = 1'h0;
    rda_int_s_prev = 1'h0;
    rls_int_q = 1'h0;
    rls_int_r_prev = 1'h0;
    rls_int_s_prev = 1'h0;
    rx_fifo_countReg = 5'h0A;
    scratch = 8'hAA;
    thre_int_q = 1'h0;
    thre_int_r_prev = 1'h0;
    thre_int_s_prev = 1'h0;
    ti_int_q = 1'h0;
    ti_int_r_prev = 1'h0;
    ti_int_s_prev = 1'h0;
    uart_rx_counter_b = 8'hAA;
    uart_rx_counter_t = 10'h2AA;
    uart_rx_last_rstate = 4'hA;
    uart_rx_rbit_counter = 3'h2;
    uart_rx_rcounter = 4'hA;
    uart_rx_rframing_error = 1'h0;
    uart_rx_rparity = 1'h0;
    uart_rx_rparity_error = 1'h0;
    uart_rx_rparity_xor = 1'h0;
    uart_rx_rshift = 8'hAA;
    uart_rx_rstate = 4'hA;
    uart_rx_rx_stable = 1'h0;
    uart_tx_bit_counter = 3'h2;
    uart_tx_bit_out = 1'h0;
    uart_tx_counter = 5'h0A;
    uart_tx_last_tstate = 3'h2;
    uart_tx_parity_xor = 1'h0;
    uart_tx_shift_out = 7'h2A;
    uart_tx_stx_o_tmp = 1'h0;
    uart_tx_tstate = 3'h2;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge csi_clockreset_clk)
  begin
    #0;
    if (csi_clockreset_reset_n != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_uart_tx_monitor_state_for_debug)
	begin
	  v__h1087 = $time;
	  #0;
	end
    if (csi_clockreset_reset_n != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_uart_tx_monitor_state_for_debug)
	$write("%05t: UART TX state change ", v__h1087);
    if (csi_clockreset_reset_n != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_uart_tx_monitor_state_for_debug &&
	  uart_tx_last_tstate == 3'd0)
	$write("STX_idle");
    if (csi_clockreset_reset_n != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_uart_tx_monitor_state_for_debug &&
	  uart_tx_last_tstate == 3'd1)
	$write("STX_pop_byte");
    if (csi_clockreset_reset_n != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_uart_tx_monitor_state_for_debug &&
	  uart_tx_last_tstate == 3'd2)
	$write("STX_send_start");
    if (csi_clockreset_reset_n != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_uart_tx_monitor_state_for_debug &&
	  uart_tx_last_tstate == 3'd3)
	$write("STX_send_byte");
    if (csi_clockreset_reset_n != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_uart_tx_monitor_state_for_debug &&
	  uart_tx_last_tstate == 3'd4)
	$write("STX_send_parity");
    if (csi_clockreset_reset_n != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_uart_tx_monitor_state_for_debug &&
	  uart_tx_last_tstate != 3'd0 &&
	  uart_tx_last_tstate != 3'd1 &&
	  uart_tx_last_tstate != 3'd2 &&
	  uart_tx_last_tstate != 3'd3 &&
	  uart_tx_last_tstate != 3'd4)
	$write("STX_send_stop");
    if (csi_clockreset_reset_n != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_uart_tx_monitor_state_for_debug) $write(" -> ");
    if (csi_clockreset_reset_n != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_uart_rx_monitor_state_for_debug)
	begin
	  v__h4707 = $time;
	  #0;
	end
    if (csi_clockreset_reset_n != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_uart_rx_monitor_state_for_debug)
	$write("%05t: UART RX state change ", v__h4707);
    if (csi_clockreset_reset_n != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_uart_rx_monitor_state_for_debug &&
	  uart_rx_last_rstate == 4'd0)
	$write("SRX_idle");
    if (csi_clockreset_reset_n != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_uart_rx_monitor_state_for_debug &&
	  uart_rx_last_rstate == 4'd1)
	$write("SRX_rec_start");
    if (csi_clockreset_reset_n != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_uart_rx_monitor_state_for_debug &&
	  uart_rx_last_rstate == 4'd2)
	$write("SRX_rec_bit");
    if (csi_clockreset_reset_n != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_uart_rx_monitor_state_for_debug &&
	  uart_rx_last_rstate == 4'd3)
	$write("SRX_rec_parity");
    if (csi_clockreset_reset_n != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_uart_rx_monitor_state_for_debug &&
	  uart_rx_last_rstate == 4'd4)
	$write("SRX_rec_stop");
    if (csi_clockreset_reset_n != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_uart_rx_monitor_state_for_debug &&
	  uart_rx_last_rstate == 4'd5)
	$write("SRX_check_parity");
    if (csi_clockreset_reset_n != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_uart_rx_monitor_state_for_debug &&
	  uart_rx_last_rstate == 4'd6)
	$write("SRX_rec_prepare");
    if (csi_clockreset_reset_n != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_uart_rx_monitor_state_for_debug &&
	  uart_rx_last_rstate == 4'd7)
	$write("SRX_end_bit");
    if (csi_clockreset_reset_n != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_uart_rx_monitor_state_for_debug &&
	  uart_rx_last_rstate == 4'd8)
	$write("SRX_wait1");
    if (csi_clockreset_reset_n != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_uart_rx_monitor_state_for_debug &&
	  uart_rx_last_rstate == 4'd9)
	$write("SRX_ca_lc_parity");
    if (csi_clockreset_reset_n != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_uart_rx_monitor_state_for_debug &&
	  uart_rx_last_rstate != 4'd0 &&
	  uart_rx_last_rstate != 4'd1 &&
	  uart_rx_last_rstate != 4'd2 &&
	  uart_rx_last_rstate != 4'd3 &&
	  uart_rx_last_rstate != 4'd4 &&
	  uart_rx_last_rstate != 4'd5 &&
	  uart_rx_last_rstate != 4'd6 &&
	  uart_rx_last_rstate != 4'd7 &&
	  uart_rx_last_rstate != 4'd8 &&
	  uart_rx_last_rstate != 4'd9)
	$write("SRX_push");
    if (csi_clockreset_reset_n != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_uart_rx_monitor_state_for_debug) $write(" -> ");
  end
  // synopsys translate_on
endmodule  // mkUart16550

