//
// Generated by Bluespec Compiler, version 2018.10.beta1 (build e1df8052c, 2018-10-17)
//
// On Wed Jul  3 23:07:53 IST 2019
//
//
// Ports:
// Name                         I/O  size props
// RDY_axi_slave_m_awvalid        O     1
// axi_slave_awready              O     1
// RDY_axi_slave_m_wvalid         O     1
// axi_slave_wready               O     1
// axi_slave_bvalid               O     1 reg
// axi_slave_bresp                O     2 reg
// axi_slave_buser                O    10 reg
// axi_slave_bid                  O     4 reg
// axi_slave_arready              O     1
// axi_slave_rvalid               O     1 reg
// axi_slave_rresp                O     2 reg
// axi_slave_rdata                O    64 reg
// axi_slave_rlast                O     1 reg
// axi_slave_ruser                O    10 reg
// axi_slave_rid                  O     4 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// axi_slave_m_awvalid_awvalid    I     1
// axi_slave_m_awvalid_awaddr     I    32 reg
// axi_slave_m_awvalid_awprot     I     3 reg
// axi_slave_m_awvalid_awuser     I    10 reg
// axi_slave_m_awvalid_awlen      I     8 reg
// axi_slave_m_awvalid_awsize     I     3 reg
// axi_slave_m_awvalid_awburst    I     2 reg
// axi_slave_m_awvalid_awlock     I     1 reg
// axi_slave_m_awvalid_awcache    I     4 reg
// axi_slave_m_awvalid_awqos      I     4 reg
// axi_slave_m_awvalid_awregion   I     4 reg
// axi_slave_m_awvalid_awid       I     4 reg
// axi_slave_m_wvalid_wvalid      I     1
// axi_slave_m_wvalid_wdata       I    64 reg
// axi_slave_m_wvalid_wstrb       I     8 reg
// axi_slave_m_wvalid_wlast       I     1 reg
// axi_slave_m_wvalid_wid         I     4 reg
// axi_slave_m_bready_bready      I     1
// axi_slave_m_arvalid_arvalid    I     1
// axi_slave_m_arvalid_araddr     I    32 reg
// axi_slave_m_arvalid_arprot     I     3 reg
// axi_slave_m_arvalid_aruser     I    10 reg
// axi_slave_m_arvalid_arlen      I     8 reg
// axi_slave_m_arvalid_arsize     I     3 reg
// axi_slave_m_arvalid_arburst    I     2 reg
// axi_slave_m_arvalid_arlock     I     1 reg
// axi_slave_m_arvalid_arcache    I     4 reg
// axi_slave_m_arvalid_arqos      I     4 reg
// axi_slave_m_arvalid_arregion   I     4 reg
// axi_slave_m_arvalid_arid       I     4 reg
// axi_slave_m_rready_rready      I     1
// EN_axi_slave_m_awvalid         I     1
// EN_axi_slave_m_wvalid          I     1
//
// Combinational paths from inputs to outputs:
//   axi_slave_m_bready_bready -> RDY_axi_slave_m_awvalid
//   axi_slave_m_bready_bready -> axi_slave_awready
//   axi_slave_m_bready_bready -> RDY_axi_slave_m_wvalid
//   axi_slave_m_bready_bready -> axi_slave_wready
//   axi_slave_m_rready_rready -> axi_slave_arready
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkBootRom(CLK,
		 RST_N,

		 axi_slave_m_awvalid_awvalid,
		 axi_slave_m_awvalid_awaddr,
		 axi_slave_m_awvalid_awprot,
		 axi_slave_m_awvalid_awuser,
		 axi_slave_m_awvalid_awlen,
		 axi_slave_m_awvalid_awsize,
		 axi_slave_m_awvalid_awburst,
		 axi_slave_m_awvalid_awlock,
		 axi_slave_m_awvalid_awcache,
		 axi_slave_m_awvalid_awqos,
		 axi_slave_m_awvalid_awregion,
		 axi_slave_m_awvalid_awid,
		 EN_axi_slave_m_awvalid,
		 RDY_axi_slave_m_awvalid,

		 axi_slave_awready,

		 axi_slave_m_wvalid_wvalid,
		 axi_slave_m_wvalid_wdata,
		 axi_slave_m_wvalid_wstrb,
		 axi_slave_m_wvalid_wlast,
		 axi_slave_m_wvalid_wid,
		 EN_axi_slave_m_wvalid,
		 RDY_axi_slave_m_wvalid,

		 axi_slave_wready,

		 axi_slave_bvalid,

		 axi_slave_bresp,

		 axi_slave_buser,

		 axi_slave_bid,

		 axi_slave_m_bready_bready,

		 axi_slave_m_arvalid_arvalid,
		 axi_slave_m_arvalid_araddr,
		 axi_slave_m_arvalid_arprot,
		 axi_slave_m_arvalid_aruser,
		 axi_slave_m_arvalid_arlen,
		 axi_slave_m_arvalid_arsize,
		 axi_slave_m_arvalid_arburst,
		 axi_slave_m_arvalid_arlock,
		 axi_slave_m_arvalid_arcache,
		 axi_slave_m_arvalid_arqos,
		 axi_slave_m_arvalid_arregion,
		 axi_slave_m_arvalid_arid,

		 axi_slave_arready,

		 axi_slave_rvalid,

		 axi_slave_rresp,

		 axi_slave_rdata,

		 axi_slave_rlast,

		 axi_slave_ruser,

		 axi_slave_rid,

		 axi_slave_m_rready_rready);
  input  CLK;
  input  RST_N;

  // action method axi_slave_m_awvalid
  input  axi_slave_m_awvalid_awvalid;
  input  [31 : 0] axi_slave_m_awvalid_awaddr;
  input  [2 : 0] axi_slave_m_awvalid_awprot;
  input  [9 : 0] axi_slave_m_awvalid_awuser;
  input  [7 : 0] axi_slave_m_awvalid_awlen;
  input  [2 : 0] axi_slave_m_awvalid_awsize;
  input  [1 : 0] axi_slave_m_awvalid_awburst;
  input  axi_slave_m_awvalid_awlock;
  input  [3 : 0] axi_slave_m_awvalid_awcache;
  input  [3 : 0] axi_slave_m_awvalid_awqos;
  input  [3 : 0] axi_slave_m_awvalid_awregion;
  input  [3 : 0] axi_slave_m_awvalid_awid;
  input  EN_axi_slave_m_awvalid;
  output RDY_axi_slave_m_awvalid;

  // value method axi_slave_m_awready
  output axi_slave_awready;

  // action method axi_slave_m_wvalid
  input  axi_slave_m_wvalid_wvalid;
  input  [63 : 0] axi_slave_m_wvalid_wdata;
  input  [7 : 0] axi_slave_m_wvalid_wstrb;
  input  axi_slave_m_wvalid_wlast;
  input  [3 : 0] axi_slave_m_wvalid_wid;
  input  EN_axi_slave_m_wvalid;
  output RDY_axi_slave_m_wvalid;

  // value method axi_slave_m_wready
  output axi_slave_wready;

  // value method axi_slave_m_bvalid
  output axi_slave_bvalid;

  // value method axi_slave_m_bresp
  output [1 : 0] axi_slave_bresp;

  // value method axi_slave_m_buser
  output [9 : 0] axi_slave_buser;

  // value method axi_slave_m_bid
  output [3 : 0] axi_slave_bid;

  // action method axi_slave_m_bready
  input  axi_slave_m_bready_bready;

  // action method axi_slave_m_arvalid
  input  axi_slave_m_arvalid_arvalid;
  input  [31 : 0] axi_slave_m_arvalid_araddr;
  input  [2 : 0] axi_slave_m_arvalid_arprot;
  input  [9 : 0] axi_slave_m_arvalid_aruser;
  input  [7 : 0] axi_slave_m_arvalid_arlen;
  input  [2 : 0] axi_slave_m_arvalid_arsize;
  input  [1 : 0] axi_slave_m_arvalid_arburst;
  input  axi_slave_m_arvalid_arlock;
  input  [3 : 0] axi_slave_m_arvalid_arcache;
  input  [3 : 0] axi_slave_m_arvalid_arqos;
  input  [3 : 0] axi_slave_m_arvalid_arregion;
  input  [3 : 0] axi_slave_m_arvalid_arid;

  // value method axi_slave_m_arready
  output axi_slave_arready;

  // value method axi_slave_m_rvalid
  output axi_slave_rvalid;

  // value method axi_slave_m_rresp
  output [1 : 0] axi_slave_rresp;

  // value method axi_slave_m_rdata
  output [63 : 0] axi_slave_rdata;

  // value method axi_slave_m_rlast
  output axi_slave_rlast;

  // value method axi_slave_m_ruser
  output [9 : 0] axi_slave_ruser;

  // value method axi_slave_m_rid
  output [3 : 0] axi_slave_rid;

  // action method axi_slave_m_rready
  input  axi_slave_m_rready_rready;

  // signals for module outputs
  wire [63 : 0] axi_slave_rdata;
  wire [9 : 0] axi_slave_buser, axi_slave_ruser;
  wire [3 : 0] axi_slave_bid, axi_slave_rid;
  wire [1 : 0] axi_slave_bresp, axi_slave_rresp;
  wire RDY_axi_slave_m_awvalid,
       RDY_axi_slave_m_wvalid,
       axi_slave_arready,
       axi_slave_awready,
       axi_slave_bvalid,
       axi_slave_rlast,
       axi_slave_rvalid,
       axi_slave_wready;

  // inlined wires
  wire rg_state$port1__read, rg_state$port2__read;

  // register rg_address
  reg [31 : 0] rg_address;
  wire [31 : 0] rg_address$D_IN;
  wire rg_address$EN;

  // register rg_id
  reg [3 : 0] rg_id;
  wire [3 : 0] rg_id$D_IN;
  wire rg_id$EN;

  // register rg_readburst_counter
  reg [7 : 0] rg_readburst_counter;
  wire [7 : 0] rg_readburst_counter$D_IN;
  wire rg_readburst_counter$EN;

  // register rg_readburst_value
  reg [7 : 0] rg_readburst_value;
  wire [7 : 0] rg_readburst_value$D_IN;
  wire rg_readburst_value$EN;

  // register rg_state
  reg rg_state;
  wire rg_state$D_IN, rg_state$EN;

  // register rg_transfer_size
  reg [2 : 0] rg_transfer_size;
  wire [2 : 0] rg_transfer_size$D_IN;
  wire rg_transfer_size$EN;

  // register rg_writeburst_counter
  reg [7 : 0] rg_writeburst_counter;
  wire [7 : 0] rg_writeburst_counter$D_IN;
  wire rg_writeburst_counter$EN;

  // ports of submodule dmemLSB
  wire [31 : 0] dmemLSB$DI, dmemLSB$DO;
  wire [12 : 0] dmemLSB$ADDR;
  wire dmemLSB$EN, dmemLSB$WE;

  // ports of submodule dmemMSB
  wire [31 : 0] dmemMSB$DI, dmemMSB$DO;
  wire [12 : 0] dmemMSB$ADDR;
  wire dmemMSB$EN, dmemMSB$WE;

  // ports of submodule s_xactor_f_rd_addr
  wire [74 : 0] s_xactor_f_rd_addr$D_IN, s_xactor_f_rd_addr$D_OUT;
  wire s_xactor_f_rd_addr$CLR,
       s_xactor_f_rd_addr$DEQ,
       s_xactor_f_rd_addr$EMPTY_N,
       s_xactor_f_rd_addr$ENQ,
       s_xactor_f_rd_addr$FULL_N;

  // ports of submodule s_xactor_f_rd_data
  wire [80 : 0] s_xactor_f_rd_data$D_IN, s_xactor_f_rd_data$D_OUT;
  wire s_xactor_f_rd_data$CLR,
       s_xactor_f_rd_data$DEQ,
       s_xactor_f_rd_data$EMPTY_N,
       s_xactor_f_rd_data$ENQ,
       s_xactor_f_rd_data$FULL_N;

  // ports of submodule s_xactor_f_wr_addr
  wire [74 : 0] s_xactor_f_wr_addr$D_IN, s_xactor_f_wr_addr$D_OUT;
  wire s_xactor_f_wr_addr$CLR,
       s_xactor_f_wr_addr$DEQ,
       s_xactor_f_wr_addr$EMPTY_N,
       s_xactor_f_wr_addr$ENQ,
       s_xactor_f_wr_addr$FULL_N;

  // ports of submodule s_xactor_f_wr_data
  wire [76 : 0] s_xactor_f_wr_data$D_IN;
  wire s_xactor_f_wr_data$CLR,
       s_xactor_f_wr_data$DEQ,
       s_xactor_f_wr_data$EMPTY_N,
       s_xactor_f_wr_data$ENQ,
       s_xactor_f_wr_data$FULL_N;

  // ports of submodule s_xactor_f_wr_resp
  wire [15 : 0] s_xactor_f_wr_resp$D_IN, s_xactor_f_wr_resp$D_OUT;
  wire s_xactor_f_wr_resp$CLR,
       s_xactor_f_wr_resp$DEQ,
       s_xactor_f_wr_resp$EMPTY_N,
       s_xactor_f_wr_resp$ENQ,
       s_xactor_f_wr_resp$FULL_N;

  // rule scheduling signals
  wire CAN_FIRE_RL_rl_rd_request,
       CAN_FIRE_RL_rl_rd_response,
       CAN_FIRE_RL_rl_wr_respond,
       CAN_FIRE_axi_slave_m_arvalid,
       CAN_FIRE_axi_slave_m_awvalid,
       CAN_FIRE_axi_slave_m_bready,
       CAN_FIRE_axi_slave_m_rready,
       CAN_FIRE_axi_slave_m_wvalid,
       WILL_FIRE_RL_rl_rd_request,
       WILL_FIRE_RL_rl_rd_response,
       WILL_FIRE_RL_rl_wr_respond,
       WILL_FIRE_axi_slave_m_arvalid,
       WILL_FIRE_axi_slave_m_awvalid,
       WILL_FIRE_axi_slave_m_bready,
       WILL_FIRE_axi_slave_m_rready,
       WILL_FIRE_axi_slave_m_wvalid;

  // declarations used by system tasks
  // synopsys translate_off
  reg [63 : 0] v__h1223;
  // synopsys translate_on

  // remaining internal signals
  reg [63 : 0] IF_rg_address_7_BITS_2_TO_0_8_EQ_0_9_THEN_dmem_ETC___d108,
	       IF_rg_address_7_BITS_2_TO_0_8_EQ_0_9_THEN_dmem_ETC___d55,
	       _theResult___rdata__h1926;
  wire [63 : 0] data0__h1567;
  wire [31 : 0] s_xactor_f_rd_addrD_OUT_BITS_74_TO_43_MINUS_0_ETC__q1;
  wire [7 : 0] x__h13117;
  wire rg_readburst_counter_12_EQ_rg_readburst_value_13___d114;

  // action method axi_slave_m_awvalid
  assign RDY_axi_slave_m_awvalid = s_xactor_f_wr_addr$FULL_N ;
  assign CAN_FIRE_axi_slave_m_awvalid = s_xactor_f_wr_addr$FULL_N ;
  assign WILL_FIRE_axi_slave_m_awvalid = EN_axi_slave_m_awvalid ;

  // value method axi_slave_m_awready
  assign axi_slave_awready = s_xactor_f_wr_addr$FULL_N ;

  // action method axi_slave_m_wvalid
  assign RDY_axi_slave_m_wvalid = s_xactor_f_wr_data$FULL_N ;
  assign CAN_FIRE_axi_slave_m_wvalid = s_xactor_f_wr_data$FULL_N ;
  assign WILL_FIRE_axi_slave_m_wvalid = EN_axi_slave_m_wvalid ;

  // value method axi_slave_m_wready
  assign axi_slave_wready = s_xactor_f_wr_data$FULL_N ;

  // value method axi_slave_m_bvalid
  assign axi_slave_bvalid = s_xactor_f_wr_resp$EMPTY_N ;

  // value method axi_slave_m_bresp
  assign axi_slave_bresp = s_xactor_f_wr_resp$D_OUT[15:14] ;

  // value method axi_slave_m_buser
  assign axi_slave_buser = s_xactor_f_wr_resp$D_OUT[13:4] ;

  // value method axi_slave_m_bid
  assign axi_slave_bid = s_xactor_f_wr_resp$D_OUT[3:0] ;

  // action method axi_slave_m_bready
  assign CAN_FIRE_axi_slave_m_bready = 1'd1 ;
  assign WILL_FIRE_axi_slave_m_bready = 1'd1 ;

  // action method axi_slave_m_arvalid
  assign CAN_FIRE_axi_slave_m_arvalid = 1'd1 ;
  assign WILL_FIRE_axi_slave_m_arvalid = 1'd1 ;

  // value method axi_slave_m_arready
  assign axi_slave_arready = s_xactor_f_rd_addr$FULL_N ;

  // value method axi_slave_m_rvalid
  assign axi_slave_rvalid = s_xactor_f_rd_data$EMPTY_N ;

  // value method axi_slave_m_rresp
  assign axi_slave_rresp = s_xactor_f_rd_data$D_OUT[80:79] ;

  // value method axi_slave_m_rdata
  assign axi_slave_rdata = s_xactor_f_rd_data$D_OUT[78:15] ;

  // value method axi_slave_m_rlast
  assign axi_slave_rlast = s_xactor_f_rd_data$D_OUT[14] ;

  // value method axi_slave_m_ruser
  assign axi_slave_ruser = s_xactor_f_rd_data$D_OUT[13:4] ;

  // value method axi_slave_m_rid
  assign axi_slave_rid = s_xactor_f_rd_data$D_OUT[3:0] ;

  // action method axi_slave_m_rready
  assign CAN_FIRE_axi_slave_m_rready = 1'd1 ;
  assign WILL_FIRE_axi_slave_m_rready = 1'd1 ;

  // submodule dmemLSB
  BRAM1Load #(.FILENAME("/home/surya/Desktop/sem_5/Diff-power-analysis/vighnesh/cclass/c-class/base-sim/bin/boot.LSB"),
	      .PIPELINED(1'd0),
	      .ADDR_WIDTH(32'd13),
	      .DATA_WIDTH(32'd32),
	      .MEMSIZE(14'd8192),
	      .BINARY(1'd0)) dmemLSB(.CLK(CLK),
				     .ADDR(dmemLSB$ADDR),
				     .DI(dmemLSB$DI),
				     .WE(dmemLSB$WE),
				     .EN(dmemLSB$EN),
				     .DO(dmemLSB$DO));

  // submodule dmemMSB 
  BRAM1Load #(.FILENAME("/home/surya/Desktop/sem_5/Diff-power-analysis/vighnesh/cclass/c-class/base-sim/bin/boot.MSB"),
	      .PIPELINED(1'd0),
	      .ADDR_WIDTH(32'd13),
	      .DATA_WIDTH(32'd32),
	      .MEMSIZE(14'd8192),
	      .BINARY(1'd0)) dmemMSB(.CLK(CLK),
				     .ADDR(dmemMSB$ADDR),
				     .DI(dmemMSB$DI),
				     .WE(dmemMSB$WE),
				     .EN(dmemMSB$EN),
				     .DO(dmemMSB$DO));

  // submodule s_xactor_f_rd_addr
  FIFOL1 #(.width(32'd75)) s_xactor_f_rd_addr(.RST(RST_N),
					      .CLK(CLK),
					      .D_IN(s_xactor_f_rd_addr$D_IN),
					      .ENQ(s_xactor_f_rd_addr$ENQ),
					      .DEQ(s_xactor_f_rd_addr$DEQ),
					      .CLR(s_xactor_f_rd_addr$CLR),
					      .D_OUT(s_xactor_f_rd_addr$D_OUT),
					      .FULL_N(s_xactor_f_rd_addr$FULL_N),
					      .EMPTY_N(s_xactor_f_rd_addr$EMPTY_N));

  // submodule s_xactor_f_rd_data
  FIFOL1 #(.width(32'd81)) s_xactor_f_rd_data(.RST(RST_N),
					      .CLK(CLK),
					      .D_IN(s_xactor_f_rd_data$D_IN),
					      .ENQ(s_xactor_f_rd_data$ENQ),
					      .DEQ(s_xactor_f_rd_data$DEQ),
					      .CLR(s_xactor_f_rd_data$CLR),
					      .D_OUT(s_xactor_f_rd_data$D_OUT),
					      .FULL_N(s_xactor_f_rd_data$FULL_N),
					      .EMPTY_N(s_xactor_f_rd_data$EMPTY_N));

  // submodule s_xactor_f_wr_addr
  FIFOL1 #(.width(32'd75)) s_xactor_f_wr_addr(.RST(RST_N),
					      .CLK(CLK),
					      .D_IN(s_xactor_f_wr_addr$D_IN),
					      .ENQ(s_xactor_f_wr_addr$ENQ),
					      .DEQ(s_xactor_f_wr_addr$DEQ),
					      .CLR(s_xactor_f_wr_addr$CLR),
					      .D_OUT(s_xactor_f_wr_addr$D_OUT),
					      .FULL_N(s_xactor_f_wr_addr$FULL_N),
					      .EMPTY_N(s_xactor_f_wr_addr$EMPTY_N));

  // submodule s_xactor_f_wr_data
  FIFOL1 #(.width(32'd77)) s_xactor_f_wr_data(.RST(RST_N),
					      .CLK(CLK),
					      .D_IN(s_xactor_f_wr_data$D_IN),
					      .ENQ(s_xactor_f_wr_data$ENQ),
					      .DEQ(s_xactor_f_wr_data$DEQ),
					      .CLR(s_xactor_f_wr_data$CLR),
					      .D_OUT(),
					      .FULL_N(s_xactor_f_wr_data$FULL_N),
					      .EMPTY_N(s_xactor_f_wr_data$EMPTY_N));

  // submodule s_xactor_f_wr_resp
  FIFOL1 #(.width(32'd16)) s_xactor_f_wr_resp(.RST(RST_N),
					      .CLK(CLK),
					      .D_IN(s_xactor_f_wr_resp$D_IN),
					      .ENQ(s_xactor_f_wr_resp$ENQ),
					      .DEQ(s_xactor_f_wr_resp$DEQ),
					      .CLR(s_xactor_f_wr_resp$CLR),
					      .D_OUT(s_xactor_f_wr_resp$D_OUT),
					      .FULL_N(s_xactor_f_wr_resp$FULL_N),
					      .EMPTY_N(s_xactor_f_wr_resp$EMPTY_N));

  // rule RL_rl_wr_respond
  assign CAN_FIRE_RL_rl_wr_respond =
	     s_xactor_f_wr_addr$EMPTY_N && s_xactor_f_wr_data$EMPTY_N &&
	     s_xactor_f_wr_resp$FULL_N ;
  assign WILL_FIRE_RL_rl_wr_respond = CAN_FIRE_RL_rl_wr_respond ;

  // rule RL_rl_rd_response
  assign CAN_FIRE_RL_rl_rd_response = s_xactor_f_rd_data$FULL_N && rg_state ;
  assign WILL_FIRE_RL_rl_rd_response = CAN_FIRE_RL_rl_rd_response ;

  // rule RL_rl_rd_request
  assign CAN_FIRE_RL_rl_rd_request =
	     s_xactor_f_rd_addr$EMPTY_N && !rg_state$port1__read ;
  assign WILL_FIRE_RL_rl_rd_request = CAN_FIRE_RL_rl_rd_request ;

  // inlined wires
  assign rg_state$port1__read = !CAN_FIRE_RL_rl_rd_response && rg_state ;
  assign rg_state$port2__read =
	     CAN_FIRE_RL_rl_rd_request || rg_state$port1__read ;

  // register rg_address
  assign rg_address$D_IN = s_xactor_f_rd_addr$D_OUT[74:43] ;
  assign rg_address$EN = CAN_FIRE_RL_rl_rd_request ;

  // register rg_id
  assign rg_id$D_IN = s_xactor_f_rd_addr$D_OUT[3:0] ;
  assign rg_id$EN = CAN_FIRE_RL_rl_rd_request ;

  // register rg_readburst_counter
  assign rg_readburst_counter$D_IN =
	     rg_readburst_counter_12_EQ_rg_readburst_value_13___d114 ?
	       8'd0 :
	       x__h13117 ;
  assign rg_readburst_counter$EN = CAN_FIRE_RL_rl_rd_response ;

  // register rg_readburst_value
  assign rg_readburst_value$D_IN = s_xactor_f_rd_addr$D_OUT[29:22] ;
  assign rg_readburst_value$EN = CAN_FIRE_RL_rl_rd_request ;

  // register rg_state
  assign rg_state$D_IN = rg_state$port2__read ;
  assign rg_state$EN = 1'b1 ;

  // register rg_transfer_size
  assign rg_transfer_size$D_IN = s_xactor_f_rd_addr$D_OUT[21:19] ;
  assign rg_transfer_size$EN = CAN_FIRE_RL_rl_rd_request ;

  // register rg_writeburst_counter
  assign rg_writeburst_counter$D_IN = 8'h0 ;
  assign rg_writeburst_counter$EN = 1'b0 ;

  // submodule dmemLSB
  assign dmemLSB$ADDR =
	     s_xactor_f_rd_addrD_OUT_BITS_74_TO_43_MINUS_0_ETC__q1[15:3] ;
  assign dmemLSB$DI = 32'hAAAAAAAA /* unspecified value */  ;
  assign dmemLSB$WE = 1'd0 ;
  assign dmemLSB$EN = CAN_FIRE_RL_rl_rd_request ;

  // submodule dmemMSB
  assign dmemMSB$ADDR =
	     s_xactor_f_rd_addrD_OUT_BITS_74_TO_43_MINUS_0_ETC__q1[15:3] ;
  assign dmemMSB$DI = 32'hAAAAAAAA /* unspecified value */  ;
  assign dmemMSB$WE = 1'd0 ;
  assign dmemMSB$EN = CAN_FIRE_RL_rl_rd_request ;

  // submodule s_xactor_f_rd_addr
  assign s_xactor_f_rd_addr$D_IN =
	     { axi_slave_m_arvalid_araddr,
	       axi_slave_m_arvalid_arprot,
	       axi_slave_m_arvalid_aruser,
	       axi_slave_m_arvalid_arlen,
	       axi_slave_m_arvalid_arsize,
	       axi_slave_m_arvalid_arburst,
	       axi_slave_m_arvalid_arlock,
	       axi_slave_m_arvalid_arcache,
	       axi_slave_m_arvalid_arqos,
	       axi_slave_m_arvalid_arregion,
	       axi_slave_m_arvalid_arid } ;
  assign s_xactor_f_rd_addr$ENQ =
	     axi_slave_m_arvalid_arvalid && s_xactor_f_rd_addr$FULL_N ;
  assign s_xactor_f_rd_addr$DEQ =
	     s_xactor_f_rd_addr$EMPTY_N && !rg_state$port1__read ;
  assign s_xactor_f_rd_addr$CLR = 1'b0 ;

  // submodule s_xactor_f_rd_data
  assign s_xactor_f_rd_data$D_IN =
	     { 2'd0,
	       _theResult___rdata__h1926,
	       rg_readburst_counter_12_EQ_rg_readburst_value_13___d114,
	       10'd0,
	       rg_id } ;
  assign s_xactor_f_rd_data$ENQ = s_xactor_f_rd_data$FULL_N && rg_state ;
  assign s_xactor_f_rd_data$DEQ =
	     axi_slave_m_rready_rready && s_xactor_f_rd_data$EMPTY_N ;
  assign s_xactor_f_rd_data$CLR = 1'b0 ;

  // submodule s_xactor_f_wr_addr
  assign s_xactor_f_wr_addr$D_IN =
	     { axi_slave_m_awvalid_awaddr,
	       axi_slave_m_awvalid_awprot,
	       axi_slave_m_awvalid_awuser,
	       axi_slave_m_awvalid_awlen,
	       axi_slave_m_awvalid_awsize,
	       axi_slave_m_awvalid_awburst,
	       axi_slave_m_awvalid_awlock,
	       axi_slave_m_awvalid_awcache,
	       axi_slave_m_awvalid_awqos,
	       axi_slave_m_awvalid_awregion,
	       axi_slave_m_awvalid_awid } ;
  assign s_xactor_f_wr_addr$ENQ =
	     EN_axi_slave_m_awvalid && axi_slave_m_awvalid_awvalid ;
  assign s_xactor_f_wr_addr$DEQ =
	     s_xactor_f_wr_addr$EMPTY_N && s_xactor_f_wr_data$EMPTY_N &&
	     s_xactor_f_wr_resp$FULL_N ;
  assign s_xactor_f_wr_addr$CLR = 1'b0 ;

  // submodule s_xactor_f_wr_data
  assign s_xactor_f_wr_data$D_IN =
	     { axi_slave_m_wvalid_wdata,
	       axi_slave_m_wvalid_wstrb,
	       axi_slave_m_wvalid_wid,
	       axi_slave_m_wvalid_wlast } ;
  assign s_xactor_f_wr_data$ENQ =
	     EN_axi_slave_m_wvalid && axi_slave_m_wvalid_wvalid ;
  assign s_xactor_f_wr_data$DEQ =
	     s_xactor_f_wr_addr$EMPTY_N && s_xactor_f_wr_data$EMPTY_N &&
	     s_xactor_f_wr_resp$FULL_N ;
  assign s_xactor_f_wr_data$CLR = 1'b0 ;

  // submodule s_xactor_f_wr_resp
  assign s_xactor_f_wr_resp$D_IN =
	     { 2'd2,
	       s_xactor_f_wr_addr$D_OUT[39:30],
	       s_xactor_f_wr_addr$D_OUT[3:0] } ;
  assign s_xactor_f_wr_resp$ENQ =
	     s_xactor_f_wr_addr$EMPTY_N && s_xactor_f_wr_data$EMPTY_N &&
	     s_xactor_f_wr_resp$FULL_N ;
  assign s_xactor_f_wr_resp$DEQ =
	     axi_slave_m_bready_bready && s_xactor_f_wr_resp$EMPTY_N ;
  assign s_xactor_f_wr_resp$CLR = 1'b0 ;

  // remaining internal signals
  assign data0__h1567 = { dmemMSB$DO, dmemLSB$DO } ;
  assign rg_readburst_counter_12_EQ_rg_readburst_value_13___d114 =
	     rg_readburst_counter == rg_readburst_value ;
  assign s_xactor_f_rd_addrD_OUT_BITS_74_TO_43_MINUS_0_ETC__q1 =
	     s_xactor_f_rd_addr$D_OUT[74:43] - 32'h00001000 ;
  assign x__h13117 = rg_readburst_counter + 8'd1 ;
  always@(rg_address or data0__h1567 or dmemLSB$DO or dmemMSB$DO)
  begin
    case (rg_address[2:0])
      3'd0:
	  IF_rg_address_7_BITS_2_TO_0_8_EQ_0_9_THEN_dmem_ETC___d55 =
	      {4{dmemLSB$DO[15:0]}};
      3'd2:
	  IF_rg_address_7_BITS_2_TO_0_8_EQ_0_9_THEN_dmem_ETC___d55 =
	      {4{dmemLSB$DO[31:16]}};
      3'd4:
	  IF_rg_address_7_BITS_2_TO_0_8_EQ_0_9_THEN_dmem_ETC___d55 =
	      {4{dmemMSB$DO[15:0]}};
      3'd6:
	  IF_rg_address_7_BITS_2_TO_0_8_EQ_0_9_THEN_dmem_ETC___d55 =
	      {4{dmemMSB$DO[31:16]}};
      default: IF_rg_address_7_BITS_2_TO_0_8_EQ_0_9_THEN_dmem_ETC___d55 =
		   data0__h1567;
    endcase
  end
  always@(rg_address or data0__h1567 or dmemLSB$DO or dmemMSB$DO)
  begin
    case (rg_address[2:0])
      3'd0:
	  IF_rg_address_7_BITS_2_TO_0_8_EQ_0_9_THEN_dmem_ETC___d108 =
	      {8{dmemLSB$DO[7:0]}};
      3'd1:
	  IF_rg_address_7_BITS_2_TO_0_8_EQ_0_9_THEN_dmem_ETC___d108 =
	      {8{dmemLSB$DO[15:8]}};
      3'd2:
	  IF_rg_address_7_BITS_2_TO_0_8_EQ_0_9_THEN_dmem_ETC___d108 =
	      {8{dmemLSB$DO[23:16]}};
      3'd3:
	  IF_rg_address_7_BITS_2_TO_0_8_EQ_0_9_THEN_dmem_ETC___d108 =
	      {8{dmemLSB$DO[31:24]}};
      3'd4:
	  IF_rg_address_7_BITS_2_TO_0_8_EQ_0_9_THEN_dmem_ETC___d108 =
	      {8{dmemMSB$DO[7:0]}};
      3'd5:
	  IF_rg_address_7_BITS_2_TO_0_8_EQ_0_9_THEN_dmem_ETC___d108 =
	      {8{dmemMSB$DO[15:8]}};
      3'd6:
	  IF_rg_address_7_BITS_2_TO_0_8_EQ_0_9_THEN_dmem_ETC___d108 =
	      {8{dmemMSB$DO[23:16]}};
      3'd7:
	  IF_rg_address_7_BITS_2_TO_0_8_EQ_0_9_THEN_dmem_ETC___d108 =
	      {8{dmemMSB$DO[31:24]}};
    endcase
  end
  always@(rg_transfer_size or
	  data0__h1567 or
	  IF_rg_address_7_BITS_2_TO_0_8_EQ_0_9_THEN_dmem_ETC___d108 or
	  IF_rg_address_7_BITS_2_TO_0_8_EQ_0_9_THEN_dmem_ETC___d55 or
	  rg_address or dmemLSB$DO or dmemMSB$DO)
  begin
    case (rg_transfer_size)
      3'd0:
	  _theResult___rdata__h1926 =
	      IF_rg_address_7_BITS_2_TO_0_8_EQ_0_9_THEN_dmem_ETC___d108;
      3'd1:
	  _theResult___rdata__h1926 =
	      IF_rg_address_7_BITS_2_TO_0_8_EQ_0_9_THEN_dmem_ETC___d55;
      3'd2:
	  _theResult___rdata__h1926 =
	      (rg_address[2:0] == 3'd0) ? {2{dmemLSB$DO}} : {2{dmemMSB$DO}};
      default: _theResult___rdata__h1926 = data0__h1567;
    endcase
  end

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        rg_address <= `BSV_ASSIGNMENT_DELAY 32'd0;
	rg_id <= `BSV_ASSIGNMENT_DELAY 4'd0;
	rg_readburst_counter <= `BSV_ASSIGNMENT_DELAY 8'd0;
	rg_readburst_value <= `BSV_ASSIGNMENT_DELAY 8'd0;
	rg_state <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rg_transfer_size <= `BSV_ASSIGNMENT_DELAY 3'd0;
	rg_writeburst_counter <= `BSV_ASSIGNMENT_DELAY 8'd0;
      end
    else
      begin
        if (rg_address$EN)
	  rg_address <= `BSV_ASSIGNMENT_DELAY rg_address$D_IN;
	if (rg_id$EN) rg_id <= `BSV_ASSIGNMENT_DELAY rg_id$D_IN;
	if (rg_readburst_counter$EN)
	  rg_readburst_counter <= `BSV_ASSIGNMENT_DELAY
	      rg_readburst_counter$D_IN;
	if (rg_readburst_value$EN)
	  rg_readburst_value <= `BSV_ASSIGNMENT_DELAY rg_readburst_value$D_IN;
	if (rg_state$EN) rg_state <= `BSV_ASSIGNMENT_DELAY rg_state$D_IN;
	if (rg_transfer_size$EN)
	  rg_transfer_size <= `BSV_ASSIGNMENT_DELAY rg_transfer_size$D_IN;
	if (rg_writeburst_counter$EN)
	  rg_writeburst_counter <= `BSV_ASSIGNMENT_DELAY
	      rg_writeburst_counter$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    rg_address = 32'hAAAAAAAA;
    rg_id = 4'hA;
    rg_readburst_counter = 8'hAA;
    rg_readburst_value = 8'hAA;
    rg_state = 1'h0;
    rg_transfer_size = 3'h2;
    rg_writeburst_counter = 8'hAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_wr_respond)
	begin
	  v__h1223 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_wr_respond)
	$display(v__h1223, "\tBootROM: Illegal Write operation on BootROM");
  end
  // synopsys translate_on
endmodule  // mkBootRom

