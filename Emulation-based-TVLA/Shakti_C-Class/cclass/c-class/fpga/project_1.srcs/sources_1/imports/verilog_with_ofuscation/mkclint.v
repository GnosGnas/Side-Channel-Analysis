//
// Generated by Bluespec Compiler, version 2018.10.beta1 (build e1df8052c, 2018-10-17)
//
// On Wed Jul  3 23:07:39 IST 2019
//
//
// Ports:
// Name                         I/O  size props
// msip_int                       O     1 reg
// RDY_msip_int                   O     1 const
// mtip_int                       O     1 reg
// RDY_mtip_int                   O     1 const
// mtime                          O    64 reg
// RDY_mtime                      O     1 const
// mtimecmp                       O    64 reg
// RDY_mtimecmp                   O     1 const
// RDY_axi4_slave_m_awvalid       O     1
// axi4_slave_awready             O     1
// RDY_axi4_slave_m_wvalid        O     1
// axi4_slave_wready              O     1
// axi4_slave_bvalid              O     1 reg
// axi4_slave_bresp               O     2 reg
// axi4_slave_buser               O    10 reg
// axi4_slave_bid                 O     4 reg
// axi4_slave_arready             O     1
// axi4_slave_rvalid              O     1 reg
// axi4_slave_rresp               O     2 reg
// axi4_slave_rdata               O    64 reg
// axi4_slave_rlast               O     1 reg
// axi4_slave_ruser               O    10 reg
// axi4_slave_rid                 O     4 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// axi4_slave_m_awvalid_awvalid   I     1
// axi4_slave_m_awvalid_awaddr    I    32 reg
// axi4_slave_m_awvalid_awprot    I     3 reg
// axi4_slave_m_awvalid_awuser    I    10 reg
// axi4_slave_m_awvalid_awlen     I     8 reg
// axi4_slave_m_awvalid_awsize    I     3 reg
// axi4_slave_m_awvalid_awburst   I     2 reg
// axi4_slave_m_awvalid_awlock    I     1 reg
// axi4_slave_m_awvalid_awcache   I     4 reg
// axi4_slave_m_awvalid_awqos     I     4 reg
// axi4_slave_m_awvalid_awregion  I     4 reg
// axi4_slave_m_awvalid_awid      I     4 reg
// axi4_slave_m_wvalid_wvalid     I     1
// axi4_slave_m_wvalid_wdata      I    64 reg
// axi4_slave_m_wvalid_wstrb      I     8 reg
// axi4_slave_m_wvalid_wlast      I     1 reg
// axi4_slave_m_wvalid_wid        I     4 reg
// axi4_slave_m_bready_bready     I     1
// axi4_slave_m_arvalid_arvalid   I     1
// axi4_slave_m_arvalid_araddr    I    32 reg
// axi4_slave_m_arvalid_arprot    I     3 reg
// axi4_slave_m_arvalid_aruser    I    10 reg
// axi4_slave_m_arvalid_arlen     I     8 reg
// axi4_slave_m_arvalid_arsize    I     3 reg
// axi4_slave_m_arvalid_arburst   I     2 reg
// axi4_slave_m_arvalid_arlock    I     1 reg
// axi4_slave_m_arvalid_arcache   I     4 reg
// axi4_slave_m_arvalid_arqos     I     4 reg
// axi4_slave_m_arvalid_arregion  I     4 reg
// axi4_slave_m_arvalid_arid      I     4 reg
// axi4_slave_m_rready_rready     I     1
// EN_axi4_slave_m_awvalid        I     1
// EN_axi4_slave_m_wvalid         I     1
//
// Combinational paths from inputs to outputs:
//   axi4_slave_m_bready_bready -> RDY_axi4_slave_m_awvalid
//   axi4_slave_m_bready_bready -> axi4_slave_awready
//   axi4_slave_m_bready_bready -> RDY_axi4_slave_m_wvalid
//   axi4_slave_m_bready_bready -> axi4_slave_wready
//   axi4_slave_m_rready_rready -> axi4_slave_arready
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkclint(CLK,
	       RST_N,

	       msip_int,
	       RDY_msip_int,

	       mtip_int,
	       RDY_mtip_int,

	       mtime,
	       RDY_mtime,

	       mtimecmp,
	       RDY_mtimecmp,

	       axi4_slave_m_awvalid_awvalid,
	       axi4_slave_m_awvalid_awaddr,
	       axi4_slave_m_awvalid_awprot,
	       axi4_slave_m_awvalid_awuser,
	       axi4_slave_m_awvalid_awlen,
	       axi4_slave_m_awvalid_awsize,
	       axi4_slave_m_awvalid_awburst,
	       axi4_slave_m_awvalid_awlock,
	       axi4_slave_m_awvalid_awcache,
	       axi4_slave_m_awvalid_awqos,
	       axi4_slave_m_awvalid_awregion,
	       axi4_slave_m_awvalid_awid,
	       EN_axi4_slave_m_awvalid,
	       RDY_axi4_slave_m_awvalid,

	       axi4_slave_awready,

	       axi4_slave_m_wvalid_wvalid,
	       axi4_slave_m_wvalid_wdata,
	       axi4_slave_m_wvalid_wstrb,
	       axi4_slave_m_wvalid_wlast,
	       axi4_slave_m_wvalid_wid,
	       EN_axi4_slave_m_wvalid,
	       RDY_axi4_slave_m_wvalid,

	       axi4_slave_wready,

	       axi4_slave_bvalid,

	       axi4_slave_bresp,

	       axi4_slave_buser,

	       axi4_slave_bid,

	       axi4_slave_m_bready_bready,

	       axi4_slave_m_arvalid_arvalid,
	       axi4_slave_m_arvalid_araddr,
	       axi4_slave_m_arvalid_arprot,
	       axi4_slave_m_arvalid_aruser,
	       axi4_slave_m_arvalid_arlen,
	       axi4_slave_m_arvalid_arsize,
	       axi4_slave_m_arvalid_arburst,
	       axi4_slave_m_arvalid_arlock,
	       axi4_slave_m_arvalid_arcache,
	       axi4_slave_m_arvalid_arqos,
	       axi4_slave_m_arvalid_arregion,
	       axi4_slave_m_arvalid_arid,

	       axi4_slave_arready,

	       axi4_slave_rvalid,

	       axi4_slave_rresp,

	       axi4_slave_rdata,

	       axi4_slave_rlast,

	       axi4_slave_ruser,

	       axi4_slave_rid,

	       axi4_slave_m_rready_rready);
  input  CLK;
  input  RST_N;

  // value method msip_int
  output msip_int;
  output RDY_msip_int;

  // value method mtip_int
  output mtip_int;
  output RDY_mtip_int;

  // value method mtime
  output [63 : 0] mtime;
  output RDY_mtime;

  // value method mtimecmp
  output [63 : 0] mtimecmp;
  output RDY_mtimecmp;

  // action method axi4_slave_m_awvalid
  input  axi4_slave_m_awvalid_awvalid;
  input  [31 : 0] axi4_slave_m_awvalid_awaddr;
  input  [2 : 0] axi4_slave_m_awvalid_awprot;
  input  [9 : 0] axi4_slave_m_awvalid_awuser;
  input  [7 : 0] axi4_slave_m_awvalid_awlen;
  input  [2 : 0] axi4_slave_m_awvalid_awsize;
  input  [1 : 0] axi4_slave_m_awvalid_awburst;
  input  axi4_slave_m_awvalid_awlock;
  input  [3 : 0] axi4_slave_m_awvalid_awcache;
  input  [3 : 0] axi4_slave_m_awvalid_awqos;
  input  [3 : 0] axi4_slave_m_awvalid_awregion;
  input  [3 : 0] axi4_slave_m_awvalid_awid;
  input  EN_axi4_slave_m_awvalid;
  output RDY_axi4_slave_m_awvalid;

  // value method axi4_slave_m_awready
  output axi4_slave_awready;

  // action method axi4_slave_m_wvalid
  input  axi4_slave_m_wvalid_wvalid;
  input  [63 : 0] axi4_slave_m_wvalid_wdata;
  input  [7 : 0] axi4_slave_m_wvalid_wstrb;
  input  axi4_slave_m_wvalid_wlast;
  input  [3 : 0] axi4_slave_m_wvalid_wid;
  input  EN_axi4_slave_m_wvalid;
  output RDY_axi4_slave_m_wvalid;

  // value method axi4_slave_m_wready
  output axi4_slave_wready;

  // value method axi4_slave_m_bvalid
  output axi4_slave_bvalid;

  // value method axi4_slave_m_bresp
  output [1 : 0] axi4_slave_bresp;

  // value method axi4_slave_m_buser
  output [9 : 0] axi4_slave_buser;

  // value method axi4_slave_m_bid
  output [3 : 0] axi4_slave_bid;

  // action method axi4_slave_m_bready
  input  axi4_slave_m_bready_bready;

  // action method axi4_slave_m_arvalid
  input  axi4_slave_m_arvalid_arvalid;
  input  [31 : 0] axi4_slave_m_arvalid_araddr;
  input  [2 : 0] axi4_slave_m_arvalid_arprot;
  input  [9 : 0] axi4_slave_m_arvalid_aruser;
  input  [7 : 0] axi4_slave_m_arvalid_arlen;
  input  [2 : 0] axi4_slave_m_arvalid_arsize;
  input  [1 : 0] axi4_slave_m_arvalid_arburst;
  input  axi4_slave_m_arvalid_arlock;
  input  [3 : 0] axi4_slave_m_arvalid_arcache;
  input  [3 : 0] axi4_slave_m_arvalid_arqos;
  input  [3 : 0] axi4_slave_m_arvalid_arregion;
  input  [3 : 0] axi4_slave_m_arvalid_arid;

  // value method axi4_slave_m_arready
  output axi4_slave_arready;

  // value method axi4_slave_m_rvalid
  output axi4_slave_rvalid;

  // value method axi4_slave_m_rresp
  output [1 : 0] axi4_slave_rresp;

  // value method axi4_slave_m_rdata
  output [63 : 0] axi4_slave_rdata;

  // value method axi4_slave_m_rlast
  output axi4_slave_rlast;

  // value method axi4_slave_m_ruser
  output [9 : 0] axi4_slave_ruser;

  // value method axi4_slave_m_rid
  output [3 : 0] axi4_slave_rid;

  // action method axi4_slave_m_rready
  input  axi4_slave_m_rready_rready;

  // signals for module outputs
  wire [63 : 0] axi4_slave_rdata, mtime, mtimecmp;
  wire [9 : 0] axi4_slave_buser, axi4_slave_ruser;
  wire [3 : 0] axi4_slave_bid, axi4_slave_rid;
  wire [1 : 0] axi4_slave_bresp, axi4_slave_rresp;
  wire RDY_axi4_slave_m_awvalid,
       RDY_axi4_slave_m_wvalid,
       RDY_msip_int,
       RDY_mtime,
       RDY_mtimecmp,
       RDY_mtip_int,
       axi4_slave_arready,
       axi4_slave_awready,
       axi4_slave_bvalid,
       axi4_slave_rlast,
       axi4_slave_rvalid,
       axi4_slave_wready,
       msip_int,
       mtip_int;

  // inlined wires
  wire wr_mtimecmp_written$whas;

  // register msip
  reg msip;
  wire msip$D_IN, msip$EN;

  // register mtip
  reg mtip;
  wire mtip$D_IN, mtip$EN;

  // register rg_tick
  reg [1 : 0] rg_tick;
  wire [1 : 0] rg_tick$D_IN;
  wire rg_tick$EN;

  // register rgmtime
  reg [63 : 0] rgmtime;
  wire [63 : 0] rgmtime$D_IN;
  wire rgmtime$EN;

  // register rgmtimecmp
  reg [63 : 0] rgmtimecmp;
  wire [63 : 0] rgmtimecmp$D_IN;
  wire rgmtimecmp$EN;

  // ports of submodule s_xactor_f_rd_addr
  wire [74 : 0] s_xactor_f_rd_addr$D_IN, s_xactor_f_rd_addr$D_OUT;
  wire s_xactor_f_rd_addr$CLR,
       s_xactor_f_rd_addr$DEQ,
       s_xactor_f_rd_addr$EMPTY_N,
       s_xactor_f_rd_addr$ENQ,
       s_xactor_f_rd_addr$FULL_N;

  // ports of submodule s_xactor_f_rd_data
  wire [80 : 0] s_xactor_f_rd_data$D_IN, s_xactor_f_rd_data$D_OUT;
  wire s_xactor_f_rd_data$CLR,
       s_xactor_f_rd_data$DEQ,
       s_xactor_f_rd_data$EMPTY_N,
       s_xactor_f_rd_data$ENQ,
       s_xactor_f_rd_data$FULL_N;

  // ports of submodule s_xactor_f_wr_addr
  wire [74 : 0] s_xactor_f_wr_addr$D_IN, s_xactor_f_wr_addr$D_OUT;
  wire s_xactor_f_wr_addr$CLR,
       s_xactor_f_wr_addr$DEQ,
       s_xactor_f_wr_addr$EMPTY_N,
       s_xactor_f_wr_addr$ENQ,
       s_xactor_f_wr_addr$FULL_N;

  // ports of submodule s_xactor_f_wr_data
  wire [76 : 0] s_xactor_f_wr_data$D_IN, s_xactor_f_wr_data$D_OUT;
  wire s_xactor_f_wr_data$CLR,
       s_xactor_f_wr_data$DEQ,
       s_xactor_f_wr_data$EMPTY_N,
       s_xactor_f_wr_data$ENQ,
       s_xactor_f_wr_data$FULL_N;

  // ports of submodule s_xactor_f_wr_resp
  wire [15 : 0] s_xactor_f_wr_resp$D_IN, s_xactor_f_wr_resp$D_OUT;
  wire s_xactor_f_wr_resp$CLR,
       s_xactor_f_wr_resp$DEQ,
       s_xactor_f_wr_resp$EMPTY_N,
       s_xactor_f_wr_resp$ENQ,
       s_xactor_f_wr_resp$FULL_N;

  // rule scheduling signals
  wire CAN_FIRE_RL_axi_read_transaction,
       CAN_FIRE_RL_axi_write_transaction,
       CAN_FIRE_RL_clear_interrupt,
       CAN_FIRE_RL_generate_time_interrupt,
       CAN_FIRE_RL_increment_timer,
       CAN_FIRE_axi4_slave_m_arvalid,
       CAN_FIRE_axi4_slave_m_awvalid,
       CAN_FIRE_axi4_slave_m_bready,
       CAN_FIRE_axi4_slave_m_rready,
       CAN_FIRE_axi4_slave_m_wvalid,
       WILL_FIRE_RL_axi_read_transaction,
       WILL_FIRE_RL_axi_write_transaction,
       WILL_FIRE_RL_clear_interrupt,
       WILL_FIRE_RL_generate_time_interrupt,
       WILL_FIRE_RL_increment_timer,
       WILL_FIRE_axi4_slave_m_arvalid,
       WILL_FIRE_axi4_slave_m_awvalid,
       WILL_FIRE_axi4_slave_m_bready,
       WILL_FIRE_axi4_slave_m_rready,
       WILL_FIRE_axi4_slave_m_wvalid;

  // inputs to muxes for submodule ports
  wire MUX_mtip$write_1__VAL_1;

  // remaining internal signals
  reg [63 : 0] x_rdata__h1019;
  reg [1 : 0] CASE_s_xactor_f_rd_addrD_OUT_BITS_58_TO_43_0x_ETC__q1,
	      CASE_s_xactor_f_wr_addrD_OUT_BITS_58_TO_43_0x_ETC__q2;

  // value method msip_int
  assign msip_int = msip ;
  assign RDY_msip_int = 1'd1 ;

  // value method mtip_int
  assign mtip_int = mtip ;
  assign RDY_mtip_int = 1'd1 ;

  // value method mtime
  assign mtime = rgmtime ;
  assign RDY_mtime = 1'd1 ;

  // value method mtimecmp
  assign mtimecmp = rgmtimecmp ;
  assign RDY_mtimecmp = 1'd1 ;

  // action method axi4_slave_m_awvalid
  assign RDY_axi4_slave_m_awvalid = s_xactor_f_wr_addr$FULL_N ;
  assign CAN_FIRE_axi4_slave_m_awvalid = s_xactor_f_wr_addr$FULL_N ;
  assign WILL_FIRE_axi4_slave_m_awvalid = EN_axi4_slave_m_awvalid ;

  // value method axi4_slave_m_awready
  assign axi4_slave_awready = s_xactor_f_wr_addr$FULL_N ;

  // action method axi4_slave_m_wvalid
  assign RDY_axi4_slave_m_wvalid = s_xactor_f_wr_data$FULL_N ;
  assign CAN_FIRE_axi4_slave_m_wvalid = s_xactor_f_wr_data$FULL_N ;
  assign WILL_FIRE_axi4_slave_m_wvalid = EN_axi4_slave_m_wvalid ;

  // value method axi4_slave_m_wready
  assign axi4_slave_wready = s_xactor_f_wr_data$FULL_N ;

  // value method axi4_slave_m_bvalid
  assign axi4_slave_bvalid = s_xactor_f_wr_resp$EMPTY_N ;

  // value method axi4_slave_m_bresp
  assign axi4_slave_bresp = s_xactor_f_wr_resp$D_OUT[15:14] ;

  // value method axi4_slave_m_buser
  assign axi4_slave_buser = s_xactor_f_wr_resp$D_OUT[13:4] ;

  // value method axi4_slave_m_bid
  assign axi4_slave_bid = s_xactor_f_wr_resp$D_OUT[3:0] ;

  // action method axi4_slave_m_bready
  assign CAN_FIRE_axi4_slave_m_bready = 1'd1 ;
  assign WILL_FIRE_axi4_slave_m_bready = 1'd1 ;

  // action method axi4_slave_m_arvalid
  assign CAN_FIRE_axi4_slave_m_arvalid = 1'd1 ;
  assign WILL_FIRE_axi4_slave_m_arvalid = 1'd1 ;

  // value method axi4_slave_m_arready
  assign axi4_slave_arready = s_xactor_f_rd_addr$FULL_N ;

  // value method axi4_slave_m_rvalid
  assign axi4_slave_rvalid = s_xactor_f_rd_data$EMPTY_N ;

  // value method axi4_slave_m_rresp
  assign axi4_slave_rresp = s_xactor_f_rd_data$D_OUT[80:79] ;

  // value method axi4_slave_m_rdata
  assign axi4_slave_rdata = s_xactor_f_rd_data$D_OUT[78:15] ;

  // value method axi4_slave_m_rlast
  assign axi4_slave_rlast = s_xactor_f_rd_data$D_OUT[14] ;

  // value method axi4_slave_m_ruser
  assign axi4_slave_ruser = s_xactor_f_rd_data$D_OUT[13:4] ;

  // value method axi4_slave_m_rid
  assign axi4_slave_rid = s_xactor_f_rd_data$D_OUT[3:0] ;

  // action method axi4_slave_m_rready
  assign CAN_FIRE_axi4_slave_m_rready = 1'd1 ;
  assign WILL_FIRE_axi4_slave_m_rready = 1'd1 ;

  // submodule s_xactor_f_rd_addr
  FIFOL1 #(.width(32'd75)) s_xactor_f_rd_addr(.RST(RST_N),
					      .CLK(CLK),
					      .D_IN(s_xactor_f_rd_addr$D_IN),
					      .ENQ(s_xactor_f_rd_addr$ENQ),
					      .DEQ(s_xactor_f_rd_addr$DEQ),
					      .CLR(s_xactor_f_rd_addr$CLR),
					      .D_OUT(s_xactor_f_rd_addr$D_OUT),
					      .FULL_N(s_xactor_f_rd_addr$FULL_N),
					      .EMPTY_N(s_xactor_f_rd_addr$EMPTY_N));

  // submodule s_xactor_f_rd_data
  FIFOL1 #(.width(32'd81)) s_xactor_f_rd_data(.RST(RST_N),
					      .CLK(CLK),
					      .D_IN(s_xactor_f_rd_data$D_IN),
					      .ENQ(s_xactor_f_rd_data$ENQ),
					      .DEQ(s_xactor_f_rd_data$DEQ),
					      .CLR(s_xactor_f_rd_data$CLR),
					      .D_OUT(s_xactor_f_rd_data$D_OUT),
					      .FULL_N(s_xactor_f_rd_data$FULL_N),
					      .EMPTY_N(s_xactor_f_rd_data$EMPTY_N));

  // submodule s_xactor_f_wr_addr
  FIFOL1 #(.width(32'd75)) s_xactor_f_wr_addr(.RST(RST_N),
					      .CLK(CLK),
					      .D_IN(s_xactor_f_wr_addr$D_IN),
					      .ENQ(s_xactor_f_wr_addr$ENQ),
					      .DEQ(s_xactor_f_wr_addr$DEQ),
					      .CLR(s_xactor_f_wr_addr$CLR),
					      .D_OUT(s_xactor_f_wr_addr$D_OUT),
					      .FULL_N(s_xactor_f_wr_addr$FULL_N),
					      .EMPTY_N(s_xactor_f_wr_addr$EMPTY_N));

  // submodule s_xactor_f_wr_data
  FIFOL1 #(.width(32'd77)) s_xactor_f_wr_data(.RST(RST_N),
					      .CLK(CLK),
					      .D_IN(s_xactor_f_wr_data$D_IN),
					      .ENQ(s_xactor_f_wr_data$ENQ),
					      .DEQ(s_xactor_f_wr_data$DEQ),
					      .CLR(s_xactor_f_wr_data$CLR),
					      .D_OUT(s_xactor_f_wr_data$D_OUT),
					      .FULL_N(s_xactor_f_wr_data$FULL_N),
					      .EMPTY_N(s_xactor_f_wr_data$EMPTY_N));

  // submodule s_xactor_f_wr_resp
  FIFOL1 #(.width(32'd16)) s_xactor_f_wr_resp(.RST(RST_N),
					      .CLK(CLK),
					      .D_IN(s_xactor_f_wr_resp$D_IN),
					      .ENQ(s_xactor_f_wr_resp$ENQ),
					      .DEQ(s_xactor_f_wr_resp$DEQ),
					      .CLR(s_xactor_f_wr_resp$CLR),
					      .D_OUT(s_xactor_f_wr_resp$D_OUT),
					      .FULL_N(s_xactor_f_wr_resp$FULL_N),
					      .EMPTY_N(s_xactor_f_wr_resp$EMPTY_N));

  // rule RL_axi_read_transaction
  assign CAN_FIRE_RL_axi_read_transaction =
	     s_xactor_f_rd_addr$EMPTY_N && s_xactor_f_rd_data$FULL_N ;
  assign WILL_FIRE_RL_axi_read_transaction =
	     CAN_FIRE_RL_axi_read_transaction ;

  // rule RL_axi_write_transaction
  assign CAN_FIRE_RL_axi_write_transaction =
	     s_xactor_f_wr_addr$EMPTY_N && s_xactor_f_wr_data$EMPTY_N &&
	     s_xactor_f_wr_resp$FULL_N ;
  assign WILL_FIRE_RL_axi_write_transaction =
	     CAN_FIRE_RL_axi_write_transaction ;

  // rule RL_generate_time_interrupt
  assign CAN_FIRE_RL_generate_time_interrupt = !wr_mtimecmp_written$whas ;
  assign WILL_FIRE_RL_generate_time_interrupt =
	     CAN_FIRE_RL_generate_time_interrupt &&
	     !WILL_FIRE_RL_axi_write_transaction ;

  // rule RL_clear_interrupt
  assign CAN_FIRE_RL_clear_interrupt = wr_mtimecmp_written$whas ;
  assign WILL_FIRE_RL_clear_interrupt = wr_mtimecmp_written$whas ;

  // rule RL_increment_timer
  assign CAN_FIRE_RL_increment_timer = 1'd1 ;
  assign WILL_FIRE_RL_increment_timer = 1'd1 ;

  // inputs to muxes for submodule ports
  assign MUX_mtip$write_1__VAL_1 = rgmtime >= rgmtimecmp ;

  // inlined wires
  assign wr_mtimecmp_written$whas =
	     WILL_FIRE_RL_axi_write_transaction &&
	     s_xactor_f_wr_addr$D_OUT[58:43] == 16'h4000 ;

  // register msip
  assign msip$D_IN = s_xactor_f_wr_data$D_OUT[13] ;
  assign msip$EN =
	     WILL_FIRE_RL_axi_write_transaction &&
	     s_xactor_f_wr_addr$D_OUT[58:43] == 16'h0 ;

  // register mtip
  assign mtip$D_IN =
	     WILL_FIRE_RL_generate_time_interrupt && MUX_mtip$write_1__VAL_1 ;
  assign mtip$EN =
	     WILL_FIRE_RL_generate_time_interrupt ||
	     wr_mtimecmp_written$whas ;

  // register rg_tick
  assign rg_tick$D_IN = rg_tick + 2'd1 ;
  assign rg_tick$EN = 1'd1 ;

  // register rgmtime
  assign rgmtime$D_IN = rgmtime + 64'd1 ;
  assign rgmtime$EN = rg_tick == 2'd0 ;

  // register rgmtimecmp
  assign rgmtimecmp$D_IN = s_xactor_f_wr_data$D_OUT[76:13] ;
  assign rgmtimecmp$EN = wr_mtimecmp_written$whas ;

  // submodule s_xactor_f_rd_addr
  assign s_xactor_f_rd_addr$D_IN =
	     { axi4_slave_m_arvalid_araddr,
	       axi4_slave_m_arvalid_arprot,
	       axi4_slave_m_arvalid_aruser,
	       axi4_slave_m_arvalid_arlen,
	       axi4_slave_m_arvalid_arsize,
	       axi4_slave_m_arvalid_arburst,
	       axi4_slave_m_arvalid_arlock,
	       axi4_slave_m_arvalid_arcache,
	       axi4_slave_m_arvalid_arqos,
	       axi4_slave_m_arvalid_arregion,
	       axi4_slave_m_arvalid_arid } ;
  assign s_xactor_f_rd_addr$ENQ =
	     axi4_slave_m_arvalid_arvalid && s_xactor_f_rd_addr$FULL_N ;
  assign s_xactor_f_rd_addr$DEQ = CAN_FIRE_RL_axi_read_transaction ;
  assign s_xactor_f_rd_addr$CLR = 1'b0 ;

  // submodule s_xactor_f_rd_data
  assign s_xactor_f_rd_data$D_IN =
	     { CASE_s_xactor_f_rd_addrD_OUT_BITS_58_TO_43_0x_ETC__q1,
	       x_rdata__h1019,
	       11'd1024,
	       s_xactor_f_rd_addr$D_OUT[3:0] } ;
  assign s_xactor_f_rd_data$ENQ = CAN_FIRE_RL_axi_read_transaction ;
  assign s_xactor_f_rd_data$DEQ =
	     axi4_slave_m_rready_rready && s_xactor_f_rd_data$EMPTY_N ;
  assign s_xactor_f_rd_data$CLR = 1'b0 ;

  // submodule s_xactor_f_wr_addr
  assign s_xactor_f_wr_addr$D_IN =
	     { axi4_slave_m_awvalid_awaddr,
	       axi4_slave_m_awvalid_awprot,
	       axi4_slave_m_awvalid_awuser,
	       axi4_slave_m_awvalid_awlen,
	       axi4_slave_m_awvalid_awsize,
	       axi4_slave_m_awvalid_awburst,
	       axi4_slave_m_awvalid_awlock,
	       axi4_slave_m_awvalid_awcache,
	       axi4_slave_m_awvalid_awqos,
	       axi4_slave_m_awvalid_awregion,
	       axi4_slave_m_awvalid_awid } ;
  assign s_xactor_f_wr_addr$ENQ =
	     EN_axi4_slave_m_awvalid && axi4_slave_m_awvalid_awvalid ;
  assign s_xactor_f_wr_addr$DEQ = CAN_FIRE_RL_axi_write_transaction ;
  assign s_xactor_f_wr_addr$CLR = 1'b0 ;

  // submodule s_xactor_f_wr_data
  assign s_xactor_f_wr_data$D_IN =
	     { axi4_slave_m_wvalid_wdata,
	       axi4_slave_m_wvalid_wstrb,
	       axi4_slave_m_wvalid_wid,
	       axi4_slave_m_wvalid_wlast } ;
  assign s_xactor_f_wr_data$ENQ =
	     EN_axi4_slave_m_wvalid && axi4_slave_m_wvalid_wvalid ;
  assign s_xactor_f_wr_data$DEQ = CAN_FIRE_RL_axi_write_transaction ;
  assign s_xactor_f_wr_data$CLR = 1'b0 ;

  // submodule s_xactor_f_wr_resp
  assign s_xactor_f_wr_resp$D_IN =
	     { CASE_s_xactor_f_wr_addrD_OUT_BITS_58_TO_43_0x_ETC__q2,
	       10'd0,
	       s_xactor_f_wr_addr$D_OUT[3:0] } ;
  assign s_xactor_f_wr_resp$ENQ = CAN_FIRE_RL_axi_write_transaction ;
  assign s_xactor_f_wr_resp$DEQ =
	     axi4_slave_m_bready_bready && s_xactor_f_wr_resp$EMPTY_N ;
  assign s_xactor_f_wr_resp$CLR = 1'b0 ;

  // remaining internal signals
  always@(s_xactor_f_rd_addr$D_OUT or msip or rgmtimecmp or rgmtime)
  begin
    case (s_xactor_f_rd_addr$D_OUT[58:43])
      16'h0: x_rdata__h1019 = { 63'd0, msip };
      16'h4000: x_rdata__h1019 = rgmtimecmp;
      16'hBFF8: x_rdata__h1019 = rgmtime;
      default: x_rdata__h1019 = 64'd0;
    endcase
  end
  always@(s_xactor_f_rd_addr$D_OUT)
  begin
    case (s_xactor_f_rd_addr$D_OUT[58:43])
      16'h0, 16'h4000, 16'hBFF8:
	  CASE_s_xactor_f_rd_addrD_OUT_BITS_58_TO_43_0x_ETC__q1 = 2'd0;
      default: CASE_s_xactor_f_rd_addrD_OUT_BITS_58_TO_43_0x_ETC__q1 = 2'd2;
    endcase
  end
  always@(s_xactor_f_wr_addr$D_OUT)
  begin
    case (s_xactor_f_wr_addr$D_OUT[58:43])
      16'h0, 16'h4000:
	  CASE_s_xactor_f_wr_addrD_OUT_BITS_58_TO_43_0x_ETC__q2 = 2'd0;
      default: CASE_s_xactor_f_wr_addrD_OUT_BITS_58_TO_43_0x_ETC__q2 = 2'd2;
    endcase
  end

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        msip <= `BSV_ASSIGNMENT_DELAY 1'd0;
	mtip <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rg_tick <= `BSV_ASSIGNMENT_DELAY 2'd0;
	rgmtime <= `BSV_ASSIGNMENT_DELAY 64'd0;
	rgmtimecmp <= `BSV_ASSIGNMENT_DELAY 64'd0;
      end
    else
      begin
        if (msip$EN) msip <= `BSV_ASSIGNMENT_DELAY msip$D_IN;
	if (mtip$EN) mtip <= `BSV_ASSIGNMENT_DELAY mtip$D_IN;
	if (rg_tick$EN) rg_tick <= `BSV_ASSIGNMENT_DELAY rg_tick$D_IN;
	if (rgmtime$EN) rgmtime <= `BSV_ASSIGNMENT_DELAY rgmtime$D_IN;
	if (rgmtimecmp$EN)
	  rgmtimecmp <= `BSV_ASSIGNMENT_DELAY rgmtimecmp$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    msip = 1'h0;
    mtip = 1'h0;
    rg_tick = 2'h2;
    rgmtime = 64'hAAAAAAAAAAAAAAAA;
    rgmtimecmp = 64'hAAAAAAAAAAAAAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkclint

