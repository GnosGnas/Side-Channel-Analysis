//
// Generated by Bluespec Compiler, version 2018.10.beta1 (build e1df8052c, 2018-10-17)
//
// On Wed Jul  3 23:07:51 IST 2019
//
//
// Ports:
// Name                         I/O  size props
// RDY_slave_axi_uart_m_awvalid   O     1
// slave_axi_uart_awready         O     1
// RDY_slave_axi_uart_m_wvalid    O     1
// slave_axi_uart_wready          O     1
// slave_axi_uart_bvalid          O     1 reg
// slave_axi_uart_bresp           O     2 reg
// slave_axi_uart_buser           O    10 reg
// slave_axi_uart_bid             O     4 reg
// slave_axi_uart_arready         O     1
// slave_axi_uart_rvalid          O     1 reg
// slave_axi_uart_rresp           O     2 reg
// slave_axi_uart_rdata           O    64 reg
// slave_axi_uart_rlast           O     1 reg
// slave_axi_uart_ruser           O    10 reg
// slave_axi_uart_rid             O     4 reg
// coe_rs232_SOUT                 O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// slave_axi_uart_m_awvalid_awvalid  I     1
// slave_axi_uart_m_awvalid_awaddr  I    32 reg
// slave_axi_uart_m_awvalid_awprot  I     3 reg
// slave_axi_uart_m_awvalid_awuser  I    10 reg
// slave_axi_uart_m_awvalid_awlen  I     8 reg
// slave_axi_uart_m_awvalid_awsize  I     3 reg
// slave_axi_uart_m_awvalid_awburst  I     2 reg
// slave_axi_uart_m_awvalid_awlock  I     1 reg
// slave_axi_uart_m_awvalid_awcache  I     4 reg
// slave_axi_uart_m_awvalid_awqos  I     4 reg
// slave_axi_uart_m_awvalid_awregion  I     4 reg
// slave_axi_uart_m_awvalid_awid  I     4 reg
// slave_axi_uart_m_wvalid_wvalid  I     1
// slave_axi_uart_m_wvalid_wdata  I    64 reg
// slave_axi_uart_m_wvalid_wstrb  I     8 reg
// slave_axi_uart_m_wvalid_wlast  I     1 reg
// slave_axi_uart_m_wvalid_wid    I     4 reg
// slave_axi_uart_m_bready_bready  I     1
// slave_axi_uart_m_arvalid_arvalid  I     1
// slave_axi_uart_m_arvalid_araddr  I    32 reg
// slave_axi_uart_m_arvalid_arprot  I     3 reg
// slave_axi_uart_m_arvalid_aruser  I    10 reg
// slave_axi_uart_m_arvalid_arlen  I     8 reg
// slave_axi_uart_m_arvalid_arsize  I     3 reg
// slave_axi_uart_m_arvalid_arburst  I     2 reg
// slave_axi_uart_m_arvalid_arlock  I     1 reg
// slave_axi_uart_m_arvalid_arcache  I     4 reg
// slave_axi_uart_m_arvalid_arqos  I     4 reg
// slave_axi_uart_m_arvalid_arregion  I     4 reg
// slave_axi_uart_m_arvalid_arid  I     4 reg
// slave_axi_uart_m_rready_rready  I     1
// coe_rs232_SIN                  I     1 reg
// EN_slave_axi_uart_m_awvalid    I     1
// EN_slave_axi_uart_m_wvalid     I     1
//
// Combinational paths from inputs to outputs:
//   slave_axi_uart_m_bready_bready -> RDY_slave_axi_uart_m_awvalid
//   slave_axi_uart_m_bready_bready -> slave_axi_uart_awready
//   slave_axi_uart_m_bready_bready -> RDY_slave_axi_uart_m_wvalid
//   slave_axi_uart_m_bready_bready -> slave_axi_uart_wready
//   slave_axi_uart_m_rready_rready -> slave_axi_uart_arready
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkUart_bs(CLK,
		 RST_N,

		 slave_axi_uart_m_awvalid_awvalid,
		 slave_axi_uart_m_awvalid_awaddr,
		 slave_axi_uart_m_awvalid_awprot,
		 slave_axi_uart_m_awvalid_awuser,
		 slave_axi_uart_m_awvalid_awlen,
		 slave_axi_uart_m_awvalid_awsize,
		 slave_axi_uart_m_awvalid_awburst,
		 slave_axi_uart_m_awvalid_awlock,
		 slave_axi_uart_m_awvalid_awcache,
		 slave_axi_uart_m_awvalid_awqos,
		 slave_axi_uart_m_awvalid_awregion,
		 slave_axi_uart_m_awvalid_awid,
		 EN_slave_axi_uart_m_awvalid,
		 RDY_slave_axi_uart_m_awvalid,

		 slave_axi_uart_awready,

		 slave_axi_uart_m_wvalid_wvalid,
		 slave_axi_uart_m_wvalid_wdata,
		 slave_axi_uart_m_wvalid_wstrb,
		 slave_axi_uart_m_wvalid_wlast,
		 slave_axi_uart_m_wvalid_wid,
		 EN_slave_axi_uart_m_wvalid,
		 RDY_slave_axi_uart_m_wvalid,

		 slave_axi_uart_wready,

		 slave_axi_uart_bvalid,

		 slave_axi_uart_bresp,

		 slave_axi_uart_buser,

		 slave_axi_uart_bid,

		 slave_axi_uart_m_bready_bready,

		 slave_axi_uart_m_arvalid_arvalid,
		 slave_axi_uart_m_arvalid_araddr,
		 slave_axi_uart_m_arvalid_arprot,
		 slave_axi_uart_m_arvalid_aruser,
		 slave_axi_uart_m_arvalid_arlen,
		 slave_axi_uart_m_arvalid_arsize,
		 slave_axi_uart_m_arvalid_arburst,
		 slave_axi_uart_m_arvalid_arlock,
		 slave_axi_uart_m_arvalid_arcache,
		 slave_axi_uart_m_arvalid_arqos,
		 slave_axi_uart_m_arvalid_arregion,
		 slave_axi_uart_m_arvalid_arid,

		 slave_axi_uart_arready,

		 slave_axi_uart_rvalid,

		 slave_axi_uart_rresp,

		 slave_axi_uart_rdata,

		 slave_axi_uart_rlast,

		 slave_axi_uart_ruser,

		 slave_axi_uart_rid,

		 slave_axi_uart_m_rready_rready,

		 coe_rs232_SIN,

		 coe_rs232_SOUT);
  input  CLK;
  input  RST_N;

  // action method slave_axi_uart_m_awvalid
  input  slave_axi_uart_m_awvalid_awvalid;
  input  [31 : 0] slave_axi_uart_m_awvalid_awaddr;
  input  [2 : 0] slave_axi_uart_m_awvalid_awprot;
  input  [9 : 0] slave_axi_uart_m_awvalid_awuser;
  input  [7 : 0] slave_axi_uart_m_awvalid_awlen;
  input  [2 : 0] slave_axi_uart_m_awvalid_awsize;
  input  [1 : 0] slave_axi_uart_m_awvalid_awburst;
  input  slave_axi_uart_m_awvalid_awlock;
  input  [3 : 0] slave_axi_uart_m_awvalid_awcache;
  input  [3 : 0] slave_axi_uart_m_awvalid_awqos;
  input  [3 : 0] slave_axi_uart_m_awvalid_awregion;
  input  [3 : 0] slave_axi_uart_m_awvalid_awid;
  input  EN_slave_axi_uart_m_awvalid;
  output RDY_slave_axi_uart_m_awvalid;

  // value method slave_axi_uart_m_awready
  output slave_axi_uart_awready;

  // action method slave_axi_uart_m_wvalid
  input  slave_axi_uart_m_wvalid_wvalid;
  input  [63 : 0] slave_axi_uart_m_wvalid_wdata;
  input  [7 : 0] slave_axi_uart_m_wvalid_wstrb;
  input  slave_axi_uart_m_wvalid_wlast;
  input  [3 : 0] slave_axi_uart_m_wvalid_wid;
  input  EN_slave_axi_uart_m_wvalid;
  output RDY_slave_axi_uart_m_wvalid;

  // value method slave_axi_uart_m_wready
  output slave_axi_uart_wready;

  // value method slave_axi_uart_m_bvalid
  output slave_axi_uart_bvalid;

  // value method slave_axi_uart_m_bresp
  output [1 : 0] slave_axi_uart_bresp;

  // value method slave_axi_uart_m_buser
  output [9 : 0] slave_axi_uart_buser;

  // value method slave_axi_uart_m_bid
  output [3 : 0] slave_axi_uart_bid;

  // action method slave_axi_uart_m_bready
  input  slave_axi_uart_m_bready_bready;

  // action method slave_axi_uart_m_arvalid
  input  slave_axi_uart_m_arvalid_arvalid;
  input  [31 : 0] slave_axi_uart_m_arvalid_araddr;
  input  [2 : 0] slave_axi_uart_m_arvalid_arprot;
  input  [9 : 0] slave_axi_uart_m_arvalid_aruser;
  input  [7 : 0] slave_axi_uart_m_arvalid_arlen;
  input  [2 : 0] slave_axi_uart_m_arvalid_arsize;
  input  [1 : 0] slave_axi_uart_m_arvalid_arburst;
  input  slave_axi_uart_m_arvalid_arlock;
  input  [3 : 0] slave_axi_uart_m_arvalid_arcache;
  input  [3 : 0] slave_axi_uart_m_arvalid_arqos;
  input  [3 : 0] slave_axi_uart_m_arvalid_arregion;
  input  [3 : 0] slave_axi_uart_m_arvalid_arid;

  // value method slave_axi_uart_m_arready
  output slave_axi_uart_arready;

  // value method slave_axi_uart_m_rvalid
  output slave_axi_uart_rvalid;

  // value method slave_axi_uart_m_rresp
  output [1 : 0] slave_axi_uart_rresp;

  // value method slave_axi_uart_m_rdata
  output [63 : 0] slave_axi_uart_rdata;

  // value method slave_axi_uart_m_rlast
  output slave_axi_uart_rlast;

  // value method slave_axi_uart_m_ruser
  output [9 : 0] slave_axi_uart_ruser;

  // value method slave_axi_uart_m_rid
  output [3 : 0] slave_axi_uart_rid;

  // action method slave_axi_uart_m_rready
  input  slave_axi_uart_m_rready_rready;

  // action method coe_rs232_sin
  input  coe_rs232_SIN;

  // value method coe_rs232_sout
  output coe_rs232_SOUT;

  // signals for module outputs
  wire [63 : 0] slave_axi_uart_rdata;
  wire [9 : 0] slave_axi_uart_buser, slave_axi_uart_ruser;
  wire [3 : 0] slave_axi_uart_bid, slave_axi_uart_rid;
  wire [1 : 0] slave_axi_uart_bresp, slave_axi_uart_rresp;
  wire RDY_slave_axi_uart_m_awvalid,
       RDY_slave_axi_uart_m_wvalid,
       coe_rs232_SOUT,
       slave_axi_uart_arready,
       slave_axi_uart_awready,
       slave_axi_uart_bvalid,
       slave_axi_uart_rlast,
       slave_axi_uart_rvalid,
       slave_axi_uart_wready;

  // inlined wires
  wire uart_fifoXmit_r_enq$whas,
       uart_pwRecvCellCountReset$whas,
       uart_pwRecvEnableBitCount$whas,
       uart_pwRecvResetBitCount$whas,
       uart_pwXmitCellCountReset$whas,
       uart_pwXmitEnableBitCount$whas,
       uart_pwXmitLoadBuffer$whas;

  // register baud_value
  reg [15 : 0] baud_value;
  wire [15 : 0] baud_value$D_IN;
  wire baud_value$EN;

  // register rg_status
  reg [3 : 0] rg_status;
  wire [3 : 0] rg_status$D_IN;
  wire rg_status$EN;

  // register uart_fifoRecv_countReg
  reg [4 : 0] uart_fifoRecv_countReg;
  wire [4 : 0] uart_fifoRecv_countReg$D_IN;
  wire uart_fifoRecv_countReg$EN;

  // register uart_fifoXmit_countReg
  reg [4 : 0] uart_fifoXmit_countReg;
  wire [4 : 0] uart_fifoXmit_countReg$D_IN;
  wire uart_fifoXmit_countReg$EN;

  // register uart_rRecvBitCount
  reg [3 : 0] uart_rRecvBitCount;
  wire [3 : 0] uart_rRecvBitCount$D_IN;
  wire uart_rRecvBitCount$EN;

  // register uart_rRecvCellCount
  reg [3 : 0] uart_rRecvCellCount;
  wire [3 : 0] uart_rRecvCellCount$D_IN;
  wire uart_rRecvCellCount$EN;

  // register uart_rRecvData
  reg uart_rRecvData;
  wire uart_rRecvData$D_IN, uart_rRecvData$EN;

  // register uart_rRecvParity
  reg uart_rRecvParity;
  wire uart_rRecvParity$D_IN, uart_rRecvParity$EN;

  // register uart_rRecvState
  reg [2 : 0] uart_rRecvState;
  reg [2 : 0] uart_rRecvState$D_IN;
  wire uart_rRecvState$EN;

  // register uart_rXmitBitCount
  reg [3 : 0] uart_rXmitBitCount;
  wire [3 : 0] uart_rXmitBitCount$D_IN;
  wire uart_rXmitBitCount$EN;

  // register uart_rXmitCellCount
  reg [3 : 0] uart_rXmitCellCount;
  wire [3 : 0] uart_rXmitCellCount$D_IN;
  wire uart_rXmitCellCount$EN;

  // register uart_rXmitDataOut
  reg uart_rXmitDataOut;
  reg uart_rXmitDataOut$D_IN;
  wire uart_rXmitDataOut$EN;

  // register uart_rXmitParity
  reg uart_rXmitParity;
  wire uart_rXmitParity$D_IN, uart_rXmitParity$EN;

  // register uart_rXmitState
  reg [2 : 0] uart_rXmitState;
  reg [2 : 0] uart_rXmitState$D_IN;
  wire uart_rXmitState$EN;

  // register uart_vrRecvBuffer_0
  reg uart_vrRecvBuffer_0;
  wire uart_vrRecvBuffer_0$D_IN, uart_vrRecvBuffer_0$EN;

  // register uart_vrRecvBuffer_1
  reg uart_vrRecvBuffer_1;
  wire uart_vrRecvBuffer_1$D_IN, uart_vrRecvBuffer_1$EN;

  // register uart_vrRecvBuffer_2
  reg uart_vrRecvBuffer_2;
  wire uart_vrRecvBuffer_2$D_IN, uart_vrRecvBuffer_2$EN;

  // register uart_vrRecvBuffer_3
  reg uart_vrRecvBuffer_3;
  wire uart_vrRecvBuffer_3$D_IN, uart_vrRecvBuffer_3$EN;

  // register uart_vrRecvBuffer_4
  reg uart_vrRecvBuffer_4;
  wire uart_vrRecvBuffer_4$D_IN, uart_vrRecvBuffer_4$EN;

  // register uart_vrRecvBuffer_5
  reg uart_vrRecvBuffer_5;
  wire uart_vrRecvBuffer_5$D_IN, uart_vrRecvBuffer_5$EN;

  // register uart_vrRecvBuffer_6
  reg uart_vrRecvBuffer_6;
  wire uart_vrRecvBuffer_6$D_IN, uart_vrRecvBuffer_6$EN;

  // register uart_vrRecvBuffer_7
  reg uart_vrRecvBuffer_7;
  wire uart_vrRecvBuffer_7$D_IN, uart_vrRecvBuffer_7$EN;

  // register uart_vrXmitBuffer_0
  reg uart_vrXmitBuffer_0;
  wire uart_vrXmitBuffer_0$D_IN, uart_vrXmitBuffer_0$EN;

  // register uart_vrXmitBuffer_1
  reg uart_vrXmitBuffer_1;
  wire uart_vrXmitBuffer_1$D_IN, uart_vrXmitBuffer_1$EN;

  // register uart_vrXmitBuffer_2
  reg uart_vrXmitBuffer_2;
  wire uart_vrXmitBuffer_2$D_IN, uart_vrXmitBuffer_2$EN;

  // register uart_vrXmitBuffer_3
  reg uart_vrXmitBuffer_3;
  wire uart_vrXmitBuffer_3$D_IN, uart_vrXmitBuffer_3$EN;

  // register uart_vrXmitBuffer_4
  reg uart_vrXmitBuffer_4;
  wire uart_vrXmitBuffer_4$D_IN, uart_vrXmitBuffer_4$EN;

  // register uart_vrXmitBuffer_5
  reg uart_vrXmitBuffer_5;
  wire uart_vrXmitBuffer_5$D_IN, uart_vrXmitBuffer_5$EN;

  // register uart_vrXmitBuffer_6
  reg uart_vrXmitBuffer_6;
  wire uart_vrXmitBuffer_6$D_IN, uart_vrXmitBuffer_6$EN;

  // register uart_vrXmitBuffer_7
  reg uart_vrXmitBuffer_7;
  wire uart_vrXmitBuffer_7$D_IN, uart_vrXmitBuffer_7$EN;

  // ports of submodule s_xactor_f_rd_addr
  wire [74 : 0] s_xactor_f_rd_addr$D_IN, s_xactor_f_rd_addr$D_OUT;
  wire s_xactor_f_rd_addr$CLR,
       s_xactor_f_rd_addr$DEQ,
       s_xactor_f_rd_addr$EMPTY_N,
       s_xactor_f_rd_addr$ENQ,
       s_xactor_f_rd_addr$FULL_N;

  // ports of submodule s_xactor_f_rd_data
  reg [80 : 0] s_xactor_f_rd_data$D_IN;
  wire [80 : 0] s_xactor_f_rd_data$D_OUT;
  wire s_xactor_f_rd_data$CLR,
       s_xactor_f_rd_data$DEQ,
       s_xactor_f_rd_data$EMPTY_N,
       s_xactor_f_rd_data$ENQ,
       s_xactor_f_rd_data$FULL_N;

  // ports of submodule s_xactor_f_wr_addr
  wire [74 : 0] s_xactor_f_wr_addr$D_IN, s_xactor_f_wr_addr$D_OUT;
  wire s_xactor_f_wr_addr$CLR,
       s_xactor_f_wr_addr$DEQ,
       s_xactor_f_wr_addr$EMPTY_N,
       s_xactor_f_wr_addr$ENQ,
       s_xactor_f_wr_addr$FULL_N;

  // ports of submodule s_xactor_f_wr_data
  wire [76 : 0] s_xactor_f_wr_data$D_IN, s_xactor_f_wr_data$D_OUT;
  wire s_xactor_f_wr_data$CLR,
       s_xactor_f_wr_data$DEQ,
       s_xactor_f_wr_data$EMPTY_N,
       s_xactor_f_wr_data$ENQ,
       s_xactor_f_wr_data$FULL_N;

  // ports of submodule s_xactor_f_wr_resp
  wire [15 : 0] s_xactor_f_wr_resp$D_IN, s_xactor_f_wr_resp$D_OUT;
  wire s_xactor_f_wr_resp$CLR,
       s_xactor_f_wr_resp$DEQ,
       s_xactor_f_wr_resp$EMPTY_N,
       s_xactor_f_wr_resp$ENQ,
       s_xactor_f_wr_resp$FULL_N;

  // ports of submodule uart_baudGen_rBaudCounter
  wire [15 : 0] uart_baudGen_rBaudCounter$DATA_A,
		uart_baudGen_rBaudCounter$DATA_B,
		uart_baudGen_rBaudCounter$DATA_C,
		uart_baudGen_rBaudCounter$DATA_F,
		uart_baudGen_rBaudCounter$Q_OUT;
  wire uart_baudGen_rBaudCounter$ADDA,
       uart_baudGen_rBaudCounter$ADDB,
       uart_baudGen_rBaudCounter$SETC,
       uart_baudGen_rBaudCounter$SETF;

  // ports of submodule uart_baudGen_rBaudTickCounter
  wire [2 : 0] uart_baudGen_rBaudTickCounter$DATA_A,
	       uart_baudGen_rBaudTickCounter$DATA_B,
	       uart_baudGen_rBaudTickCounter$DATA_C,
	       uart_baudGen_rBaudTickCounter$DATA_F,
	       uart_baudGen_rBaudTickCounter$Q_OUT;
  wire uart_baudGen_rBaudTickCounter$ADDA,
       uart_baudGen_rBaudTickCounter$ADDB,
       uart_baudGen_rBaudTickCounter$SETC,
       uart_baudGen_rBaudTickCounter$SETF;

  // ports of submodule uart_fifoRecv
  wire [7 : 0] uart_fifoRecv$D_IN, uart_fifoRecv$D_OUT;
  wire uart_fifoRecv$CLR,
       uart_fifoRecv$DEQ,
       uart_fifoRecv$EMPTY_N,
       uart_fifoRecv$ENQ,
       uart_fifoRecv$FULL_N;

  // ports of submodule uart_fifoXmit
  wire [7 : 0] uart_fifoXmit$D_IN, uart_fifoXmit$D_OUT;
  wire uart_fifoXmit$CLR,
       uart_fifoXmit$DEQ,
       uart_fifoXmit$EMPTY_N,
       uart_fifoXmit$ENQ,
       uart_fifoXmit$FULL_N;

  // rule scheduling signals
  wire CAN_FIRE_RL_rl_handle_axi4_uart_baud,
       CAN_FIRE_RL_rl_handle_axi4_uart_read,
       CAN_FIRE_RL_rl_handle_axi4_uart_status,
       CAN_FIRE_RL_rl_handle_axi4_write,
       CAN_FIRE_RL_rl_handle_rest_axi4_req,
       CAN_FIRE_RL_rl_update_status_reg,
       CAN_FIRE_RL_uart_baudGen_assert_2x_baud_tick,
       CAN_FIRE_RL_uart_baudGen_baud_count_wire,
       CAN_FIRE_RL_uart_baudGen_baud_tick_count_wire,
       CAN_FIRE_RL_uart_baudGen_count_baudtick_16x,
       CAN_FIRE_RL_uart_baud_generator_clock_enable,
       CAN_FIRE_RL_uart_fifoRecv__updateLevelCounter,
       CAN_FIRE_RL_uart_fifoXmit__updateLevelCounter,
       CAN_FIRE_RL_uart_receive_bit_cell_time_counter,
       CAN_FIRE_RL_uart_receive_bit_counter,
       CAN_FIRE_RL_uart_receive_buffer_shift,
       CAN_FIRE_RL_uart_receive_find_center_of_bit_cell,
       CAN_FIRE_RL_uart_receive_parity_bit,
       CAN_FIRE_RL_uart_receive_sample_pin,
       CAN_FIRE_RL_uart_receive_stop_first_bit,
       CAN_FIRE_RL_uart_receive_stop_last_bit,
       CAN_FIRE_RL_uart_receive_wait_bit_cell_time_for_sample,
       CAN_FIRE_RL_uart_receive_wait_for_start_bit,
       CAN_FIRE_RL_uart_transmit_bit_cell_time_counter,
       CAN_FIRE_RL_uart_transmit_bit_counter,
       CAN_FIRE_RL_uart_transmit_buffer_load,
       CAN_FIRE_RL_uart_transmit_buffer_shift,
       CAN_FIRE_RL_uart_transmit_send_parity_bit,
       CAN_FIRE_RL_uart_transmit_send_start_bit,
       CAN_FIRE_RL_uart_transmit_send_stop_bit,
       CAN_FIRE_RL_uart_transmit_send_stop_bit1_5,
       CAN_FIRE_RL_uart_transmit_send_stop_bit2,
       CAN_FIRE_RL_uart_transmit_shift_next_bit,
       CAN_FIRE_RL_uart_transmit_wait_1_bit_cell_time,
       CAN_FIRE_RL_uart_transmit_wait_for_start_command,
       CAN_FIRE_coe_rs232_sin,
       CAN_FIRE_slave_axi_uart_m_arvalid,
       CAN_FIRE_slave_axi_uart_m_awvalid,
       CAN_FIRE_slave_axi_uart_m_bready,
       CAN_FIRE_slave_axi_uart_m_rready,
       CAN_FIRE_slave_axi_uart_m_wvalid,
       WILL_FIRE_RL_rl_handle_axi4_uart_baud,
       WILL_FIRE_RL_rl_handle_axi4_uart_read,
       WILL_FIRE_RL_rl_handle_axi4_uart_status,
       WILL_FIRE_RL_rl_handle_axi4_write,
       WILL_FIRE_RL_rl_handle_rest_axi4_req,
       WILL_FIRE_RL_rl_update_status_reg,
       WILL_FIRE_RL_uart_baudGen_assert_2x_baud_tick,
       WILL_FIRE_RL_uart_baudGen_baud_count_wire,
       WILL_FIRE_RL_uart_baudGen_baud_tick_count_wire,
       WILL_FIRE_RL_uart_baudGen_count_baudtick_16x,
       WILL_FIRE_RL_uart_baud_generator_clock_enable,
       WILL_FIRE_RL_uart_fifoRecv__updateLevelCounter,
       WILL_FIRE_RL_uart_fifoXmit__updateLevelCounter,
       WILL_FIRE_RL_uart_receive_bit_cell_time_counter,
       WILL_FIRE_RL_uart_receive_bit_counter,
       WILL_FIRE_RL_uart_receive_buffer_shift,
       WILL_FIRE_RL_uart_receive_find_center_of_bit_cell,
       WILL_FIRE_RL_uart_receive_parity_bit,
       WILL_FIRE_RL_uart_receive_sample_pin,
       WILL_FIRE_RL_uart_receive_stop_first_bit,
       WILL_FIRE_RL_uart_receive_stop_last_bit,
       WILL_FIRE_RL_uart_receive_wait_bit_cell_time_for_sample,
       WILL_FIRE_RL_uart_receive_wait_for_start_bit,
       WILL_FIRE_RL_uart_transmit_bit_cell_time_counter,
       WILL_FIRE_RL_uart_transmit_bit_counter,
       WILL_FIRE_RL_uart_transmit_buffer_load,
       WILL_FIRE_RL_uart_transmit_buffer_shift,
       WILL_FIRE_RL_uart_transmit_send_parity_bit,
       WILL_FIRE_RL_uart_transmit_send_start_bit,
       WILL_FIRE_RL_uart_transmit_send_stop_bit,
       WILL_FIRE_RL_uart_transmit_send_stop_bit1_5,
       WILL_FIRE_RL_uart_transmit_send_stop_bit2,
       WILL_FIRE_RL_uart_transmit_shift_next_bit,
       WILL_FIRE_RL_uart_transmit_wait_1_bit_cell_time,
       WILL_FIRE_RL_uart_transmit_wait_for_start_command,
       WILL_FIRE_coe_rs232_sin,
       WILL_FIRE_slave_axi_uart_m_arvalid,
       WILL_FIRE_slave_axi_uart_m_awvalid,
       WILL_FIRE_slave_axi_uart_m_bready,
       WILL_FIRE_slave_axi_uart_m_rready,
       WILL_FIRE_slave_axi_uart_m_wvalid;

  // inputs to muxes for submodule ports
  reg [2 : 0] MUX_uart_rRecvState$write_1__VAL_3;
  wire [80 : 0] MUX_s_xactor_f_rd_data$enq_1__VAL_1,
		MUX_s_xactor_f_rd_data$enq_1__VAL_2,
		MUX_s_xactor_f_rd_data$enq_1__VAL_3,
		MUX_s_xactor_f_rd_data$enq_1__VAL_4;
  wire [2 : 0] MUX_uart_rRecvState$write_1__VAL_1,
	       MUX_uart_rRecvState$write_1__VAL_2,
	       MUX_uart_rRecvState$write_1__VAL_4,
	       MUX_uart_rXmitState$write_1__VAL_1,
	       MUX_uart_rXmitState$write_1__VAL_2,
	       MUX_uart_rXmitState$write_1__VAL_3,
	       MUX_uart_rXmitState$write_1__VAL_4,
	       MUX_uart_rXmitState$write_1__VAL_5,
	       MUX_uart_rXmitState$write_1__VAL_6,
	       MUX_uart_rXmitState$write_1__VAL_7;
  wire MUX_uart_rRecvState$write_1__SEL_6,
       MUX_uart_rXmitDataOut$write_1__SEL_1,
       MUX_uart_rXmitDataOut$write_1__SEL_2,
       MUX_uart_rXmitDataOut$write_1__SEL_3;

  // remaining internal signals
  reg [1 : 0] CASE_s_xactor_f_wr_addrD_OUT_BITS_46_TO_45_0__ETC__q1;
  wire [63 : 0] x_rdata__h11373, x_rdata__h11480, x_rdata__h11570;
  wire [3 : 0] x__h3124, x__h4765, x__h6559, x__h6585;
  wire _dor2uart_pwXmitCellCountReset$EN_wset,
       uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_b_ETC___d30,
       z__h7973,
       z__h7980,
       z__h7987,
       z__h7994,
       z__h8001,
       z__h8008;

  // action method slave_axi_uart_m_awvalid
  assign RDY_slave_axi_uart_m_awvalid = s_xactor_f_wr_addr$FULL_N ;
  assign CAN_FIRE_slave_axi_uart_m_awvalid = s_xactor_f_wr_addr$FULL_N ;
  assign WILL_FIRE_slave_axi_uart_m_awvalid = EN_slave_axi_uart_m_awvalid ;

  // value method slave_axi_uart_m_awready
  assign slave_axi_uart_awready = s_xactor_f_wr_addr$FULL_N ;

  // action method slave_axi_uart_m_wvalid
  assign RDY_slave_axi_uart_m_wvalid = s_xactor_f_wr_data$FULL_N ;
  assign CAN_FIRE_slave_axi_uart_m_wvalid = s_xactor_f_wr_data$FULL_N ;
  assign WILL_FIRE_slave_axi_uart_m_wvalid = EN_slave_axi_uart_m_wvalid ;

  // value method slave_axi_uart_m_wready
  assign slave_axi_uart_wready = s_xactor_f_wr_data$FULL_N ;

  // value method slave_axi_uart_m_bvalid
  assign slave_axi_uart_bvalid = s_xactor_f_wr_resp$EMPTY_N ;

  // value method slave_axi_uart_m_bresp
  assign slave_axi_uart_bresp = s_xactor_f_wr_resp$D_OUT[15:14] ;

  // value method slave_axi_uart_m_buser
  assign slave_axi_uart_buser = s_xactor_f_wr_resp$D_OUT[13:4] ;

  // value method slave_axi_uart_m_bid
  assign slave_axi_uart_bid = s_xactor_f_wr_resp$D_OUT[3:0] ;

  // action method slave_axi_uart_m_bready
  assign CAN_FIRE_slave_axi_uart_m_bready = 1'd1 ;
  assign WILL_FIRE_slave_axi_uart_m_bready = 1'd1 ;

  // action method slave_axi_uart_m_arvalid
  assign CAN_FIRE_slave_axi_uart_m_arvalid = 1'd1 ;
  assign WILL_FIRE_slave_axi_uart_m_arvalid = 1'd1 ;

  // value method slave_axi_uart_m_arready
  assign slave_axi_uart_arready = s_xactor_f_rd_addr$FULL_N ;

  // value method slave_axi_uart_m_rvalid
  assign slave_axi_uart_rvalid = s_xactor_f_rd_data$EMPTY_N ;

  // value method slave_axi_uart_m_rresp
  assign slave_axi_uart_rresp = s_xactor_f_rd_data$D_OUT[80:79] ;

  // value method slave_axi_uart_m_rdata
  assign slave_axi_uart_rdata = s_xactor_f_rd_data$D_OUT[78:15] ;

  // value method slave_axi_uart_m_rlast
  assign slave_axi_uart_rlast = s_xactor_f_rd_data$D_OUT[14] ;

  // value method slave_axi_uart_m_ruser
  assign slave_axi_uart_ruser = s_xactor_f_rd_data$D_OUT[13:4] ;

  // value method slave_axi_uart_m_rid
  assign slave_axi_uart_rid = s_xactor_f_rd_data$D_OUT[3:0] ;

  // action method slave_axi_uart_m_rready
  assign CAN_FIRE_slave_axi_uart_m_rready = 1'd1 ;
  assign WILL_FIRE_slave_axi_uart_m_rready = 1'd1 ;

  // action method coe_rs232_sin
  assign CAN_FIRE_coe_rs232_sin = 1'd1 ;
  assign WILL_FIRE_coe_rs232_sin = 1'd1 ;

  // value method coe_rs232_sout
  assign coe_rs232_SOUT = uart_rXmitDataOut ;

  // submodule s_xactor_f_rd_addr
  FIFOL1 #(.width(32'd75)) s_xactor_f_rd_addr(.RST(RST_N),
					      .CLK(CLK),
					      .D_IN(s_xactor_f_rd_addr$D_IN),
					      .ENQ(s_xactor_f_rd_addr$ENQ),
					      .DEQ(s_xactor_f_rd_addr$DEQ),
					      .CLR(s_xactor_f_rd_addr$CLR),
					      .D_OUT(s_xactor_f_rd_addr$D_OUT),
					      .FULL_N(s_xactor_f_rd_addr$FULL_N),
					      .EMPTY_N(s_xactor_f_rd_addr$EMPTY_N));

  // submodule s_xactor_f_rd_data
  FIFOL1 #(.width(32'd81)) s_xactor_f_rd_data(.RST(RST_N),
					      .CLK(CLK),
					      .D_IN(s_xactor_f_rd_data$D_IN),
					      .ENQ(s_xactor_f_rd_data$ENQ),
					      .DEQ(s_xactor_f_rd_data$DEQ),
					      .CLR(s_xactor_f_rd_data$CLR),
					      .D_OUT(s_xactor_f_rd_data$D_OUT),
					      .FULL_N(s_xactor_f_rd_data$FULL_N),
					      .EMPTY_N(s_xactor_f_rd_data$EMPTY_N));

  // submodule s_xactor_f_wr_addr
  FIFOL1 #(.width(32'd75)) s_xactor_f_wr_addr(.RST(RST_N),
					      .CLK(CLK),
					      .D_IN(s_xactor_f_wr_addr$D_IN),
					      .ENQ(s_xactor_f_wr_addr$ENQ),
					      .DEQ(s_xactor_f_wr_addr$DEQ),
					      .CLR(s_xactor_f_wr_addr$CLR),
					      .D_OUT(s_xactor_f_wr_addr$D_OUT),
					      .FULL_N(s_xactor_f_wr_addr$FULL_N),
					      .EMPTY_N(s_xactor_f_wr_addr$EMPTY_N));

  // submodule s_xactor_f_wr_data
  FIFOL1 #(.width(32'd77)) s_xactor_f_wr_data(.RST(RST_N),
					      .CLK(CLK),
					      .D_IN(s_xactor_f_wr_data$D_IN),
					      .ENQ(s_xactor_f_wr_data$ENQ),
					      .DEQ(s_xactor_f_wr_data$DEQ),
					      .CLR(s_xactor_f_wr_data$CLR),
					      .D_OUT(s_xactor_f_wr_data$D_OUT),
					      .FULL_N(s_xactor_f_wr_data$FULL_N),
					      .EMPTY_N(s_xactor_f_wr_data$EMPTY_N));

  // submodule s_xactor_f_wr_resp
  FIFOL1 #(.width(32'd16)) s_xactor_f_wr_resp(.RST(RST_N),
					      .CLK(CLK),
					      .D_IN(s_xactor_f_wr_resp$D_IN),
					      .ENQ(s_xactor_f_wr_resp$ENQ),
					      .DEQ(s_xactor_f_wr_resp$DEQ),
					      .CLR(s_xactor_f_wr_resp$CLR),
					      .D_OUT(s_xactor_f_wr_resp$D_OUT),
					      .FULL_N(s_xactor_f_wr_resp$FULL_N),
					      .EMPTY_N(s_xactor_f_wr_resp$EMPTY_N));

  // submodule uart_baudGen_rBaudCounter
  Counter #(.width(32'd16), .init(16'd0)) uart_baudGen_rBaudCounter(.CLK(CLK),
								    .RST(RST_N),
								    .DATA_A(uart_baudGen_rBaudCounter$DATA_A),
								    .DATA_B(uart_baudGen_rBaudCounter$DATA_B),
								    .DATA_C(uart_baudGen_rBaudCounter$DATA_C),
								    .DATA_F(uart_baudGen_rBaudCounter$DATA_F),
								    .ADDA(uart_baudGen_rBaudCounter$ADDA),
								    .ADDB(uart_baudGen_rBaudCounter$ADDB),
								    .SETC(uart_baudGen_rBaudCounter$SETC),
								    .SETF(uart_baudGen_rBaudCounter$SETF),
								    .Q_OUT(uart_baudGen_rBaudCounter$Q_OUT));

  // submodule uart_baudGen_rBaudTickCounter
  Counter #(.width(32'd3),
	    .init(3'd0)) uart_baudGen_rBaudTickCounter(.CLK(CLK),
						       .RST(RST_N),
						       .DATA_A(uart_baudGen_rBaudTickCounter$DATA_A),
						       .DATA_B(uart_baudGen_rBaudTickCounter$DATA_B),
						       .DATA_C(uart_baudGen_rBaudTickCounter$DATA_C),
						       .DATA_F(uart_baudGen_rBaudTickCounter$DATA_F),
						       .ADDA(uart_baudGen_rBaudTickCounter$ADDA),
						       .ADDB(uart_baudGen_rBaudTickCounter$ADDB),
						       .SETC(uart_baudGen_rBaudTickCounter$SETC),
						       .SETF(uart_baudGen_rBaudTickCounter$SETF),
						       .Q_OUT(uart_baudGen_rBaudTickCounter$Q_OUT));

  // submodule uart_fifoRecv
  SizedFIFO #(.p1width(32'd8),
	      .p2depth(32'd16),
	      .p3cntr_width(32'd4),
	      .guarded(32'd1)) uart_fifoRecv(.RST(RST_N),
					     .CLK(CLK),
					     .D_IN(uart_fifoRecv$D_IN),
					     .ENQ(uart_fifoRecv$ENQ),
					     .DEQ(uart_fifoRecv$DEQ),
					     .CLR(uart_fifoRecv$CLR),
					     .D_OUT(uart_fifoRecv$D_OUT),
					     .FULL_N(uart_fifoRecv$FULL_N),
					     .EMPTY_N(uart_fifoRecv$EMPTY_N));

  // submodule uart_fifoXmit
  SizedFIFO #(.p1width(32'd8),
	      .p2depth(32'd16),
	      .p3cntr_width(32'd4),
	      .guarded(32'd1)) uart_fifoXmit(.RST(RST_N),
					     .CLK(CLK),
					     .D_IN(uart_fifoXmit$D_IN),
					     .ENQ(uart_fifoXmit$ENQ),
					     .DEQ(uart_fifoXmit$DEQ),
					     .CLR(uart_fifoXmit$CLR),
					     .D_OUT(uart_fifoXmit$D_OUT),
					     .FULL_N(uart_fifoXmit$FULL_N),
					     .EMPTY_N(uart_fifoXmit$EMPTY_N));

  // rule RL_rl_handle_axi4_uart_status
  assign CAN_FIRE_RL_rl_handle_axi4_uart_status =
	     s_xactor_f_rd_addr$EMPTY_N && s_xactor_f_rd_data$FULL_N &&
	     s_xactor_f_rd_addr$D_OUT[46:45] == 2'd2 ;
  assign WILL_FIRE_RL_rl_handle_axi4_uart_status =
	     CAN_FIRE_RL_rl_handle_axi4_uart_status ;

  // rule RL_rl_handle_axi4_uart_baud
  assign CAN_FIRE_RL_rl_handle_axi4_uart_baud =
	     s_xactor_f_rd_addr$EMPTY_N && s_xactor_f_rd_data$FULL_N &&
	     s_xactor_f_rd_addr$D_OUT[46:45] == 2'd3 ;
  assign WILL_FIRE_RL_rl_handle_axi4_uart_baud =
	     CAN_FIRE_RL_rl_handle_axi4_uart_baud ;

  // rule RL_rl_handle_rest_axi4_req
  assign CAN_FIRE_RL_rl_handle_rest_axi4_req =
	     s_xactor_f_rd_data$FULL_N && s_xactor_f_rd_addr$EMPTY_N ;
  assign WILL_FIRE_RL_rl_handle_rest_axi4_req =
	     CAN_FIRE_RL_rl_handle_rest_axi4_req &&
	     !WILL_FIRE_RL_rl_handle_axi4_uart_baud &&
	     !WILL_FIRE_RL_rl_handle_axi4_uart_status &&
	     !WILL_FIRE_RL_rl_handle_axi4_uart_read ;

  // rule RL_rl_update_status_reg
  assign CAN_FIRE_RL_rl_update_status_reg = 1'd1 ;
  assign WILL_FIRE_RL_rl_update_status_reg = 1'd1 ;

  // rule RL_rl_handle_axi4_uart_read
  assign CAN_FIRE_RL_rl_handle_axi4_uart_read =
	     uart_fifoRecv$EMPTY_N && s_xactor_f_rd_addr$EMPTY_N &&
	     s_xactor_f_rd_data$FULL_N &&
	     s_xactor_f_rd_addr$D_OUT[46:45] == 2'd1 ;
  assign WILL_FIRE_RL_rl_handle_axi4_uart_read =
	     CAN_FIRE_RL_rl_handle_axi4_uart_read ;

  // rule RL_uart_baudGen_baud_count_wire
  assign CAN_FIRE_RL_uart_baudGen_baud_count_wire = 1'd1 ;
  assign WILL_FIRE_RL_uart_baudGen_baud_count_wire = 1'd1 ;

  // rule RL_uart_baud_generator_clock_enable
  assign CAN_FIRE_RL_uart_baud_generator_clock_enable = 1'd1 ;
  assign WILL_FIRE_RL_uart_baud_generator_clock_enable = 1'd1 ;

  // rule RL_uart_receive_wait_for_start_bit
  assign CAN_FIRE_RL_uart_receive_wait_for_start_bit =
	     uart_rRecvState == 3'd0 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_b_ETC___d30 ;
  assign WILL_FIRE_RL_uart_receive_wait_for_start_bit =
	     CAN_FIRE_RL_uart_receive_wait_for_start_bit ;

  // rule RL_uart_receive_find_center_of_bit_cell
  assign CAN_FIRE_RL_uart_receive_find_center_of_bit_cell =
	     uart_rRecvState == 3'd1 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_b_ETC___d30 ;
  assign WILL_FIRE_RL_uart_receive_find_center_of_bit_cell =
	     CAN_FIRE_RL_uart_receive_find_center_of_bit_cell ;

  // rule RL_uart_receive_wait_bit_cell_time_for_sample
  assign CAN_FIRE_RL_uart_receive_wait_bit_cell_time_for_sample =
	     uart_rRecvState == 3'd2 && uart_rRecvCellCount == 4'hF &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_b_ETC___d30 ;
  assign WILL_FIRE_RL_uart_receive_wait_bit_cell_time_for_sample =
	     CAN_FIRE_RL_uart_receive_wait_bit_cell_time_for_sample ;

  // rule RL_uart_receive_sample_pin
  assign CAN_FIRE_RL_uart_receive_sample_pin =
	     CAN_FIRE_RL_uart_receive_buffer_shift ;
  assign WILL_FIRE_RL_uart_receive_sample_pin =
	     CAN_FIRE_RL_uart_receive_buffer_shift ;

  // rule RL_uart_receive_parity_bit
  assign CAN_FIRE_RL_uart_receive_parity_bit =
	     uart_rRecvState == 3'd4 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_b_ETC___d30 ;
  assign WILL_FIRE_RL_uart_receive_parity_bit =
	     CAN_FIRE_RL_uart_receive_parity_bit ;

  // rule RL_uart_receive_stop_first_bit
  assign CAN_FIRE_RL_uart_receive_stop_first_bit =
	     uart_rRecvState == 3'd5 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_b_ETC___d30 ;
  assign WILL_FIRE_RL_uart_receive_stop_first_bit =
	     CAN_FIRE_RL_uart_receive_stop_first_bit ;

  // rule RL_uart_receive_bit_counter
  assign CAN_FIRE_RL_uart_receive_bit_counter = 1'd1 ;
  assign WILL_FIRE_RL_uart_receive_bit_counter = 1'd1 ;

  // rule RL_uart_receive_stop_last_bit
  assign CAN_FIRE_RL_uart_receive_stop_last_bit =
	     uart_rRecvState == 3'd6 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_b_ETC___d30 ;
  assign WILL_FIRE_RL_uart_receive_stop_last_bit =
	     CAN_FIRE_RL_uart_receive_stop_last_bit ;

  // rule RL_uart_receive_bit_cell_time_counter
  assign CAN_FIRE_RL_uart_receive_bit_cell_time_counter =
	     CAN_FIRE_RL_uart_baudGen_count_baudtick_16x ;
  assign WILL_FIRE_RL_uart_receive_bit_cell_time_counter =
	     CAN_FIRE_RL_uart_baudGen_count_baudtick_16x ;

  // rule RL_uart_receive_buffer_shift
  assign CAN_FIRE_RL_uart_receive_buffer_shift =
	     uart_rRecvState == 3'd3 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_b_ETC___d30 ;
  assign WILL_FIRE_RL_uart_receive_buffer_shift =
	     CAN_FIRE_RL_uart_receive_buffer_shift ;

  // rule RL_uart_transmit_wait_for_start_command
  assign CAN_FIRE_RL_uart_transmit_wait_for_start_command =
	     uart_rXmitState == 3'd0 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_b_ETC___d30 ;
  assign WILL_FIRE_RL_uart_transmit_wait_for_start_command =
	     CAN_FIRE_RL_uart_transmit_wait_for_start_command ;

  // rule RL_rl_handle_axi4_write
  assign CAN_FIRE_RL_rl_handle_axi4_write =
	     s_xactor_f_wr_data$EMPTY_N && uart_fifoXmit$FULL_N &&
	     s_xactor_f_wr_resp$FULL_N &&
	     s_xactor_f_wr_addr$EMPTY_N ;
  assign WILL_FIRE_RL_rl_handle_axi4_write =
	     CAN_FIRE_RL_rl_handle_axi4_write ;

  // rule RL_uart_transmit_send_start_bit
  assign CAN_FIRE_RL_uart_transmit_send_start_bit =
	     uart_rXmitState == 3'd1 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_b_ETC___d30 ;
  assign WILL_FIRE_RL_uart_transmit_send_start_bit =
	     CAN_FIRE_RL_uart_transmit_send_start_bit ;

  // rule RL_uart_transmit_wait_1_bit_cell_time
  assign CAN_FIRE_RL_uart_transmit_wait_1_bit_cell_time =
	     uart_rXmitState == 3'd2 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_b_ETC___d30 ;
  assign WILL_FIRE_RL_uart_transmit_wait_1_bit_cell_time =
	     CAN_FIRE_RL_uart_transmit_wait_1_bit_cell_time ;

  // rule RL_uart_transmit_bit_counter
  assign CAN_FIRE_RL_uart_transmit_bit_counter = 1'd1 ;
  assign WILL_FIRE_RL_uart_transmit_bit_counter = 1'd1 ;

  // rule RL_uart_transmit_shift_next_bit
  assign CAN_FIRE_RL_uart_transmit_shift_next_bit =
	     uart_rXmitState == 3'd3 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_b_ETC___d30 ;
  assign WILL_FIRE_RL_uart_transmit_shift_next_bit =
	     CAN_FIRE_RL_uart_transmit_shift_next_bit ;

  // rule RL_uart_transmit_buffer_load
  assign CAN_FIRE_RL_uart_transmit_buffer_load =
	     uart_fifoXmit$EMPTY_N && uart_pwXmitLoadBuffer$whas ;
  assign WILL_FIRE_RL_uart_transmit_buffer_load =
	     CAN_FIRE_RL_uart_transmit_buffer_load ;

  // rule RL_uart_transmit_buffer_shift
  assign CAN_FIRE_RL_uart_transmit_buffer_shift =
	     !uart_pwXmitLoadBuffer$whas &&
	     CAN_FIRE_RL_uart_transmit_shift_next_bit ;
  assign WILL_FIRE_RL_uart_transmit_buffer_shift =
	     CAN_FIRE_RL_uart_transmit_buffer_shift ;

  // rule RL_uart_transmit_send_parity_bit
  assign CAN_FIRE_RL_uart_transmit_send_parity_bit =
	     uart_rXmitState == 3'd7 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_b_ETC___d30 ;
  assign WILL_FIRE_RL_uart_transmit_send_parity_bit =
	     CAN_FIRE_RL_uart_transmit_send_parity_bit ;

  // rule RL_uart_transmit_send_stop_bit
  assign CAN_FIRE_RL_uart_transmit_send_stop_bit =
	     uart_rXmitState == 3'd4 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_b_ETC___d30 ;
  assign WILL_FIRE_RL_uart_transmit_send_stop_bit =
	     CAN_FIRE_RL_uart_transmit_send_stop_bit ;

  // rule RL_uart_transmit_send_stop_bit1_5
  assign CAN_FIRE_RL_uart_transmit_send_stop_bit1_5 =
	     uart_rXmitState == 3'd5 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_b_ETC___d30 ;
  assign WILL_FIRE_RL_uart_transmit_send_stop_bit1_5 =
	     CAN_FIRE_RL_uart_transmit_send_stop_bit1_5 ;

  // rule RL_uart_transmit_send_stop_bit2
  assign CAN_FIRE_RL_uart_transmit_send_stop_bit2 =
	     uart_rXmitState == 3'd6 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_b_ETC___d30 ;
  assign WILL_FIRE_RL_uart_transmit_send_stop_bit2 =
	     CAN_FIRE_RL_uart_transmit_send_stop_bit2 ;

  // rule RL_uart_transmit_bit_cell_time_counter
  assign CAN_FIRE_RL_uart_transmit_bit_cell_time_counter =
	     CAN_FIRE_RL_uart_baudGen_count_baudtick_16x ;
  assign WILL_FIRE_RL_uart_transmit_bit_cell_time_counter =
	     CAN_FIRE_RL_uart_baudGen_count_baudtick_16x ;

  // rule RL_uart_baudGen_baud_tick_count_wire
  assign CAN_FIRE_RL_uart_baudGen_baud_tick_count_wire = 1'd1 ;
  assign WILL_FIRE_RL_uart_baudGen_baud_tick_count_wire = 1'd1 ;

  // rule RL_uart_baudGen_assert_2x_baud_tick
  assign CAN_FIRE_RL_uart_baudGen_assert_2x_baud_tick =
	     uart_baudGen_rBaudTickCounter$Q_OUT == 3'd0 &&
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_b_ETC___d30 ;
  assign WILL_FIRE_RL_uart_baudGen_assert_2x_baud_tick =
	     CAN_FIRE_RL_uart_baudGen_assert_2x_baud_tick ;

  // rule RL_uart_baudGen_count_baudtick_16x
  assign CAN_FIRE_RL_uart_baudGen_count_baudtick_16x =
	     !uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_b_ETC___d30 ;
  assign WILL_FIRE_RL_uart_baudGen_count_baudtick_16x =
	     CAN_FIRE_RL_uart_baudGen_count_baudtick_16x ;

  // rule RL_uart_fifoRecv__updateLevelCounter
  assign CAN_FIRE_RL_uart_fifoRecv__updateLevelCounter =
	     CAN_FIRE_RL_uart_receive_stop_last_bit !=
	     CAN_FIRE_RL_rl_handle_axi4_uart_read ;
  assign WILL_FIRE_RL_uart_fifoRecv__updateLevelCounter =
	     CAN_FIRE_RL_uart_fifoRecv__updateLevelCounter ;

  // rule RL_uart_fifoXmit__updateLevelCounter
  assign CAN_FIRE_RL_uart_fifoXmit__updateLevelCounter =
	     uart_fifoXmit_r_enq$whas !=
	     CAN_FIRE_RL_uart_transmit_buffer_load ;
  assign WILL_FIRE_RL_uart_fifoXmit__updateLevelCounter =
	     CAN_FIRE_RL_uart_fifoXmit__updateLevelCounter ;

  // inputs to muxes for submodule ports
  assign MUX_uart_rRecvState$write_1__SEL_6 =
	     WILL_FIRE_RL_uart_receive_parity_bit ||
	     WILL_FIRE_RL_uart_receive_sample_pin ;
  assign MUX_uart_rXmitDataOut$write_1__SEL_1 =
	     WILL_FIRE_RL_uart_transmit_shift_next_bit ||
	     WILL_FIRE_RL_uart_transmit_wait_1_bit_cell_time ;
  assign MUX_uart_rXmitDataOut$write_1__SEL_2 =
	     WILL_FIRE_RL_uart_transmit_send_parity_bit ||
	     WILL_FIRE_RL_uart_transmit_send_start_bit ;
  assign MUX_uart_rXmitDataOut$write_1__SEL_3 =
	     WILL_FIRE_RL_uart_transmit_send_stop_bit2 ||
	     WILL_FIRE_RL_uart_transmit_send_stop_bit1_5 ||
	     WILL_FIRE_RL_uart_transmit_send_stop_bit ||
	     WILL_FIRE_RL_uart_transmit_wait_for_start_command ;
  assign MUX_s_xactor_f_rd_data$enq_1__VAL_1 =
	     { 2'd0, x_rdata__h11373, 1'd1, s_xactor_f_rd_addr$D_OUT[13:0] } ;
  assign MUX_s_xactor_f_rd_data$enq_1__VAL_2 =
	     { 2'd0, x_rdata__h11480, 1'd1, s_xactor_f_rd_addr$D_OUT[13:0] } ;
  assign MUX_s_xactor_f_rd_data$enq_1__VAL_3 =
	     { 2'd0, x_rdata__h11570, 1'd1, s_xactor_f_rd_addr$D_OUT[13:0] } ;
  assign MUX_s_xactor_f_rd_data$enq_1__VAL_4 =
	     { 2'd2,
	       64'hAAAAAAAAAAAAAAAA /* unspecified value */ ,
	       1'd1,
	       s_xactor_f_rd_addr$D_OUT[13:0] } ;
  assign MUX_uart_rRecvState$write_1__VAL_1 = uart_rRecvData ? 3'd0 : 3'd1 ;
  assign MUX_uart_rRecvState$write_1__VAL_2 =
	     (uart_rRecvCellCount == 4'h4) ?
	       (uart_rRecvData ? 3'd0 : 3'd2) :
	       3'd1 ;
  always@(uart_rRecvBitCount)
  begin
    case (uart_rRecvBitCount)
      4'd8, 4'd9, 4'd10: MUX_uart_rRecvState$write_1__VAL_3 = 3'd6;
      default: MUX_uart_rRecvState$write_1__VAL_3 = 3'd3;
    endcase
  end
  assign MUX_uart_rRecvState$write_1__VAL_4 = uart_rRecvData ? 3'd2 : 3'd0 ;
  assign MUX_uart_rXmitState$write_1__VAL_1 =
	     uart_fifoXmit$EMPTY_N ? 3'd1 : 3'd0 ;
  assign MUX_uart_rXmitState$write_1__VAL_2 =
	     (uart_rXmitCellCount == 4'hF) ? 3'd2 : 3'd1 ;
  assign MUX_uart_rXmitState$write_1__VAL_3 =
	     (uart_rXmitCellCount == 4'hF) ?
	       ((uart_rXmitBitCount == 4'd7) ? 3'd4 : 3'd3) :
	       3'd2 ;
  assign MUX_uart_rXmitState$write_1__VAL_4 =
	     (uart_rXmitCellCount == 4'hF) ? 3'd4 : 3'd7 ;
  assign MUX_uart_rXmitState$write_1__VAL_5 =
	     (uart_rXmitCellCount == 4'hF) ? 3'd0 : 3'd4 ;
  assign MUX_uart_rXmitState$write_1__VAL_6 =
	     (uart_rXmitCellCount == 4'h7) ? 3'd0 : 3'd5 ;
  assign MUX_uart_rXmitState$write_1__VAL_7 =
	     (uart_rXmitCellCount == 4'hF) ? 3'd0 : 3'd6 ;

  // inlined wires
  assign uart_pwRecvCellCountReset$whas =
	     WILL_FIRE_RL_uart_receive_find_center_of_bit_cell &&
	     uart_rRecvCellCount == 4'h4 ||
	     WILL_FIRE_RL_uart_receive_stop_last_bit ||
	     WILL_FIRE_RL_uart_receive_stop_first_bit ||
	     WILL_FIRE_RL_uart_receive_parity_bit ||
	     WILL_FIRE_RL_uart_receive_sample_pin ||
	     WILL_FIRE_RL_uart_receive_wait_bit_cell_time_for_sample ||
	     WILL_FIRE_RL_uart_receive_wait_for_start_bit ;
  assign uart_pwRecvResetBitCount$whas =
	     WILL_FIRE_RL_uart_receive_wait_for_start_bit && uart_rRecvData ;
  assign uart_pwRecvEnableBitCount$whas =
	     WILL_FIRE_RL_uart_receive_stop_first_bit ||
	     WILL_FIRE_RL_uart_receive_parity_bit ||
	     WILL_FIRE_RL_uart_receive_sample_pin ;
  assign uart_fifoXmit_r_enq$whas =
	     WILL_FIRE_RL_rl_handle_axi4_write &&
	     s_xactor_f_wr_addr$D_OUT[46:45] == 2'd0 ;
  assign uart_pwXmitCellCountReset$whas =
	     WILL_FIRE_RL_uart_transmit_wait_for_start_command &&
	     uart_fifoXmit$EMPTY_N ||
	     _dor2uart_pwXmitCellCountReset$EN_wset &&
	     uart_rXmitCellCount == 4'hF ||
	     WILL_FIRE_RL_uart_transmit_send_stop_bit1_5 &&
	     uart_rXmitCellCount == 4'h7 ;
  assign uart_pwXmitEnableBitCount$whas =
	     WILL_FIRE_RL_uart_transmit_wait_1_bit_cell_time &&
	     uart_rXmitCellCount == 4'hF &&
	     uart_rXmitBitCount != 4'd7 ;
  assign uart_pwXmitLoadBuffer$whas =
	     WILL_FIRE_RL_uart_transmit_wait_for_start_command &&
	     uart_fifoXmit$EMPTY_N ;

  // register baud_value
  assign baud_value$D_IN = s_xactor_f_wr_data$D_OUT[28:13] ;
  assign baud_value$EN =
	     WILL_FIRE_RL_rl_handle_axi4_write &&
	     s_xactor_f_wr_addr$D_OUT[46:45] == 2'd3 ;

  // register rg_status
  assign rg_status$D_IN =
	     { uart_fifoRecv$EMPTY_N,
	       uart_fifoRecv$FULL_N,
	       uart_fifoXmit$EMPTY_N,
	       !uart_fifoXmit$EMPTY_N && uart_rXmitState == 3'd0 } ;
  assign rg_status$EN = 1'd1 ;

  // register uart_fifoRecv_countReg
  assign uart_fifoRecv_countReg$D_IN =
	     CAN_FIRE_RL_uart_receive_stop_last_bit ?
	       uart_fifoRecv_countReg + 5'd1 :
	       uart_fifoRecv_countReg - 5'd1 ;
  assign uart_fifoRecv_countReg$EN =
	     CAN_FIRE_RL_uart_fifoRecv__updateLevelCounter ;

  // register uart_fifoXmit_countReg
  assign uart_fifoXmit_countReg$D_IN =
	     uart_fifoXmit_r_enq$whas ?
	       uart_fifoXmit_countReg + 5'd1 :
	       uart_fifoXmit_countReg - 5'd1 ;
  assign uart_fifoXmit_countReg$EN =
	     CAN_FIRE_RL_uart_fifoXmit__updateLevelCounter ;

  // register uart_rRecvBitCount
  assign uart_rRecvBitCount$D_IN =
	     uart_pwRecvResetBitCount$whas ? 4'd0 : x__h4765 ;
  assign uart_rRecvBitCount$EN =
	     uart_pwRecvResetBitCount$whas || uart_pwRecvEnableBitCount$whas ;

  // register uart_rRecvCellCount
  assign uart_rRecvCellCount$D_IN =
	     uart_pwRecvCellCountReset$whas ? 4'd0 : x__h3124 ;
  assign uart_rRecvCellCount$EN =
	     CAN_FIRE_RL_uart_baudGen_count_baudtick_16x ;

  // register uart_rRecvData
  assign uart_rRecvData$D_IN = coe_rs232_SIN ;
  assign uart_rRecvData$EN = 1'd1 ;

  // register uart_rRecvParity
  assign uart_rRecvParity$D_IN = uart_rRecvData ;
  assign uart_rRecvParity$EN = CAN_FIRE_RL_uart_receive_parity_bit ;

  // register uart_rRecvState
  always@(WILL_FIRE_RL_uart_receive_wait_for_start_bit or
	  MUX_uart_rRecvState$write_1__VAL_1 or
	  WILL_FIRE_RL_uart_receive_find_center_of_bit_cell or
	  MUX_uart_rRecvState$write_1__VAL_2 or
	  WILL_FIRE_RL_uart_receive_wait_bit_cell_time_for_sample or
	  MUX_uart_rRecvState$write_1__VAL_3 or
	  WILL_FIRE_RL_uart_receive_stop_first_bit or
	  MUX_uart_rRecvState$write_1__VAL_4 or
	  WILL_FIRE_RL_uart_receive_stop_last_bit or
	  MUX_uart_rRecvState$write_1__SEL_6)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_uart_receive_wait_for_start_bit:
	  uart_rRecvState$D_IN = MUX_uart_rRecvState$write_1__VAL_1;
      WILL_FIRE_RL_uart_receive_find_center_of_bit_cell:
	  uart_rRecvState$D_IN = MUX_uart_rRecvState$write_1__VAL_2;
      WILL_FIRE_RL_uart_receive_wait_bit_cell_time_for_sample:
	  uart_rRecvState$D_IN = MUX_uart_rRecvState$write_1__VAL_3;
      WILL_FIRE_RL_uart_receive_stop_first_bit:
	  uart_rRecvState$D_IN = MUX_uart_rRecvState$write_1__VAL_4;
      WILL_FIRE_RL_uart_receive_stop_last_bit: uart_rRecvState$D_IN = 3'd0;
      MUX_uart_rRecvState$write_1__SEL_6: uart_rRecvState$D_IN = 3'd2;
      default: uart_rRecvState$D_IN = 3'b010 /* unspecified value */ ;
    endcase
  end
  assign uart_rRecvState$EN =
	     WILL_FIRE_RL_uart_receive_wait_for_start_bit ||
	     WILL_FIRE_RL_uart_receive_find_center_of_bit_cell ||
	     WILL_FIRE_RL_uart_receive_wait_bit_cell_time_for_sample ||
	     WILL_FIRE_RL_uart_receive_stop_first_bit ||
	     WILL_FIRE_RL_uart_receive_stop_last_bit ||
	     WILL_FIRE_RL_uart_receive_parity_bit ||
	     WILL_FIRE_RL_uart_receive_sample_pin ;

  // register uart_rXmitBitCount
  assign uart_rXmitBitCount$D_IN =
	     CAN_FIRE_RL_uart_transmit_wait_for_start_command ?
	       4'd0 :
	       x__h6585 ;
  assign uart_rXmitBitCount$EN =
	     CAN_FIRE_RL_uart_transmit_wait_for_start_command ||
	     uart_pwXmitEnableBitCount$whas ;

  // register uart_rXmitCellCount
  assign uart_rXmitCellCount$D_IN =
	     uart_pwXmitCellCountReset$whas ? 4'd0 : x__h6559 ;
  assign uart_rXmitCellCount$EN =
	     CAN_FIRE_RL_uart_baudGen_count_baudtick_16x ;

  // register uart_rXmitDataOut
  always@(MUX_uart_rXmitDataOut$write_1__SEL_1 or
	  uart_vrXmitBuffer_0 or
	  MUX_uart_rXmitDataOut$write_1__SEL_2 or
	  MUX_uart_rXmitDataOut$write_1__SEL_3)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_uart_rXmitDataOut$write_1__SEL_1:
	  uart_rXmitDataOut$D_IN = uart_vrXmitBuffer_0;
      MUX_uart_rXmitDataOut$write_1__SEL_2: uart_rXmitDataOut$D_IN = 1'b0;
      MUX_uart_rXmitDataOut$write_1__SEL_3: uart_rXmitDataOut$D_IN = 1'b1;
      default: uart_rXmitDataOut$D_IN = 1'b0 /* unspecified value */ ;
    endcase
  end
  assign uart_rXmitDataOut$EN =
	     WILL_FIRE_RL_uart_transmit_shift_next_bit ||
	     WILL_FIRE_RL_uart_transmit_wait_1_bit_cell_time ||
	     WILL_FIRE_RL_uart_transmit_send_parity_bit ||
	     WILL_FIRE_RL_uart_transmit_send_start_bit ||
	     WILL_FIRE_RL_uart_transmit_send_stop_bit2 ||
	     WILL_FIRE_RL_uart_transmit_send_stop_bit1_5 ||
	     WILL_FIRE_RL_uart_transmit_send_stop_bit ||
	     WILL_FIRE_RL_uart_transmit_wait_for_start_command ;

  // register uart_rXmitParity
  assign uart_rXmitParity$D_IN = z__h8008 ^ uart_fifoXmit$D_OUT[7] ;
  assign uart_rXmitParity$EN = CAN_FIRE_RL_uart_transmit_buffer_load ;

  // register uart_rXmitState
  always@(WILL_FIRE_RL_uart_transmit_wait_for_start_command or
	  MUX_uart_rXmitState$write_1__VAL_1 or
	  WILL_FIRE_RL_uart_transmit_send_start_bit or
	  MUX_uart_rXmitState$write_1__VAL_2 or
	  WILL_FIRE_RL_uart_transmit_wait_1_bit_cell_time or
	  MUX_uart_rXmitState$write_1__VAL_3 or
	  WILL_FIRE_RL_uart_transmit_send_parity_bit or
	  MUX_uart_rXmitState$write_1__VAL_4 or
	  WILL_FIRE_RL_uart_transmit_send_stop_bit or
	  MUX_uart_rXmitState$write_1__VAL_5 or
	  WILL_FIRE_RL_uart_transmit_send_stop_bit1_5 or
	  MUX_uart_rXmitState$write_1__VAL_6 or
	  WILL_FIRE_RL_uart_transmit_send_stop_bit2 or
	  MUX_uart_rXmitState$write_1__VAL_7 or
	  WILL_FIRE_RL_uart_transmit_shift_next_bit)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_uart_transmit_wait_for_start_command:
	  uart_rXmitState$D_IN = MUX_uart_rXmitState$write_1__VAL_1;
      WILL_FIRE_RL_uart_transmit_send_start_bit:
	  uart_rXmitState$D_IN = MUX_uart_rXmitState$write_1__VAL_2;
      WILL_FIRE_RL_uart_transmit_wait_1_bit_cell_time:
	  uart_rXmitState$D_IN = MUX_uart_rXmitState$write_1__VAL_3;
      WILL_FIRE_RL_uart_transmit_send_parity_bit:
	  uart_rXmitState$D_IN = MUX_uart_rXmitState$write_1__VAL_4;
      WILL_FIRE_RL_uart_transmit_send_stop_bit:
	  uart_rXmitState$D_IN = MUX_uart_rXmitState$write_1__VAL_5;
      WILL_FIRE_RL_uart_transmit_send_stop_bit1_5:
	  uart_rXmitState$D_IN = MUX_uart_rXmitState$write_1__VAL_6;
      WILL_FIRE_RL_uart_transmit_send_stop_bit2:
	  uart_rXmitState$D_IN = MUX_uart_rXmitState$write_1__VAL_7;
      WILL_FIRE_RL_uart_transmit_shift_next_bit: uart_rXmitState$D_IN = 3'd2;
      default: uart_rXmitState$D_IN = 3'b010 /* unspecified value */ ;
    endcase
  end
  assign uart_rXmitState$EN =
	     WILL_FIRE_RL_uart_transmit_wait_for_start_command ||
	     WILL_FIRE_RL_uart_transmit_send_start_bit ||
	     WILL_FIRE_RL_uart_transmit_wait_1_bit_cell_time ||
	     WILL_FIRE_RL_uart_transmit_send_parity_bit ||
	     WILL_FIRE_RL_uart_transmit_send_stop_bit ||
	     WILL_FIRE_RL_uart_transmit_send_stop_bit1_5 ||
	     WILL_FIRE_RL_uart_transmit_send_stop_bit2 ||
	     WILL_FIRE_RL_uart_transmit_shift_next_bit ;

  // register uart_vrRecvBuffer_0
  assign uart_vrRecvBuffer_0$D_IN = uart_vrRecvBuffer_1 ;
  assign uart_vrRecvBuffer_0$EN = CAN_FIRE_RL_uart_receive_buffer_shift ;

  // register uart_vrRecvBuffer_1
  assign uart_vrRecvBuffer_1$D_IN = uart_vrRecvBuffer_2 ;
  assign uart_vrRecvBuffer_1$EN = CAN_FIRE_RL_uart_receive_buffer_shift ;

  // register uart_vrRecvBuffer_2
  assign uart_vrRecvBuffer_2$D_IN = uart_vrRecvBuffer_3 ;
  assign uart_vrRecvBuffer_2$EN = CAN_FIRE_RL_uart_receive_buffer_shift ;

  // register uart_vrRecvBuffer_3
  assign uart_vrRecvBuffer_3$D_IN = uart_vrRecvBuffer_4 ;
  assign uart_vrRecvBuffer_3$EN = CAN_FIRE_RL_uart_receive_buffer_shift ;

  // register uart_vrRecvBuffer_4
  assign uart_vrRecvBuffer_4$D_IN = uart_vrRecvBuffer_5 ;
  assign uart_vrRecvBuffer_4$EN = CAN_FIRE_RL_uart_receive_buffer_shift ;

  // register uart_vrRecvBuffer_5
  assign uart_vrRecvBuffer_5$D_IN = uart_vrRecvBuffer_6 ;
  assign uart_vrRecvBuffer_5$EN = CAN_FIRE_RL_uart_receive_buffer_shift ;

  // register uart_vrRecvBuffer_6
  assign uart_vrRecvBuffer_6$D_IN = uart_vrRecvBuffer_7 ;
  assign uart_vrRecvBuffer_6$EN = CAN_FIRE_RL_uart_receive_buffer_shift ;

  // register uart_vrRecvBuffer_7
  assign uart_vrRecvBuffer_7$D_IN = uart_rRecvData ;
  assign uart_vrRecvBuffer_7$EN = CAN_FIRE_RL_uart_receive_buffer_shift ;

  // register uart_vrXmitBuffer_0
  assign uart_vrXmitBuffer_0$D_IN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ?
	       uart_fifoXmit$D_OUT[0] :
	       uart_vrXmitBuffer_1 ;
  assign uart_vrXmitBuffer_0$EN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ||
	     WILL_FIRE_RL_uart_transmit_buffer_shift ;

  // register uart_vrXmitBuffer_1
  assign uart_vrXmitBuffer_1$D_IN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ?
	       uart_fifoXmit$D_OUT[1] :
	       uart_vrXmitBuffer_2 ;
  assign uart_vrXmitBuffer_1$EN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ||
	     WILL_FIRE_RL_uart_transmit_buffer_shift ;

  // register uart_vrXmitBuffer_2
  assign uart_vrXmitBuffer_2$D_IN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ?
	       uart_fifoXmit$D_OUT[2] :
	       uart_vrXmitBuffer_3 ;
  assign uart_vrXmitBuffer_2$EN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ||
	     WILL_FIRE_RL_uart_transmit_buffer_shift ;

  // register uart_vrXmitBuffer_3
  assign uart_vrXmitBuffer_3$D_IN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ?
	       uart_fifoXmit$D_OUT[3] :
	       uart_vrXmitBuffer_4 ;
  assign uart_vrXmitBuffer_3$EN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ||
	     WILL_FIRE_RL_uart_transmit_buffer_shift ;

  // register uart_vrXmitBuffer_4
  assign uart_vrXmitBuffer_4$D_IN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ?
	       uart_fifoXmit$D_OUT[4] :
	       uart_vrXmitBuffer_5 ;
  assign uart_vrXmitBuffer_4$EN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ||
	     WILL_FIRE_RL_uart_transmit_buffer_shift ;

  // register uart_vrXmitBuffer_5
  assign uart_vrXmitBuffer_5$D_IN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ?
	       uart_fifoXmit$D_OUT[5] :
	       uart_vrXmitBuffer_6 ;
  assign uart_vrXmitBuffer_5$EN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ||
	     WILL_FIRE_RL_uart_transmit_buffer_shift ;

  // register uart_vrXmitBuffer_6
  assign uart_vrXmitBuffer_6$D_IN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ?
	       uart_fifoXmit$D_OUT[6] :
	       uart_vrXmitBuffer_7 ;
  assign uart_vrXmitBuffer_6$EN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ||
	     WILL_FIRE_RL_uart_transmit_buffer_shift ;

  // register uart_vrXmitBuffer_7
  assign uart_vrXmitBuffer_7$D_IN =
	     !WILL_FIRE_RL_uart_transmit_buffer_load ||
	     uart_fifoXmit$D_OUT[7] ;
  assign uart_vrXmitBuffer_7$EN =
	     WILL_FIRE_RL_uart_transmit_buffer_load ||
	     WILL_FIRE_RL_uart_transmit_buffer_shift ;

  // submodule s_xactor_f_rd_addr
  assign s_xactor_f_rd_addr$D_IN =
	     { slave_axi_uart_m_arvalid_araddr,
	       slave_axi_uart_m_arvalid_arprot,
	       slave_axi_uart_m_arvalid_aruser,
	       slave_axi_uart_m_arvalid_arlen,
	       slave_axi_uart_m_arvalid_arsize,
	       slave_axi_uart_m_arvalid_arburst,
	       slave_axi_uart_m_arvalid_arlock,
	       slave_axi_uart_m_arvalid_arcache,
	       slave_axi_uart_m_arvalid_arqos,
	       slave_axi_uart_m_arvalid_arregion,
	       slave_axi_uart_m_arvalid_arid } ;
  assign s_xactor_f_rd_addr$ENQ =
	     slave_axi_uart_m_arvalid_arvalid && s_xactor_f_rd_addr$FULL_N ;
  assign s_xactor_f_rd_addr$DEQ =
	     WILL_FIRE_RL_rl_handle_axi4_uart_baud ||
	     WILL_FIRE_RL_rl_handle_rest_axi4_req ||
	     WILL_FIRE_RL_rl_handle_axi4_uart_status ||
	     WILL_FIRE_RL_rl_handle_axi4_uart_read ;
  assign s_xactor_f_rd_addr$CLR = 1'b0 ;

  // submodule s_xactor_f_rd_data
  always@(WILL_FIRE_RL_rl_handle_axi4_uart_read or
	  MUX_s_xactor_f_rd_data$enq_1__VAL_1 or
	  WILL_FIRE_RL_rl_handle_axi4_uart_status or
	  MUX_s_xactor_f_rd_data$enq_1__VAL_2 or
	  WILL_FIRE_RL_rl_handle_axi4_uart_baud or
	  MUX_s_xactor_f_rd_data$enq_1__VAL_3 or
	  WILL_FIRE_RL_rl_handle_rest_axi4_req or
	  MUX_s_xactor_f_rd_data$enq_1__VAL_4)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_rl_handle_axi4_uart_read:
	  s_xactor_f_rd_data$D_IN = MUX_s_xactor_f_rd_data$enq_1__VAL_1;
      WILL_FIRE_RL_rl_handle_axi4_uart_status:
	  s_xactor_f_rd_data$D_IN = MUX_s_xactor_f_rd_data$enq_1__VAL_2;
      WILL_FIRE_RL_rl_handle_axi4_uart_baud:
	  s_xactor_f_rd_data$D_IN = MUX_s_xactor_f_rd_data$enq_1__VAL_3;
      WILL_FIRE_RL_rl_handle_rest_axi4_req:
	  s_xactor_f_rd_data$D_IN = MUX_s_xactor_f_rd_data$enq_1__VAL_4;
      default: s_xactor_f_rd_data$D_IN =
		   81'h0AAAAAAAAAAAAAAAAAAAA /* unspecified value */ ;
    endcase
  end
  assign s_xactor_f_rd_data$ENQ =
	     WILL_FIRE_RL_rl_handle_axi4_uart_read ||
	     WILL_FIRE_RL_rl_handle_axi4_uart_status ||
	     WILL_FIRE_RL_rl_handle_axi4_uart_baud ||
	     WILL_FIRE_RL_rl_handle_rest_axi4_req ;
  assign s_xactor_f_rd_data$DEQ =
	     slave_axi_uart_m_rready_rready && s_xactor_f_rd_data$EMPTY_N ;
  assign s_xactor_f_rd_data$CLR = 1'b0 ;

  // submodule s_xactor_f_wr_addr
  assign s_xactor_f_wr_addr$D_IN =
	     { slave_axi_uart_m_awvalid_awaddr,
	       slave_axi_uart_m_awvalid_awprot,
	       slave_axi_uart_m_awvalid_awuser,
	       slave_axi_uart_m_awvalid_awlen,
	       slave_axi_uart_m_awvalid_awsize,
	       slave_axi_uart_m_awvalid_awburst,
	       slave_axi_uart_m_awvalid_awlock,
	       slave_axi_uart_m_awvalid_awcache,
	       slave_axi_uart_m_awvalid_awqos,
	       slave_axi_uart_m_awvalid_awregion,
	       slave_axi_uart_m_awvalid_awid } ;
  assign s_xactor_f_wr_addr$ENQ =
	     EN_slave_axi_uart_m_awvalid && slave_axi_uart_m_awvalid_awvalid ;
  assign s_xactor_f_wr_addr$DEQ =
	     s_xactor_f_wr_data$EMPTY_N && uart_fifoXmit$FULL_N &&
	     s_xactor_f_wr_resp$FULL_N &&
	     s_xactor_f_wr_addr$EMPTY_N ;
  assign s_xactor_f_wr_addr$CLR = 1'b0 ;

  // submodule s_xactor_f_wr_data
  assign s_xactor_f_wr_data$D_IN =
	     { slave_axi_uart_m_wvalid_wdata,
	       slave_axi_uart_m_wvalid_wstrb,
	       slave_axi_uart_m_wvalid_wid,
	       slave_axi_uart_m_wvalid_wlast } ;
  assign s_xactor_f_wr_data$ENQ =
	     EN_slave_axi_uart_m_wvalid && slave_axi_uart_m_wvalid_wvalid ;
  assign s_xactor_f_wr_data$DEQ =
	     s_xactor_f_wr_data$EMPTY_N && uart_fifoXmit$FULL_N &&
	     s_xactor_f_wr_resp$FULL_N &&
	     s_xactor_f_wr_addr$EMPTY_N ;
  assign s_xactor_f_wr_data$CLR = 1'b0 ;

  // submodule s_xactor_f_wr_resp
  assign s_xactor_f_wr_resp$D_IN =
	     { CASE_s_xactor_f_wr_addrD_OUT_BITS_46_TO_45_0__ETC__q1,
	       s_xactor_f_wr_addr$D_OUT[13:0] } ;
  assign s_xactor_f_wr_resp$ENQ =
	     s_xactor_f_wr_data$EMPTY_N && uart_fifoXmit$FULL_N &&
	     s_xactor_f_wr_resp$FULL_N &&
	     s_xactor_f_wr_addr$EMPTY_N ;
  assign s_xactor_f_wr_resp$DEQ =
	     slave_axi_uart_m_bready_bready && s_xactor_f_wr_resp$EMPTY_N ;
  assign s_xactor_f_wr_resp$CLR = 1'b0 ;

  // submodule uart_baudGen_rBaudCounter
  assign uart_baudGen_rBaudCounter$DATA_A = 16'd1 ;
  assign uart_baudGen_rBaudCounter$DATA_B = 16'h0 ;
  assign uart_baudGen_rBaudCounter$DATA_C = 16'h0 ;
  assign uart_baudGen_rBaudCounter$DATA_F = 16'd0 ;
  assign uart_baudGen_rBaudCounter$ADDA =
	     uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_b_ETC___d30 ;
  assign uart_baudGen_rBaudCounter$ADDB = 1'b0 ;
  assign uart_baudGen_rBaudCounter$SETC = 1'b0 ;
  assign uart_baudGen_rBaudCounter$SETF =
	     CAN_FIRE_RL_uart_baudGen_count_baudtick_16x ;

  // submodule uart_baudGen_rBaudTickCounter
  assign uart_baudGen_rBaudTickCounter$DATA_A = 3'd1 ;
  assign uart_baudGen_rBaudTickCounter$DATA_B = 3'h0 ;
  assign uart_baudGen_rBaudTickCounter$DATA_C = 3'h0 ;
  assign uart_baudGen_rBaudTickCounter$DATA_F = 3'h0 ;
  assign uart_baudGen_rBaudTickCounter$ADDA =
	     CAN_FIRE_RL_uart_baudGen_count_baudtick_16x ;
  assign uart_baudGen_rBaudTickCounter$ADDB = 1'b0 ;
  assign uart_baudGen_rBaudTickCounter$SETC = 1'b0 ;
  assign uart_baudGen_rBaudTickCounter$SETF = 1'b0 ;

  // submodule uart_fifoRecv
  assign uart_fifoRecv$D_IN =
	     { uart_vrRecvBuffer_7,
	       uart_vrRecvBuffer_6,
	       uart_vrRecvBuffer_5,
	       uart_vrRecvBuffer_4,
	       uart_vrRecvBuffer_3,
	       uart_vrRecvBuffer_2,
	       uart_vrRecvBuffer_1,
	       uart_vrRecvBuffer_0 } ;
  assign uart_fifoRecv$ENQ = CAN_FIRE_RL_uart_receive_stop_last_bit ;
  assign uart_fifoRecv$DEQ = CAN_FIRE_RL_rl_handle_axi4_uart_read ;
  assign uart_fifoRecv$CLR = 1'b0 ;

  // submodule uart_fifoXmit
  assign uart_fifoXmit$D_IN = s_xactor_f_wr_data$D_OUT[20:13] ;
  assign uart_fifoXmit$ENQ = uart_fifoXmit_r_enq$whas ;
  assign uart_fifoXmit$DEQ = CAN_FIRE_RL_uart_transmit_buffer_load ;
  assign uart_fifoXmit$CLR = 1'b0 ;

  // remaining internal signals
  assign _dor2uart_pwXmitCellCountReset$EN_wset =
	     WILL_FIRE_RL_uart_transmit_send_stop_bit2 ||
	     WILL_FIRE_RL_uart_transmit_send_stop_bit ||
	     WILL_FIRE_RL_uart_transmit_send_parity_bit ||
	     WILL_FIRE_RL_uart_transmit_wait_1_bit_cell_time ||
	     WILL_FIRE_RL_uart_transmit_send_start_bit ;
  assign uart_baudGen_rBaudCounter_value_PLUS_1_8_ULT_b_ETC___d30 =
	     uart_baudGen_rBaudCounter$Q_OUT + 16'd1 < baud_value ;
  assign x__h3124 = uart_rRecvCellCount + 4'd1 ;
  assign x__h4765 = uart_rRecvBitCount + 4'd1 ;
  assign x__h6559 = uart_rXmitCellCount + 4'd1 ;
  assign x__h6585 = uart_rXmitBitCount + 4'd1 ;
  assign x_rdata__h11373 = { 56'd0, uart_fifoRecv$D_OUT } ;
  assign x_rdata__h11480 = { 60'd0, rg_status } ;
  assign x_rdata__h11570 = { 48'd0, baud_value } ;
  assign z__h7973 = uart_fifoXmit$D_OUT[0] ^ uart_fifoXmit$D_OUT[1] ;
  assign z__h7980 = z__h7973 ^ uart_fifoXmit$D_OUT[2] ;
  assign z__h7987 = z__h7980 ^ uart_fifoXmit$D_OUT[3] ;
  assign z__h7994 = z__h7987 ^ uart_fifoXmit$D_OUT[4] ;
  assign z__h8001 = z__h7994 ^ uart_fifoXmit$D_OUT[5] ;
  assign z__h8008 = z__h8001 ^ uart_fifoXmit$D_OUT[6] ;
  always@(s_xactor_f_wr_addr$D_OUT)
  begin
    case (s_xactor_f_wr_addr$D_OUT[46:45])
      2'd0, 2'd3:
	  CASE_s_xactor_f_wr_addrD_OUT_BITS_46_TO_45_0__ETC__q1 = 2'd0;
      default: CASE_s_xactor_f_wr_addrD_OUT_BITS_46_TO_45_0__ETC__q1 = 2'd2;
    endcase
  end

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        baud_value <= `BSV_ASSIGNMENT_DELAY 16'd130;
	rg_status <= `BSV_ASSIGNMENT_DELAY 4'd0;
	uart_fifoRecv_countReg <= `BSV_ASSIGNMENT_DELAY 5'd0;
	uart_fifoXmit_countReg <= `BSV_ASSIGNMENT_DELAY 5'd0;
	uart_rRecvData <= `BSV_ASSIGNMENT_DELAY 1'd1;
      end
    else
      begin
        if (baud_value$EN)
	  baud_value <= `BSV_ASSIGNMENT_DELAY baud_value$D_IN;
	if (rg_status$EN) rg_status <= `BSV_ASSIGNMENT_DELAY rg_status$D_IN;
	if (uart_fifoRecv_countReg$EN)
	  uart_fifoRecv_countReg <= `BSV_ASSIGNMENT_DELAY
	      uart_fifoRecv_countReg$D_IN;
	if (uart_fifoXmit_countReg$EN)
	  uart_fifoXmit_countReg <= `BSV_ASSIGNMENT_DELAY
	      uart_fifoXmit_countReg$D_IN;
	if (uart_rRecvData$EN)
	  uart_rRecvData <= `BSV_ASSIGNMENT_DELAY uart_rRecvData$D_IN;
      end
    if (uart_vrRecvBuffer_0$EN)
      uart_vrRecvBuffer_0 <= `BSV_ASSIGNMENT_DELAY uart_vrRecvBuffer_0$D_IN;
    if (uart_vrRecvBuffer_1$EN)
      uart_vrRecvBuffer_1 <= `BSV_ASSIGNMENT_DELAY uart_vrRecvBuffer_1$D_IN;
    if (uart_vrRecvBuffer_2$EN)
      uart_vrRecvBuffer_2 <= `BSV_ASSIGNMENT_DELAY uart_vrRecvBuffer_2$D_IN;
    if (uart_vrRecvBuffer_3$EN)
      uart_vrRecvBuffer_3 <= `BSV_ASSIGNMENT_DELAY uart_vrRecvBuffer_3$D_IN;
    if (uart_vrRecvBuffer_4$EN)
      uart_vrRecvBuffer_4 <= `BSV_ASSIGNMENT_DELAY uart_vrRecvBuffer_4$D_IN;
    if (uart_vrRecvBuffer_5$EN)
      uart_vrRecvBuffer_5 <= `BSV_ASSIGNMENT_DELAY uart_vrRecvBuffer_5$D_IN;
    if (uart_vrRecvBuffer_6$EN)
      uart_vrRecvBuffer_6 <= `BSV_ASSIGNMENT_DELAY uart_vrRecvBuffer_6$D_IN;
    if (uart_vrRecvBuffer_7$EN)
      uart_vrRecvBuffer_7 <= `BSV_ASSIGNMENT_DELAY uart_vrRecvBuffer_7$D_IN;
    if (uart_vrXmitBuffer_0$EN)
      uart_vrXmitBuffer_0 <= `BSV_ASSIGNMENT_DELAY uart_vrXmitBuffer_0$D_IN;
    if (uart_vrXmitBuffer_1$EN)
      uart_vrXmitBuffer_1 <= `BSV_ASSIGNMENT_DELAY uart_vrXmitBuffer_1$D_IN;
    if (uart_vrXmitBuffer_2$EN)
      uart_vrXmitBuffer_2 <= `BSV_ASSIGNMENT_DELAY uart_vrXmitBuffer_2$D_IN;
    if (uart_vrXmitBuffer_3$EN)
      uart_vrXmitBuffer_3 <= `BSV_ASSIGNMENT_DELAY uart_vrXmitBuffer_3$D_IN;
    if (uart_vrXmitBuffer_4$EN)
      uart_vrXmitBuffer_4 <= `BSV_ASSIGNMENT_DELAY uart_vrXmitBuffer_4$D_IN;
    if (uart_vrXmitBuffer_5$EN)
      uart_vrXmitBuffer_5 <= `BSV_ASSIGNMENT_DELAY uart_vrXmitBuffer_5$D_IN;
    if (uart_vrXmitBuffer_6$EN)
      uart_vrXmitBuffer_6 <= `BSV_ASSIGNMENT_DELAY uart_vrXmitBuffer_6$D_IN;
    if (uart_vrXmitBuffer_7$EN)
      uart_vrXmitBuffer_7 <= `BSV_ASSIGNMENT_DELAY uart_vrXmitBuffer_7$D_IN;
  end

  always@(posedge CLK or `BSV_RESET_EDGE RST_N)
  if (RST_N == `BSV_RESET_VALUE)
    begin
      uart_rRecvBitCount <= `BSV_ASSIGNMENT_DELAY 4'd0;
      uart_rRecvCellCount <= `BSV_ASSIGNMENT_DELAY 4'd0;
      uart_rRecvParity <= `BSV_ASSIGNMENT_DELAY 1'd0;
      uart_rRecvState <= `BSV_ASSIGNMENT_DELAY 3'd0;
      uart_rXmitBitCount <= `BSV_ASSIGNMENT_DELAY 4'd0;
      uart_rXmitCellCount <= `BSV_ASSIGNMENT_DELAY 4'd0;
      uart_rXmitDataOut <= `BSV_ASSIGNMENT_DELAY 1'd1;
      uart_rXmitParity <= `BSV_ASSIGNMENT_DELAY 1'd0;
      uart_rXmitState <= `BSV_ASSIGNMENT_DELAY 3'd0;
    end
  else
    begin
      if (uart_rRecvBitCount$EN)
	uart_rRecvBitCount <= `BSV_ASSIGNMENT_DELAY uart_rRecvBitCount$D_IN;
      if (uart_rRecvCellCount$EN)
	uart_rRecvCellCount <= `BSV_ASSIGNMENT_DELAY uart_rRecvCellCount$D_IN;
      if (uart_rRecvParity$EN)
	uart_rRecvParity <= `BSV_ASSIGNMENT_DELAY uart_rRecvParity$D_IN;
      if (uart_rRecvState$EN)
	uart_rRecvState <= `BSV_ASSIGNMENT_DELAY uart_rRecvState$D_IN;
      if (uart_rXmitBitCount$EN)
	uart_rXmitBitCount <= `BSV_ASSIGNMENT_DELAY uart_rXmitBitCount$D_IN;
      if (uart_rXmitCellCount$EN)
	uart_rXmitCellCount <= `BSV_ASSIGNMENT_DELAY uart_rXmitCellCount$D_IN;
      if (uart_rXmitDataOut$EN)
	uart_rXmitDataOut <= `BSV_ASSIGNMENT_DELAY uart_rXmitDataOut$D_IN;
      if (uart_rXmitParity$EN)
	uart_rXmitParity <= `BSV_ASSIGNMENT_DELAY uart_rXmitParity$D_IN;
      if (uart_rXmitState$EN)
	uart_rXmitState <= `BSV_ASSIGNMENT_DELAY uart_rXmitState$D_IN;
    end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    baud_value = 16'hAAAA;
    rg_status = 4'hA;
    uart_fifoRecv_countReg = 5'h0A;
    uart_fifoXmit_countReg = 5'h0A;
    uart_rRecvBitCount = 4'hA;
    uart_rRecvCellCount = 4'hA;
    uart_rRecvData = 1'h0;
    uart_rRecvParity = 1'h0;
    uart_rRecvState = 3'h2;
    uart_rXmitBitCount = 4'hA;
    uart_rXmitCellCount = 4'hA;
    uart_rXmitDataOut = 1'h0;
    uart_rXmitParity = 1'h0;
    uart_rXmitState = 3'h2;
    uart_vrRecvBuffer_0 = 1'h0;
    uart_vrRecvBuffer_1 = 1'h0;
    uart_vrRecvBuffer_2 = 1'h0;
    uart_vrRecvBuffer_3 = 1'h0;
    uart_vrRecvBuffer_4 = 1'h0;
    uart_vrRecvBuffer_5 = 1'h0;
    uart_vrRecvBuffer_6 = 1'h0;
    uart_vrRecvBuffer_7 = 1'h0;
    uart_vrXmitBuffer_0 = 1'h0;
    uart_vrXmitBuffer_1 = 1'h0;
    uart_vrXmitBuffer_2 = 1'h0;
    uart_vrXmitBuffer_3 = 1'h0;
    uart_vrXmitBuffer_4 = 1'h0;
    uart_vrXmitBuffer_5 = 1'h0;
    uart_vrXmitBuffer_6 = 1'h0;
    uart_vrXmitBuffer_7 = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkUart_bs

