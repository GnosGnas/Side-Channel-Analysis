//
// Generated by Bluespec Compiler, version 2021.07-1-gaf77efcd (build af77efcd)
//
// On Mon Dec  6 14:10:13 IST 2021
//
//
// Ports:
// Name                         I/O  size props
// correlator_master_AWVALID      O     1 reg
// correlator_master_AWADDR       O    32 reg
// correlator_master_AWPROT       O     3 reg
// correlator_master_AWLEN        O     8 reg
// correlator_master_AWSIZE       O     3 reg
// correlator_master_AWBURST      O     2 reg
// correlator_master_AWID         O     4 reg
// correlator_master_WVALID       O     1 reg
// correlator_master_WDATA        O    64 reg
// correlator_master_WSTRB        O     8 reg
// correlator_master_WLAST        O     1 reg
// correlator_master_WID          O     4 reg
// correlator_master_BREADY       O     1 reg
// correlator_master_ARVALID      O     1 reg
// correlator_master_ARADDR       O    32 reg
// correlator_master_ARPROT       O     3 reg
// correlator_master_ARLEN        O     8 reg
// correlator_master_ARSIZE       O     3 reg
// correlator_master_ARBURST      O     2 reg
// correlator_master_ARID         O     4 reg
// correlator_master_RREADY       O     1 reg
// gpio_io_gpio_out               O    32 reg
// RDY_gpio_io_gpio_out           O     1 const
// gpio_io_gpio_out_en            O    32 reg
// RDY_gpio_io_gpio_out_en        O     1 const
// RDY_interrupts                 O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// correlator_master_AWREADY      I     1
// correlator_master_WREADY       I     1
// correlator_master_BVALID       I     1
// correlator_master_BRESP        I     2 reg
// correlator_master_BID          I     4 reg
// correlator_master_ARREADY      I     1
// correlator_master_RVALID       I     1
// correlator_master_RRESP        I     2 reg
// correlator_master_RDATA        I    64 reg
// correlator_master_RLAST        I     1 reg
// correlator_master_RID          I     4 reg
// gpio_io_gpio_in_inp            I    32 reg
// interrupts_inp                 I     8
// boot_option_option             I     1 unused
// EN_interrupts                  I     1 inhigh
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkTbSoc(CLK,
	       RST_N,

	       correlator_master_AWVALID,

	       correlator_master_AWADDR,

	       correlator_master_AWPROT,

	       correlator_master_AWLEN,

	       correlator_master_AWSIZE,

	       correlator_master_AWBURST,

	       correlator_master_AWID,

	       correlator_master_AWREADY,

	       correlator_master_WVALID,

	       correlator_master_WDATA,

	       correlator_master_WSTRB,

	       correlator_master_WLAST,

	       correlator_master_WID,

	       correlator_master_WREADY,

	       correlator_master_BVALID,
	       correlator_master_BRESP,
	       correlator_master_BID,

	       correlator_master_BREADY,

	       correlator_master_ARVALID,

	       correlator_master_ARADDR,

	       correlator_master_ARPROT,

	       correlator_master_ARLEN,

	       correlator_master_ARSIZE,

	       correlator_master_ARBURST,

	       correlator_master_ARID,

	       correlator_master_ARREADY,

	       correlator_master_RVALID,
	       correlator_master_RRESP,
	       correlator_master_RDATA,
	       correlator_master_RLAST,
	       correlator_master_RID,

	       correlator_master_RREADY,

	       gpio_io_gpio_in_inp,

	       gpio_io_gpio_out,
	       RDY_gpio_io_gpio_out,

	       gpio_io_gpio_out_en,
	       RDY_gpio_io_gpio_out_en,

	       interrupts_inp,
	       EN_interrupts,
	       RDY_interrupts,

	       boot_option_option);
  input  CLK;
  input  RST_N;

  // value method correlator_master_m_awvalid
  output correlator_master_AWVALID;

  // value method correlator_master_m_awaddr
  output [31 : 0] correlator_master_AWADDR;

  // value method correlator_master_m_awuser

  // value method correlator_master_m_awprot
  output [2 : 0] correlator_master_AWPROT;

  // value method correlator_master_m_awlen
  output [7 : 0] correlator_master_AWLEN;

  // value method correlator_master_m_awsize
  output [2 : 0] correlator_master_AWSIZE;

  // value method correlator_master_m_awburst
  output [1 : 0] correlator_master_AWBURST;

  // value method correlator_master_m_awid
  output [3 : 0] correlator_master_AWID;

  // action method correlator_master_m_awready
  input  correlator_master_AWREADY;

  // value method correlator_master_m_wvalid
  output correlator_master_WVALID;

  // value method correlator_master_m_wdata
  output [63 : 0] correlator_master_WDATA;

  // value method correlator_master_m_wstrb
  output [7 : 0] correlator_master_WSTRB;

  // value method correlator_master_m_wlast
  output correlator_master_WLAST;

  // value method correlator_master_m_wid
  output [3 : 0] correlator_master_WID;

  // action method correlator_master_m_wready
  input  correlator_master_WREADY;

  // action method correlator_master_m_bvalid
  input  correlator_master_BVALID;
  input  [1 : 0] correlator_master_BRESP;
  input  [3 : 0] correlator_master_BID;

  // value method correlator_master_m_bready
  output correlator_master_BREADY;

  // value method correlator_master_m_arvalid
  output correlator_master_ARVALID;

  // value method correlator_master_m_araddr
  output [31 : 0] correlator_master_ARADDR;

  // value method correlator_master_m_aruser

  // value method correlator_master_m_arprot
  output [2 : 0] correlator_master_ARPROT;

  // value method correlator_master_m_arlen
  output [7 : 0] correlator_master_ARLEN;

  // value method correlator_master_m_arsize
  output [2 : 0] correlator_master_ARSIZE;

  // value method correlator_master_m_arburst
  output [1 : 0] correlator_master_ARBURST;

  // value method correlator_master_m_arid
  output [3 : 0] correlator_master_ARID;

  // action method correlator_master_m_arready
  input  correlator_master_ARREADY;

  // action method correlator_master_m_rvalid
  input  correlator_master_RVALID;
  input  [1 : 0] correlator_master_RRESP;
  input  [63 : 0] correlator_master_RDATA;
  input  correlator_master_RLAST;
  input  [3 : 0] correlator_master_RID;

  // value method correlator_master_m_rready
  output correlator_master_RREADY;

  // action method gpio_io_gpio_in
  input  [31 : 0] gpio_io_gpio_in_inp;

  // value method gpio_io_gpio_out
  output [31 : 0] gpio_io_gpio_out;
  output RDY_gpio_io_gpio_out;

  // value method gpio_io_gpio_out_en
  output [31 : 0] gpio_io_gpio_out_en;
  output RDY_gpio_io_gpio_out_en;

  // action method interrupts
  input  [7 : 0] interrupts_inp;
  input  EN_interrupts;
  output RDY_interrupts;

  // action method boot_option
  input  boot_option_option;

  // signals for module outputs
  wire [63 : 0] correlator_master_WDATA;
  wire [31 : 0] correlator_master_ARADDR,
		correlator_master_AWADDR,
		gpio_io_gpio_out,
		gpio_io_gpio_out_en;
  wire [7 : 0] correlator_master_ARLEN,
	       correlator_master_AWLEN,
	       correlator_master_WSTRB;
  wire [3 : 0] correlator_master_ARID,
	       correlator_master_AWID,
	       correlator_master_WID;
  wire [2 : 0] correlator_master_ARPROT,
	       correlator_master_ARSIZE,
	       correlator_master_AWPROT,
	       correlator_master_AWSIZE;
  wire [1 : 0] correlator_master_ARBURST, correlator_master_AWBURST;
  wire RDY_gpio_io_gpio_out,
       RDY_gpio_io_gpio_out_en,
       RDY_interrupts,
       correlator_master_ARVALID,
       correlator_master_AWVALID,
       correlator_master_BREADY,
       correlator_master_RREADY,
       correlator_master_WLAST,
       correlator_master_WVALID;

  // inlined wires
  wire rg_read_rx_1_whas,
       uart_uart_fifoRecv_r_deq_whas,
       uart_uart_pwRecvCellCountReset_whas,
       uart_uart_pwRecvEnableBitCount_whas,
       uart_uart_pwRecvResetBitCount_whas,
       uart_uart_pwXmitCellCountReset_whas,
       uart_uart_pwXmitEnableBitCount_whas,
       uart_uart_pwXmitLoadBuffer_whas;

  // register delayed_actor
  reg [4 : 0] delayed_actor;
  wire [4 : 0] delayed_actor_D_IN;
  wire delayed_actor_EN;

  // register delayed_actor2
  reg [4 : 0] delayed_actor2;
  wire [4 : 0] delayed_actor2_D_IN;
  wire delayed_actor2_EN;

  // register delayed_actor3
  reg [4 : 0] delayed_actor3;
  wire [4 : 0] delayed_actor3_D_IN;
  wire delayed_actor3_EN;

  // register delayed_actor4
  reg [4 : 0] delayed_actor4;
  wire [4 : 0] delayed_actor4_D_IN;
  wire delayed_actor4_EN;

  // register delayed_actor5
  reg [4 : 0] delayed_actor5;
  wire [4 : 0] delayed_actor5_D_IN;
  wire delayed_actor5_EN;

  // register dump
  reg [31 : 0] dump;
  wire [31 : 0] dump_D_IN;
  wire dump_EN;

  // register dump1
  reg [31 : 0] dump1;
  wire [31 : 0] dump1_D_IN;
  wire dump1_EN;

  // register rg_client_fd
  reg [31 : 0] rg_client_fd;
  wire [31 : 0] rg_client_fd_D_IN;
  wire rg_client_fd_EN;

  // register rg_cnt
  reg [4 : 0] rg_cnt;
  wire [4 : 0] rg_cnt_D_IN;
  wire rg_cnt_EN;

  // register rg_end_sim
  reg rg_end_sim;
  wire rg_end_sim_D_IN, rg_end_sim_EN;

  // register rg_initial
  reg rg_initial;
  wire rg_initial_D_IN, rg_initial_EN;

  // register rg_read_rx
  reg rg_read_rx;
  wire rg_read_rx_D_IN, rg_read_rx_EN;

  // register uart_baud_value
  reg [15 : 0] uart_baud_value;
  wire [15 : 0] uart_baud_value_D_IN;
  wire uart_baud_value_EN;

  // register uart_uart_fifoRecv_countReg
  reg [4 : 0] uart_uart_fifoRecv_countReg;
  wire [4 : 0] uart_uart_fifoRecv_countReg_D_IN;
  wire uart_uart_fifoRecv_countReg_EN;

  // register uart_uart_fifoXmit_countReg
  reg [4 : 0] uart_uart_fifoXmit_countReg;
  wire [4 : 0] uart_uart_fifoXmit_countReg_D_IN;
  wire uart_uart_fifoXmit_countReg_EN;

  // register uart_uart_rRecvBitCount
  reg [3 : 0] uart_uart_rRecvBitCount;
  wire [3 : 0] uart_uart_rRecvBitCount_D_IN;
  wire uart_uart_rRecvBitCount_EN;

  // register uart_uart_rRecvCellCount
  reg [3 : 0] uart_uart_rRecvCellCount;
  wire [3 : 0] uart_uart_rRecvCellCount_D_IN;
  wire uart_uart_rRecvCellCount_EN;

  // register uart_uart_rRecvData
  reg uart_uart_rRecvData;
  wire uart_uart_rRecvData_D_IN, uart_uart_rRecvData_EN;

  // register uart_uart_rRecvParity
  reg uart_uart_rRecvParity;
  wire uart_uart_rRecvParity_D_IN, uart_uart_rRecvParity_EN;

  // register uart_uart_rRecvState
  reg [2 : 0] uart_uart_rRecvState;
  reg [2 : 0] uart_uart_rRecvState_D_IN;
  wire uart_uart_rRecvState_EN;

  // register uart_uart_rXmitBitCount
  reg [3 : 0] uart_uart_rXmitBitCount;
  wire [3 : 0] uart_uart_rXmitBitCount_D_IN;
  wire uart_uart_rXmitBitCount_EN;

  // register uart_uart_rXmitCellCount
  reg [3 : 0] uart_uart_rXmitCellCount;
  wire [3 : 0] uart_uart_rXmitCellCount_D_IN;
  wire uart_uart_rXmitCellCount_EN;

  // register uart_uart_rXmitDataOut
  reg uart_uart_rXmitDataOut;
  reg uart_uart_rXmitDataOut_D_IN;
  wire uart_uart_rXmitDataOut_EN;

  // register uart_uart_rXmitParity
  reg uart_uart_rXmitParity;
  wire uart_uart_rXmitParity_D_IN, uart_uart_rXmitParity_EN;

  // register uart_uart_rXmitState
  reg [2 : 0] uart_uart_rXmitState;
  reg [2 : 0] uart_uart_rXmitState_D_IN;
  wire uart_uart_rXmitState_EN;

  // register uart_uart_vrRecvBuffer_0
  reg uart_uart_vrRecvBuffer_0;
  wire uart_uart_vrRecvBuffer_0_D_IN, uart_uart_vrRecvBuffer_0_EN;

  // register uart_uart_vrRecvBuffer_1
  reg uart_uart_vrRecvBuffer_1;
  wire uart_uart_vrRecvBuffer_1_D_IN, uart_uart_vrRecvBuffer_1_EN;

  // register uart_uart_vrRecvBuffer_2
  reg uart_uart_vrRecvBuffer_2;
  wire uart_uart_vrRecvBuffer_2_D_IN, uart_uart_vrRecvBuffer_2_EN;

  // register uart_uart_vrRecvBuffer_3
  reg uart_uart_vrRecvBuffer_3;
  wire uart_uart_vrRecvBuffer_3_D_IN, uart_uart_vrRecvBuffer_3_EN;

  // register uart_uart_vrRecvBuffer_4
  reg uart_uart_vrRecvBuffer_4;
  wire uart_uart_vrRecvBuffer_4_D_IN, uart_uart_vrRecvBuffer_4_EN;

  // register uart_uart_vrRecvBuffer_5
  reg uart_uart_vrRecvBuffer_5;
  wire uart_uart_vrRecvBuffer_5_D_IN, uart_uart_vrRecvBuffer_5_EN;

  // register uart_uart_vrRecvBuffer_6
  reg uart_uart_vrRecvBuffer_6;
  wire uart_uart_vrRecvBuffer_6_D_IN, uart_uart_vrRecvBuffer_6_EN;

  // register uart_uart_vrRecvBuffer_7
  reg uart_uart_vrRecvBuffer_7;
  wire uart_uart_vrRecvBuffer_7_D_IN, uart_uart_vrRecvBuffer_7_EN;

  // register uart_uart_vrXmitBuffer_0
  reg uart_uart_vrXmitBuffer_0;
  wire uart_uart_vrXmitBuffer_0_D_IN, uart_uart_vrXmitBuffer_0_EN;

  // register uart_uart_vrXmitBuffer_1
  reg uart_uart_vrXmitBuffer_1;
  wire uart_uart_vrXmitBuffer_1_D_IN, uart_uart_vrXmitBuffer_1_EN;

  // register uart_uart_vrXmitBuffer_2
  reg uart_uart_vrXmitBuffer_2;
  wire uart_uart_vrXmitBuffer_2_D_IN, uart_uart_vrXmitBuffer_2_EN;

  // register uart_uart_vrXmitBuffer_3
  reg uart_uart_vrXmitBuffer_3;
  wire uart_uart_vrXmitBuffer_3_D_IN, uart_uart_vrXmitBuffer_3_EN;

  // register uart_uart_vrXmitBuffer_4
  reg uart_uart_vrXmitBuffer_4;
  wire uart_uart_vrXmitBuffer_4_D_IN, uart_uart_vrXmitBuffer_4_EN;

  // register uart_uart_vrXmitBuffer_5
  reg uart_uart_vrXmitBuffer_5;
  wire uart_uart_vrXmitBuffer_5_D_IN, uart_uart_vrXmitBuffer_5_EN;

  // register uart_uart_vrXmitBuffer_6
  reg uart_uart_vrXmitBuffer_6;
  wire uart_uart_vrXmitBuffer_6_D_IN, uart_uart_vrXmitBuffer_6_EN;

  // register uart_uart_vrXmitBuffer_7
  reg uart_uart_vrXmitBuffer_7;
  wire uart_uart_vrXmitBuffer_7_D_IN, uart_uart_vrXmitBuffer_7_EN;

  // ports of submodule soc
  wire [167 : 0] soc_io_dump_get;
  wire [63 : 0] soc_correlator_master_RDATA, soc_correlator_master_WDATA;
  wire [31 : 0] soc_correlator_master_ARADDR,
		soc_correlator_master_AWADDR,
		soc_gpio_io_gpio_in_inp,
		soc_gpio_io_gpio_out,
		soc_gpio_io_gpio_out_en;
  wire [7 : 0] soc_correlator_master_ARLEN,
	       soc_correlator_master_AWLEN,
	       soc_correlator_master_WSTRB,
	       soc_interrupts_inp;
  wire [3 : 0] soc_correlator_master_ARID,
	       soc_correlator_master_AWID,
	       soc_correlator_master_BID,
	       soc_correlator_master_RID,
	       soc_correlator_master_WID;
  wire [2 : 0] soc_correlator_master_ARPROT,
	       soc_correlator_master_ARSIZE,
	       soc_correlator_master_AWPROT,
	       soc_correlator_master_AWSIZE;
  wire [1 : 0] soc_correlator_master_ARBURST,
	       soc_correlator_master_AWBURST,
	       soc_correlator_master_BRESP,
	       soc_correlator_master_RRESP;
  wire soc_EN_io_dump_get,
       soc_RDY_io_dump_get,
       soc_correlator_master_ARREADY,
       soc_correlator_master_ARVALID,
       soc_correlator_master_AWREADY,
       soc_correlator_master_AWVALID,
       soc_correlator_master_BREADY,
       soc_correlator_master_BVALID,
       soc_correlator_master_RLAST,
       soc_correlator_master_RREADY,
       soc_correlator_master_RVALID,
       soc_correlator_master_WLAST,
       soc_correlator_master_WREADY,
       soc_correlator_master_WVALID,
       soc_uart_io_SIN,
       soc_uart_io_SOUT,
       soc_wire_tdi_tdi_in,
       soc_wire_tdo,
       soc_wire_tms_tms_in;

  // ports of submodule tck_clk
  wire tck_clk_CLK_IN,
       tck_clk_CLK_IN_EN,
       tck_clk_CLK_OUT,
       tck_clk_COND_IN,
       tck_clk_COND_IN_EN;

  // ports of submodule trst
  wire trst_ASSERT_IN, trst_OUT_RST;

  // ports of submodule uart_uart_baudGen_rBaudCounter
  wire [15 : 0] uart_uart_baudGen_rBaudCounter_DATA_A,
		uart_uart_baudGen_rBaudCounter_DATA_B,
		uart_uart_baudGen_rBaudCounter_DATA_C,
		uart_uart_baudGen_rBaudCounter_DATA_F,
		uart_uart_baudGen_rBaudCounter_Q_OUT;
  wire uart_uart_baudGen_rBaudCounter_ADDA,
       uart_uart_baudGen_rBaudCounter_ADDB,
       uart_uart_baudGen_rBaudCounter_SETC,
       uart_uart_baudGen_rBaudCounter_SETF;

  // ports of submodule uart_uart_baudGen_rBaudTickCounter
  wire [2 : 0] uart_uart_baudGen_rBaudTickCounter_DATA_A,
	       uart_uart_baudGen_rBaudTickCounter_DATA_B,
	       uart_uart_baudGen_rBaudTickCounter_DATA_C,
	       uart_uart_baudGen_rBaudTickCounter_DATA_F,
	       uart_uart_baudGen_rBaudTickCounter_Q_OUT;
  wire uart_uart_baudGen_rBaudTickCounter_ADDA,
       uart_uart_baudGen_rBaudTickCounter_ADDB,
       uart_uart_baudGen_rBaudTickCounter_SETC,
       uart_uart_baudGen_rBaudTickCounter_SETF;

  // ports of submodule uart_uart_fifoRecv
  wire [7 : 0] uart_uart_fifoRecv_D_IN, uart_uart_fifoRecv_D_OUT;
  wire uart_uart_fifoRecv_CLR,
       uart_uart_fifoRecv_DEQ,
       uart_uart_fifoRecv_EMPTY_N,
       uart_uart_fifoRecv_ENQ,
       uart_uart_fifoRecv_FULL_N;

  // ports of submodule uart_uart_fifoXmit
  wire [7 : 0] uart_uart_fifoXmit_D_IN, uart_uart_fifoXmit_D_OUT;
  wire uart_uart_fifoXmit_CLR,
       uart_uart_fifoXmit_DEQ,
       uart_uart_fifoXmit_EMPTY_N,
       uart_uart_fifoXmit_ENQ,
       uart_uart_fifoXmit_FULL_N;

  // rule scheduling signals
  wire CAN_FIRE_RL_check_if_character_present,
       CAN_FIRE_RL_connect_jtag_io,
       CAN_FIRE_RL_connect_uart_in,
       CAN_FIRE_RL_connect_uart_out,
       CAN_FIRE_RL_display_eol,
       CAN_FIRE_RL_open_file_app,
       CAN_FIRE_RL_open_file_rtldump,
       CAN_FIRE_RL_rg_read_rx__dreg_update,
       CAN_FIRE_RL_rl_get_frame,
       CAN_FIRE_RL_rl_initial,
       CAN_FIRE_RL_rl_wr_tdo,
       CAN_FIRE_RL_uart_capture_status,
       CAN_FIRE_RL_uart_uart_baudGen_assert_2x_baud_tick,
       CAN_FIRE_RL_uart_uart_baudGen_baud_count_wire,
       CAN_FIRE_RL_uart_uart_baudGen_baud_tick_count_wire,
       CAN_FIRE_RL_uart_uart_baudGen_count_baudtick_16x,
       CAN_FIRE_RL_uart_uart_baud_generator_clock_enable,
       CAN_FIRE_RL_uart_uart_fifoRecv__updateLevelCounter,
       CAN_FIRE_RL_uart_uart_fifoXmit__updateLevelCounter,
       CAN_FIRE_RL_uart_uart_receive_bit_cell_time_counter,
       CAN_FIRE_RL_uart_uart_receive_bit_counter,
       CAN_FIRE_RL_uart_uart_receive_buffer_shift,
       CAN_FIRE_RL_uart_uart_receive_find_center_of_bit_cell,
       CAN_FIRE_RL_uart_uart_receive_parity_bit,
       CAN_FIRE_RL_uart_uart_receive_sample_pin,
       CAN_FIRE_RL_uart_uart_receive_stop_first_bit,
       CAN_FIRE_RL_uart_uart_receive_stop_last_bit,
       CAN_FIRE_RL_uart_uart_receive_wait_bit_cell_time_for_sample,
       CAN_FIRE_RL_uart_uart_receive_wait_for_start_bit,
       CAN_FIRE_RL_uart_uart_transmit_bit_cell_time_counter,
       CAN_FIRE_RL_uart_uart_transmit_bit_counter,
       CAN_FIRE_RL_uart_uart_transmit_buffer_load,
       CAN_FIRE_RL_uart_uart_transmit_buffer_shift,
       CAN_FIRE_RL_uart_uart_transmit_send_parity_bit,
       CAN_FIRE_RL_uart_uart_transmit_send_start_bit,
       CAN_FIRE_RL_uart_uart_transmit_send_stop_bit,
       CAN_FIRE_RL_uart_uart_transmit_send_stop_bit1_5,
       CAN_FIRE_RL_uart_uart_transmit_send_stop_bit2,
       CAN_FIRE_RL_uart_uart_transmit_shift_next_bit,
       CAN_FIRE_RL_uart_uart_transmit_wait_1_bit_cell_time,
       CAN_FIRE_RL_uart_uart_transmit_wait_for_start_command,
       CAN_FIRE_RL_write_dump_file,
       CAN_FIRE_RL_write_received_character,
       CAN_FIRE_boot_option,
       CAN_FIRE_correlator_master_m_arready,
       CAN_FIRE_correlator_master_m_awready,
       CAN_FIRE_correlator_master_m_bvalid,
       CAN_FIRE_correlator_master_m_rvalid,
       CAN_FIRE_correlator_master_m_wready,
       CAN_FIRE_gpio_io_gpio_in,
       CAN_FIRE_interrupts,
       WILL_FIRE_RL_check_if_character_present,
       WILL_FIRE_RL_connect_jtag_io,
       WILL_FIRE_RL_connect_uart_in,
       WILL_FIRE_RL_connect_uart_out,
       WILL_FIRE_RL_display_eol,
       WILL_FIRE_RL_open_file_app,
       WILL_FIRE_RL_open_file_rtldump,
       WILL_FIRE_RL_rg_read_rx__dreg_update,
       WILL_FIRE_RL_rl_get_frame,
       WILL_FIRE_RL_rl_initial,
       WILL_FIRE_RL_rl_wr_tdo,
       WILL_FIRE_RL_uart_capture_status,
       WILL_FIRE_RL_uart_uart_baudGen_assert_2x_baud_tick,
       WILL_FIRE_RL_uart_uart_baudGen_baud_count_wire,
       WILL_FIRE_RL_uart_uart_baudGen_baud_tick_count_wire,
       WILL_FIRE_RL_uart_uart_baudGen_count_baudtick_16x,
       WILL_FIRE_RL_uart_uart_baud_generator_clock_enable,
       WILL_FIRE_RL_uart_uart_fifoRecv__updateLevelCounter,
       WILL_FIRE_RL_uart_uart_fifoXmit__updateLevelCounter,
       WILL_FIRE_RL_uart_uart_receive_bit_cell_time_counter,
       WILL_FIRE_RL_uart_uart_receive_bit_counter,
       WILL_FIRE_RL_uart_uart_receive_buffer_shift,
       WILL_FIRE_RL_uart_uart_receive_find_center_of_bit_cell,
       WILL_FIRE_RL_uart_uart_receive_parity_bit,
       WILL_FIRE_RL_uart_uart_receive_sample_pin,
       WILL_FIRE_RL_uart_uart_receive_stop_first_bit,
       WILL_FIRE_RL_uart_uart_receive_stop_last_bit,
       WILL_FIRE_RL_uart_uart_receive_wait_bit_cell_time_for_sample,
       WILL_FIRE_RL_uart_uart_receive_wait_for_start_bit,
       WILL_FIRE_RL_uart_uart_transmit_bit_cell_time_counter,
       WILL_FIRE_RL_uart_uart_transmit_bit_counter,
       WILL_FIRE_RL_uart_uart_transmit_buffer_load,
       WILL_FIRE_RL_uart_uart_transmit_buffer_shift,
       WILL_FIRE_RL_uart_uart_transmit_send_parity_bit,
       WILL_FIRE_RL_uart_uart_transmit_send_start_bit,
       WILL_FIRE_RL_uart_uart_transmit_send_stop_bit,
       WILL_FIRE_RL_uart_uart_transmit_send_stop_bit1_5,
       WILL_FIRE_RL_uart_uart_transmit_send_stop_bit2,
       WILL_FIRE_RL_uart_uart_transmit_shift_next_bit,
       WILL_FIRE_RL_uart_uart_transmit_wait_1_bit_cell_time,
       WILL_FIRE_RL_uart_uart_transmit_wait_for_start_command,
       WILL_FIRE_RL_write_dump_file,
       WILL_FIRE_RL_write_received_character,
       WILL_FIRE_boot_option,
       WILL_FIRE_correlator_master_m_arready,
       WILL_FIRE_correlator_master_m_awready,
       WILL_FIRE_correlator_master_m_bvalid,
       WILL_FIRE_correlator_master_m_rvalid,
       WILL_FIRE_correlator_master_m_wready,
       WILL_FIRE_gpio_io_gpio_in,
       WILL_FIRE_interrupts;

  // inputs to muxes for submodule ports
  reg [2 : 0] MUX_uart_uart_rRecvState_write_1__VAL_3;
  wire [2 : 0] MUX_uart_uart_rRecvState_write_1__VAL_1,
	       MUX_uart_uart_rRecvState_write_1__VAL_2,
	       MUX_uart_uart_rRecvState_write_1__VAL_4,
	       MUX_uart_uart_rXmitState_write_1__VAL_1,
	       MUX_uart_uart_rXmitState_write_1__VAL_2,
	       MUX_uart_uart_rXmitState_write_1__VAL_3,
	       MUX_uart_uart_rXmitState_write_1__VAL_4,
	       MUX_uart_uart_rXmitState_write_1__VAL_5,
	       MUX_uart_uart_rXmitState_write_1__VAL_6,
	       MUX_uart_uart_rXmitState_write_1__VAL_7;
  wire MUX_uart_uart_rRecvState_write_1__SEL_6,
       MUX_uart_uart_rXmitDataOut_write_1__SEL_1,
       MUX_uart_uart_rXmitDataOut_write_1__SEL_2,
       MUX_uart_uart_rXmitDataOut_write_1__SEL_3;

  // declarations used by system tasks
  // synopsys translate_off
  reg [63 : 0] v__h11693;
  reg TASK_testplusargs___d165;
  reg TASK_testplusargs___d166;
  reg TASK_testplusargs___d167;
  reg [63 : 0] v__h11763;
  reg TASK_testplusargs___d174;
  reg [31 : 0] TASK_fopen___d175;
  reg TASK_testplusargs___d178;
  reg TASK_testplusargs___d179;
  reg TASK_testplusargs___d180;
  reg [63 : 0] v__h12052;
  reg [31 : 0] TASK_fopen___d186;
  reg TASK_testplusargs___d188;
  reg TASK_testplusargs___d189;
  reg TASK_testplusargs___d190;
  reg [63 : 0] v__h12464;
  reg TASK_testplusargs___d216;
  reg [31 : 0] b__h16357;
  reg [7 : 0] TASK_get_frame___d244;
  reg TASK_fopen_75_EQ_0_76_AND_TASK_testplusargs_78_ETC___d183;
  reg TASK_fopen_86_EQ_0_87_AND_TASK_testplusargs_88_ETC___d193;
  // synopsys translate_on

  // remaining internal signals
  wire [63 : 0] data__h13998;
  wire [3 : 0] x__h3566, x__h5270, x__h7026, x__h7052, x__read__h11422;
  wire _dor2uart_uart_pwXmitCellCountReset_EN_wset,
       rg_cnt_72_ULT_5___d173,
       uart_uart_baudGen_rBaudCounter_value_PLUS_1_8__ETC___d30,
       z__h8509,
       z__h8516,
       z__h8523,
       z__h8530,
       z__h8537,
       z__h8544;

  // value method correlator_master_m_awvalid
  assign correlator_master_AWVALID = soc_correlator_master_AWVALID ;

  // value method correlator_master_m_awaddr
  assign correlator_master_AWADDR = soc_correlator_master_AWADDR ;

  // value method correlator_master_m_awprot
  assign correlator_master_AWPROT = soc_correlator_master_AWPROT ;

  // value method correlator_master_m_awlen
  assign correlator_master_AWLEN = soc_correlator_master_AWLEN ;

  // value method correlator_master_m_awsize
  assign correlator_master_AWSIZE = soc_correlator_master_AWSIZE ;

  // value method correlator_master_m_awburst
  assign correlator_master_AWBURST = soc_correlator_master_AWBURST ;

  // value method correlator_master_m_awid
  assign correlator_master_AWID = soc_correlator_master_AWID ;

  // action method correlator_master_m_awready
  assign CAN_FIRE_correlator_master_m_awready = 1'd1 ;
  assign WILL_FIRE_correlator_master_m_awready = 1'd1 ;

  // value method correlator_master_m_wvalid
  assign correlator_master_WVALID = soc_correlator_master_WVALID ;

  // value method correlator_master_m_wdata
  assign correlator_master_WDATA = soc_correlator_master_WDATA ;

  // value method correlator_master_m_wstrb
  assign correlator_master_WSTRB = soc_correlator_master_WSTRB ;

  // value method correlator_master_m_wlast
  assign correlator_master_WLAST = soc_correlator_master_WLAST ;

  // value method correlator_master_m_wid
  assign correlator_master_WID = soc_correlator_master_WID ;

  // action method correlator_master_m_wready
  assign CAN_FIRE_correlator_master_m_wready = 1'd1 ;
  assign WILL_FIRE_correlator_master_m_wready = 1'd1 ;

  // action method correlator_master_m_bvalid
  assign CAN_FIRE_correlator_master_m_bvalid = 1'd1 ;
  assign WILL_FIRE_correlator_master_m_bvalid = 1'd1 ;

  // value method correlator_master_m_bready
  assign correlator_master_BREADY = soc_correlator_master_BREADY ;

  // value method correlator_master_m_arvalid
  assign correlator_master_ARVALID = soc_correlator_master_ARVALID ;

  // value method correlator_master_m_araddr
  assign correlator_master_ARADDR = soc_correlator_master_ARADDR ;

  // value method correlator_master_m_arprot
  assign correlator_master_ARPROT = soc_correlator_master_ARPROT ;

  // value method correlator_master_m_arlen
  assign correlator_master_ARLEN = soc_correlator_master_ARLEN ;

  // value method correlator_master_m_arsize
  assign correlator_master_ARSIZE = soc_correlator_master_ARSIZE ;

  // value method correlator_master_m_arburst
  assign correlator_master_ARBURST = soc_correlator_master_ARBURST ;

  // value method correlator_master_m_arid
  assign correlator_master_ARID = soc_correlator_master_ARID ;

  // action method correlator_master_m_arready
  assign CAN_FIRE_correlator_master_m_arready = 1'd1 ;
  assign WILL_FIRE_correlator_master_m_arready = 1'd1 ;

  // action method correlator_master_m_rvalid
  assign CAN_FIRE_correlator_master_m_rvalid = 1'd1 ;
  assign WILL_FIRE_correlator_master_m_rvalid = 1'd1 ;

  // value method correlator_master_m_rready
  assign correlator_master_RREADY = soc_correlator_master_RREADY ;

  // action method gpio_io_gpio_in
  assign CAN_FIRE_gpio_io_gpio_in = 1'd1 ;
  assign WILL_FIRE_gpio_io_gpio_in = 1'd1 ;

  // value method gpio_io_gpio_out
  assign gpio_io_gpio_out = soc_gpio_io_gpio_out ;
  assign RDY_gpio_io_gpio_out = 1'd1 ;

  // value method gpio_io_gpio_out_en
  assign gpio_io_gpio_out_en = soc_gpio_io_gpio_out_en ;
  assign RDY_gpio_io_gpio_out_en = 1'd1 ;

  // action method interrupts
  assign RDY_interrupts = 1'd1 ;
  assign CAN_FIRE_interrupts = 1'd1 ;
  assign WILL_FIRE_interrupts = EN_interrupts ;

  // action method boot_option
  assign CAN_FIRE_boot_option = 1'd1 ;
  assign WILL_FIRE_boot_option = 1'd1 ;

  // submodule soc
  mkSoc soc(.CLK_tck_clk(tck_clk_CLK_OUT),
	    .RST_N_trst(trst_OUT_RST),
	    .resetpc(64'h0000000080000000),
	    .CLK(CLK),
	    .RST_N(RST_N),
	    .correlator_master_ARREADY(soc_correlator_master_ARREADY),
	    .correlator_master_AWREADY(soc_correlator_master_AWREADY),
	    .correlator_master_BID(soc_correlator_master_BID),
	    .correlator_master_BRESP(soc_correlator_master_BRESP),
	    .correlator_master_BVALID(soc_correlator_master_BVALID),
	    .correlator_master_RDATA(soc_correlator_master_RDATA),
	    .correlator_master_RID(soc_correlator_master_RID),
	    .correlator_master_RLAST(soc_correlator_master_RLAST),
	    .correlator_master_RRESP(soc_correlator_master_RRESP),
	    .correlator_master_RVALID(soc_correlator_master_RVALID),
	    .correlator_master_WREADY(soc_correlator_master_WREADY),
	    .gpio_io_gpio_in_inp(soc_gpio_io_gpio_in_inp),
	    .interrupts_inp(soc_interrupts_inp),
	    .uart_io_SIN(soc_uart_io_SIN),
	    .wire_tdi_tdi_in(soc_wire_tdi_tdi_in),
	    .wire_tms_tms_in(soc_wire_tms_tms_in),
	    .EN_io_dump_get(soc_EN_io_dump_get),
	    .correlator_master_AWVALID(soc_correlator_master_AWVALID),
	    .correlator_master_AWADDR(soc_correlator_master_AWADDR),
	    .correlator_master_AWPROT(soc_correlator_master_AWPROT),
	    .correlator_master_AWLEN(soc_correlator_master_AWLEN),
	    .correlator_master_AWSIZE(soc_correlator_master_AWSIZE),
	    .correlator_master_AWBURST(soc_correlator_master_AWBURST),
	    .correlator_master_AWID(soc_correlator_master_AWID),
	    .correlator_master_WVALID(soc_correlator_master_WVALID),
	    .correlator_master_WDATA(soc_correlator_master_WDATA),
	    .correlator_master_WSTRB(soc_correlator_master_WSTRB),
	    .correlator_master_WLAST(soc_correlator_master_WLAST),
	    .correlator_master_WID(soc_correlator_master_WID),
	    .correlator_master_BREADY(soc_correlator_master_BREADY),
	    .correlator_master_ARVALID(soc_correlator_master_ARVALID),
	    .correlator_master_ARADDR(soc_correlator_master_ARADDR),
	    .correlator_master_ARPROT(soc_correlator_master_ARPROT),
	    .correlator_master_ARLEN(soc_correlator_master_ARLEN),
	    .correlator_master_ARSIZE(soc_correlator_master_ARSIZE),
	    .correlator_master_ARBURST(soc_correlator_master_ARBURST),
	    .correlator_master_ARID(soc_correlator_master_ARID),
	    .correlator_master_RREADY(soc_correlator_master_RREADY),
	    .uart_io_SOUT(soc_uart_io_SOUT),
	    .wire_tdo(soc_wire_tdo),
	    .gpio_io_gpio_out(soc_gpio_io_gpio_out),
	    .RDY_gpio_io_gpio_out(),
	    .gpio_io_gpio_out_en(soc_gpio_io_gpio_out_en),
	    .RDY_gpio_io_gpio_out_en(),
	    .io_dump_get(soc_io_dump_get),
	    .RDY_io_dump_get(soc_RDY_io_dump_get));

  // submodule tck_clk
  MakeClock #(.initVal(1'd1), .initGate(1'd1)) tck_clk(.CLK(CLK),
						       .RST(RST_N),
						       .CLK_IN(tck_clk_CLK_IN),
						       .COND_IN(tck_clk_COND_IN),
						       .CLK_IN_EN(tck_clk_CLK_IN_EN),
						       .COND_IN_EN(tck_clk_COND_IN_EN),
						       .CLK_VAL_OUT(),
						       .COND_OUT(),
						       .CLK_GATE_OUT(),
						       .CLK_OUT(tck_clk_CLK_OUT));

  // submodule trst
  MakeReset0 #(.init(1'd1)) trst(.CLK(CLK),
				 .RST(RST_N),
				 .ASSERT_IN(trst_ASSERT_IN),
				 .ASSERT_OUT(),
				 .OUT_RST(trst_OUT_RST));

  // submodule uart_uart_baudGen_rBaudCounter
  Counter #(.width(32'd16),
	    .init(16'd0)) uart_uart_baudGen_rBaudCounter(.CLK(CLK),
							 .RST(RST_N),
							 .DATA_A(uart_uart_baudGen_rBaudCounter_DATA_A),
							 .DATA_B(uart_uart_baudGen_rBaudCounter_DATA_B),
							 .DATA_C(uart_uart_baudGen_rBaudCounter_DATA_C),
							 .DATA_F(uart_uart_baudGen_rBaudCounter_DATA_F),
							 .ADDA(uart_uart_baudGen_rBaudCounter_ADDA),
							 .ADDB(uart_uart_baudGen_rBaudCounter_ADDB),
							 .SETC(uart_uart_baudGen_rBaudCounter_SETC),
							 .SETF(uart_uart_baudGen_rBaudCounter_SETF),
							 .Q_OUT(uart_uart_baudGen_rBaudCounter_Q_OUT));

  // submodule uart_uart_baudGen_rBaudTickCounter
  Counter #(.width(32'd3),
	    .init(3'd0)) uart_uart_baudGen_rBaudTickCounter(.CLK(CLK),
							    .RST(RST_N),
							    .DATA_A(uart_uart_baudGen_rBaudTickCounter_DATA_A),
							    .DATA_B(uart_uart_baudGen_rBaudTickCounter_DATA_B),
							    .DATA_C(uart_uart_baudGen_rBaudTickCounter_DATA_C),
							    .DATA_F(uart_uart_baudGen_rBaudTickCounter_DATA_F),
							    .ADDA(uart_uart_baudGen_rBaudTickCounter_ADDA),
							    .ADDB(uart_uart_baudGen_rBaudTickCounter_ADDB),
							    .SETC(uart_uart_baudGen_rBaudTickCounter_SETC),
							    .SETF(uart_uart_baudGen_rBaudTickCounter_SETF),
							    .Q_OUT(uart_uart_baudGen_rBaudTickCounter_Q_OUT));

  // submodule uart_uart_fifoRecv
  SizedFIFO #(.p1width(32'd8),
	      .p2depth(32'd16),
	      .p3cntr_width(32'd4),
	      .guarded(1'd1)) uart_uart_fifoRecv(.RST(RST_N),
						 .CLK(CLK),
						 .D_IN(uart_uart_fifoRecv_D_IN),
						 .ENQ(uart_uart_fifoRecv_ENQ),
						 .DEQ(uart_uart_fifoRecv_DEQ),
						 .CLR(uart_uart_fifoRecv_CLR),
						 .D_OUT(uart_uart_fifoRecv_D_OUT),
						 .FULL_N(uart_uart_fifoRecv_FULL_N),
						 .EMPTY_N(uart_uart_fifoRecv_EMPTY_N));

  // submodule uart_uart_fifoXmit
  SizedFIFO #(.p1width(32'd8),
	      .p2depth(32'd16),
	      .p3cntr_width(32'd4),
	      .guarded(1'd1)) uart_uart_fifoXmit(.RST(RST_N),
						 .CLK(CLK),
						 .D_IN(uart_uart_fifoXmit_D_IN),
						 .ENQ(uart_uart_fifoXmit_ENQ),
						 .DEQ(uart_uart_fifoXmit_DEQ),
						 .CLR(uart_uart_fifoXmit_CLR),
						 .D_OUT(uart_uart_fifoXmit_D_OUT),
						 .FULL_N(uart_uart_fifoXmit_FULL_N),
						 .EMPTY_N(uart_uart_fifoXmit_EMPTY_N));

  // rule RL_display_eol
  assign CAN_FIRE_RL_display_eol = 1'd1 ;
  assign WILL_FIRE_RL_display_eol = 1'd1 ;

  // rule RL_open_file_rtldump
  assign CAN_FIRE_RL_open_file_rtldump = rg_cnt_72_ULT_5___d173 ;
  assign WILL_FIRE_RL_open_file_rtldump = rg_cnt_72_ULT_5___d173 ;

  // rule RL_open_file_app
  assign CAN_FIRE_RL_open_file_app = rg_cnt_72_ULT_5___d173 ;
  assign WILL_FIRE_RL_open_file_app = rg_cnt_72_ULT_5___d173 ;

  // rule RL_connect_uart_out
  assign CAN_FIRE_RL_connect_uart_out = 1'd1 ;
  assign WILL_FIRE_RL_connect_uart_out = 1'd1 ;

  // rule RL_write_dump_file
  assign CAN_FIRE_RL_write_dump_file =
	     soc_RDY_io_dump_get && !rg_cnt_72_ULT_5___d173 ;
  assign WILL_FIRE_RL_write_dump_file = CAN_FIRE_RL_write_dump_file ;

  // rule RL_rl_wr_tdo
  assign CAN_FIRE_RL_rl_wr_tdo = 1'd1 ;
  assign WILL_FIRE_RL_rl_wr_tdo = 1'd1 ;

  // rule RL_rl_initial
  assign CAN_FIRE_RL_rl_initial = !rg_initial ;
  assign WILL_FIRE_RL_rl_initial = CAN_FIRE_RL_rl_initial ;

  // rule RL_rl_get_frame
  assign CAN_FIRE_RL_rl_get_frame = rg_initial ;
  assign WILL_FIRE_RL_rl_get_frame = rg_initial ;

  // rule RL_connect_jtag_io
  assign CAN_FIRE_RL_connect_jtag_io = rg_initial ;
  assign WILL_FIRE_RL_connect_jtag_io = rg_initial ;

  // rule RL_uart_capture_status
  assign CAN_FIRE_RL_uart_capture_status = 1'd1 ;
  assign WILL_FIRE_RL_uart_capture_status = 1'd1 ;

  // rule RL_check_if_character_present
  assign CAN_FIRE_RL_check_if_character_present = !rg_read_rx ;
  assign WILL_FIRE_RL_check_if_character_present =
	     CAN_FIRE_RL_check_if_character_present ;

  // rule RL_write_received_character
  assign CAN_FIRE_RL_write_received_character =
	     !rg_cnt_72_ULT_5___d173 && rg_read_rx ;
  assign WILL_FIRE_RL_write_received_character =
	     CAN_FIRE_RL_write_received_character ;

  // rule RL_uart_uart_baudGen_baud_count_wire
  assign CAN_FIRE_RL_uart_uart_baudGen_baud_count_wire = 1'd1 ;
  assign WILL_FIRE_RL_uart_uart_baudGen_baud_count_wire = 1'd1 ;

  // rule RL_uart_uart_baud_generator_clock_enable
  assign CAN_FIRE_RL_uart_uart_baud_generator_clock_enable = 1'd1 ;
  assign WILL_FIRE_RL_uart_uart_baud_generator_clock_enable = 1'd1 ;

  // rule RL_uart_uart_receive_wait_for_start_bit
  assign CAN_FIRE_RL_uart_uart_receive_wait_for_start_bit =
	     uart_uart_rRecvState == 3'd0 &&
	     !uart_uart_baudGen_rBaudCounter_value_PLUS_1_8__ETC___d30 ;
  assign WILL_FIRE_RL_uart_uart_receive_wait_for_start_bit =
	     CAN_FIRE_RL_uart_uart_receive_wait_for_start_bit ;

  // rule RL_uart_uart_receive_find_center_of_bit_cell
  assign CAN_FIRE_RL_uart_uart_receive_find_center_of_bit_cell =
	     uart_uart_rRecvState == 3'd1 &&
	     !uart_uart_baudGen_rBaudCounter_value_PLUS_1_8__ETC___d30 ;
  assign WILL_FIRE_RL_uart_uart_receive_find_center_of_bit_cell =
	     CAN_FIRE_RL_uart_uart_receive_find_center_of_bit_cell ;

  // rule RL_uart_uart_receive_wait_bit_cell_time_for_sample
  assign CAN_FIRE_RL_uart_uart_receive_wait_bit_cell_time_for_sample =
	     uart_uart_rRecvState == 3'd2 &&
	     uart_uart_rRecvCellCount == 4'hF &&
	     !uart_uart_baudGen_rBaudCounter_value_PLUS_1_8__ETC___d30 ;
  assign WILL_FIRE_RL_uart_uart_receive_wait_bit_cell_time_for_sample =
	     CAN_FIRE_RL_uart_uart_receive_wait_bit_cell_time_for_sample ;

  // rule RL_uart_uart_receive_sample_pin
  assign CAN_FIRE_RL_uart_uart_receive_sample_pin =
	     CAN_FIRE_RL_uart_uart_receive_buffer_shift ;
  assign WILL_FIRE_RL_uart_uart_receive_sample_pin =
	     CAN_FIRE_RL_uart_uart_receive_buffer_shift ;

  // rule RL_uart_uart_receive_parity_bit
  assign CAN_FIRE_RL_uart_uart_receive_parity_bit =
	     uart_uart_rRecvState == 3'd4 &&
	     !uart_uart_baudGen_rBaudCounter_value_PLUS_1_8__ETC___d30 ;
  assign WILL_FIRE_RL_uart_uart_receive_parity_bit =
	     CAN_FIRE_RL_uart_uart_receive_parity_bit ;

  // rule RL_uart_uart_receive_stop_first_bit
  assign CAN_FIRE_RL_uart_uart_receive_stop_first_bit =
	     uart_uart_rRecvState == 3'd5 &&
	     !uart_uart_baudGen_rBaudCounter_value_PLUS_1_8__ETC___d30 ;
  assign WILL_FIRE_RL_uart_uart_receive_stop_first_bit =
	     CAN_FIRE_RL_uart_uart_receive_stop_first_bit ;

  // rule RL_uart_uart_receive_bit_counter
  assign CAN_FIRE_RL_uart_uart_receive_bit_counter = 1'd1 ;
  assign WILL_FIRE_RL_uart_uart_receive_bit_counter = 1'd1 ;

  // rule RL_uart_uart_receive_stop_last_bit
  assign CAN_FIRE_RL_uart_uart_receive_stop_last_bit =
	     uart_uart_rRecvState == 3'd6 &&
	     !uart_uart_baudGen_rBaudCounter_value_PLUS_1_8__ETC___d30 ;
  assign WILL_FIRE_RL_uart_uart_receive_stop_last_bit =
	     CAN_FIRE_RL_uart_uart_receive_stop_last_bit ;

  // rule RL_uart_uart_receive_bit_cell_time_counter
  assign CAN_FIRE_RL_uart_uart_receive_bit_cell_time_counter =
	     CAN_FIRE_RL_uart_uart_baudGen_count_baudtick_16x ;
  assign WILL_FIRE_RL_uart_uart_receive_bit_cell_time_counter =
	     CAN_FIRE_RL_uart_uart_baudGen_count_baudtick_16x ;

  // rule RL_uart_uart_receive_buffer_shift
  assign CAN_FIRE_RL_uart_uart_receive_buffer_shift =
	     uart_uart_rRecvState == 3'd3 &&
	     !uart_uart_baudGen_rBaudCounter_value_PLUS_1_8__ETC___d30 ;
  assign WILL_FIRE_RL_uart_uart_receive_buffer_shift =
	     CAN_FIRE_RL_uart_uart_receive_buffer_shift ;

  // rule RL_connect_uart_in
  assign CAN_FIRE_RL_connect_uart_in = 1'd1 ;
  assign WILL_FIRE_RL_connect_uart_in = 1'd1 ;

  // rule RL_uart_uart_transmit_wait_for_start_command
  assign CAN_FIRE_RL_uart_uart_transmit_wait_for_start_command =
	     uart_uart_rXmitState == 3'd0 &&
	     !uart_uart_baudGen_rBaudCounter_value_PLUS_1_8__ETC___d30 ;
  assign WILL_FIRE_RL_uart_uart_transmit_wait_for_start_command =
	     CAN_FIRE_RL_uart_uart_transmit_wait_for_start_command ;

  // rule RL_uart_uart_transmit_send_start_bit
  assign CAN_FIRE_RL_uart_uart_transmit_send_start_bit =
	     uart_uart_rXmitState == 3'd1 &&
	     !uart_uart_baudGen_rBaudCounter_value_PLUS_1_8__ETC___d30 ;
  assign WILL_FIRE_RL_uart_uart_transmit_send_start_bit =
	     CAN_FIRE_RL_uart_uart_transmit_send_start_bit ;

  // rule RL_uart_uart_transmit_wait_1_bit_cell_time
  assign CAN_FIRE_RL_uart_uart_transmit_wait_1_bit_cell_time =
	     uart_uart_rXmitState == 3'd2 &&
	     !uart_uart_baudGen_rBaudCounter_value_PLUS_1_8__ETC___d30 ;
  assign WILL_FIRE_RL_uart_uart_transmit_wait_1_bit_cell_time =
	     CAN_FIRE_RL_uart_uart_transmit_wait_1_bit_cell_time ;

  // rule RL_uart_uart_transmit_bit_counter
  assign CAN_FIRE_RL_uart_uart_transmit_bit_counter = 1'd1 ;
  assign WILL_FIRE_RL_uart_uart_transmit_bit_counter = 1'd1 ;

  // rule RL_uart_uart_transmit_shift_next_bit
  assign CAN_FIRE_RL_uart_uart_transmit_shift_next_bit =
	     uart_uart_rXmitState == 3'd3 &&
	     !uart_uart_baudGen_rBaudCounter_value_PLUS_1_8__ETC___d30 ;
  assign WILL_FIRE_RL_uart_uart_transmit_shift_next_bit =
	     CAN_FIRE_RL_uart_uart_transmit_shift_next_bit ;

  // rule RL_uart_uart_transmit_buffer_load
  assign CAN_FIRE_RL_uart_uart_transmit_buffer_load =
	     uart_uart_fifoXmit_EMPTY_N && uart_uart_pwXmitLoadBuffer_whas ;
  assign WILL_FIRE_RL_uart_uart_transmit_buffer_load =
	     CAN_FIRE_RL_uart_uart_transmit_buffer_load ;

  // rule RL_uart_uart_transmit_buffer_shift
  assign CAN_FIRE_RL_uart_uart_transmit_buffer_shift =
	     !uart_uart_pwXmitLoadBuffer_whas &&
	     CAN_FIRE_RL_uart_uart_transmit_shift_next_bit ;
  assign WILL_FIRE_RL_uart_uart_transmit_buffer_shift =
	     CAN_FIRE_RL_uart_uart_transmit_buffer_shift ;

  // rule RL_uart_uart_transmit_send_parity_bit
  assign CAN_FIRE_RL_uart_uart_transmit_send_parity_bit =
	     uart_uart_rXmitState == 3'd7 &&
	     !uart_uart_baudGen_rBaudCounter_value_PLUS_1_8__ETC___d30 ;
  assign WILL_FIRE_RL_uart_uart_transmit_send_parity_bit =
	     CAN_FIRE_RL_uart_uart_transmit_send_parity_bit ;

  // rule RL_uart_uart_transmit_send_stop_bit
  assign CAN_FIRE_RL_uart_uart_transmit_send_stop_bit =
	     uart_uart_rXmitState == 3'd4 &&
	     !uart_uart_baudGen_rBaudCounter_value_PLUS_1_8__ETC___d30 ;
  assign WILL_FIRE_RL_uart_uart_transmit_send_stop_bit =
	     CAN_FIRE_RL_uart_uart_transmit_send_stop_bit ;

  // rule RL_uart_uart_transmit_send_stop_bit1_5
  assign CAN_FIRE_RL_uart_uart_transmit_send_stop_bit1_5 =
	     uart_uart_rXmitState == 3'd5 &&
	     !uart_uart_baudGen_rBaudCounter_value_PLUS_1_8__ETC___d30 ;
  assign WILL_FIRE_RL_uart_uart_transmit_send_stop_bit1_5 =
	     CAN_FIRE_RL_uart_uart_transmit_send_stop_bit1_5 ;

  // rule RL_uart_uart_transmit_send_stop_bit2
  assign CAN_FIRE_RL_uart_uart_transmit_send_stop_bit2 =
	     uart_uart_rXmitState == 3'd6 &&
	     !uart_uart_baudGen_rBaudCounter_value_PLUS_1_8__ETC___d30 ;
  assign WILL_FIRE_RL_uart_uart_transmit_send_stop_bit2 =
	     CAN_FIRE_RL_uart_uart_transmit_send_stop_bit2 ;

  // rule RL_uart_uart_transmit_bit_cell_time_counter
  assign CAN_FIRE_RL_uart_uart_transmit_bit_cell_time_counter =
	     CAN_FIRE_RL_uart_uart_baudGen_count_baudtick_16x ;
  assign WILL_FIRE_RL_uart_uart_transmit_bit_cell_time_counter =
	     CAN_FIRE_RL_uart_uart_baudGen_count_baudtick_16x ;

  // rule RL_uart_uart_baudGen_baud_tick_count_wire
  assign CAN_FIRE_RL_uart_uart_baudGen_baud_tick_count_wire = 1'd1 ;
  assign WILL_FIRE_RL_uart_uart_baudGen_baud_tick_count_wire = 1'd1 ;

  // rule RL_uart_uart_baudGen_assert_2x_baud_tick
  assign CAN_FIRE_RL_uart_uart_baudGen_assert_2x_baud_tick =
	     uart_uart_baudGen_rBaudTickCounter_Q_OUT == 3'd0 &&
	     !uart_uart_baudGen_rBaudCounter_value_PLUS_1_8__ETC___d30 ;
  assign WILL_FIRE_RL_uart_uart_baudGen_assert_2x_baud_tick =
	     CAN_FIRE_RL_uart_uart_baudGen_assert_2x_baud_tick ;

  // rule RL_uart_uart_baudGen_count_baudtick_16x
  assign CAN_FIRE_RL_uart_uart_baudGen_count_baudtick_16x =
	     !uart_uart_baudGen_rBaudCounter_value_PLUS_1_8__ETC___d30 ;
  assign WILL_FIRE_RL_uart_uart_baudGen_count_baudtick_16x =
	     CAN_FIRE_RL_uart_uart_baudGen_count_baudtick_16x ;

  // rule RL_uart_uart_fifoRecv__updateLevelCounter
  assign CAN_FIRE_RL_uart_uart_fifoRecv__updateLevelCounter =
	     CAN_FIRE_RL_uart_uart_receive_stop_last_bit !=
	     uart_uart_fifoRecv_r_deq_whas ;
  assign WILL_FIRE_RL_uart_uart_fifoRecv__updateLevelCounter =
	     CAN_FIRE_RL_uart_uart_fifoRecv__updateLevelCounter ;

  // rule RL_uart_uart_fifoXmit__updateLevelCounter
  assign CAN_FIRE_RL_uart_uart_fifoXmit__updateLevelCounter =
	     1'b0 != CAN_FIRE_RL_uart_uart_transmit_buffer_load ;
  assign WILL_FIRE_RL_uart_uart_fifoXmit__updateLevelCounter =
	     CAN_FIRE_RL_uart_uart_fifoXmit__updateLevelCounter ;

  // rule RL_rg_read_rx__dreg_update
  assign CAN_FIRE_RL_rg_read_rx__dreg_update = 1'd1 ;
  assign WILL_FIRE_RL_rg_read_rx__dreg_update = 1'd1 ;

  // inputs to muxes for submodule ports
  assign MUX_uart_uart_rRecvState_write_1__SEL_6 =
	     WILL_FIRE_RL_uart_uart_receive_parity_bit ||
	     WILL_FIRE_RL_uart_uart_receive_sample_pin ;
  assign MUX_uart_uart_rXmitDataOut_write_1__SEL_1 =
	     WILL_FIRE_RL_uart_uart_transmit_shift_next_bit ||
	     WILL_FIRE_RL_uart_uart_transmit_wait_1_bit_cell_time ;
  assign MUX_uart_uart_rXmitDataOut_write_1__SEL_2 =
	     WILL_FIRE_RL_uart_uart_transmit_send_parity_bit ||
	     WILL_FIRE_RL_uart_uart_transmit_send_start_bit ;
  assign MUX_uart_uart_rXmitDataOut_write_1__SEL_3 =
	     WILL_FIRE_RL_uart_uart_transmit_send_stop_bit2 ||
	     WILL_FIRE_RL_uart_uart_transmit_send_stop_bit1_5 ||
	     WILL_FIRE_RL_uart_uart_transmit_send_stop_bit ||
	     WILL_FIRE_RL_uart_uart_transmit_wait_for_start_command ;
  assign MUX_uart_uart_rRecvState_write_1__VAL_1 =
	     uart_uart_rRecvData ? 3'd0 : 3'd1 ;
  assign MUX_uart_uart_rRecvState_write_1__VAL_2 =
	     (uart_uart_rRecvCellCount == 4'h4) ?
	       (uart_uart_rRecvData ? 3'd0 : 3'd2) :
	       3'd1 ;
  always@(uart_uart_rRecvBitCount)
  begin
    case (uart_uart_rRecvBitCount)
      4'd8, 4'd9, 4'd10: MUX_uart_uart_rRecvState_write_1__VAL_3 = 3'd6;
      default: MUX_uart_uart_rRecvState_write_1__VAL_3 = 3'd3;
    endcase
  end
  assign MUX_uart_uart_rRecvState_write_1__VAL_4 =
	     uart_uart_rRecvData ? 3'd2 : 3'd0 ;
  assign MUX_uart_uart_rXmitState_write_1__VAL_1 =
	     uart_uart_fifoXmit_EMPTY_N ? 3'd1 : 3'd0 ;
  assign MUX_uart_uart_rXmitState_write_1__VAL_2 =
	     (uart_uart_rXmitCellCount == 4'hF) ? 3'd2 : 3'd1 ;
  assign MUX_uart_uart_rXmitState_write_1__VAL_3 =
	     (uart_uart_rXmitCellCount == 4'hF) ?
	       ((uart_uart_rXmitBitCount == 4'd7) ? 3'd4 : 3'd3) :
	       3'd2 ;
  assign MUX_uart_uart_rXmitState_write_1__VAL_4 =
	     (uart_uart_rXmitCellCount == 4'hF) ? 3'd4 : 3'd7 ;
  assign MUX_uart_uart_rXmitState_write_1__VAL_5 =
	     (uart_uart_rXmitCellCount == 4'hF) ? 3'd0 : 3'd4 ;
  assign MUX_uart_uart_rXmitState_write_1__VAL_6 =
	     (uart_uart_rXmitCellCount == 4'h7) ? 3'd0 : 3'd5 ;
  assign MUX_uart_uart_rXmitState_write_1__VAL_7 =
	     (uart_uart_rXmitCellCount == 4'hF) ? 3'd0 : 3'd6 ;

  // inlined wires
  assign rg_read_rx_1_whas =
	     WILL_FIRE_RL_check_if_character_present && x__read__h11422[3] ;
  assign uart_uart_fifoRecv_r_deq_whas =
	     WILL_FIRE_RL_write_received_character &&
	     uart_uart_fifoRecv_EMPTY_N ;
  assign uart_uart_pwRecvCellCountReset_whas =
	     WILL_FIRE_RL_uart_uart_receive_find_center_of_bit_cell &&
	     uart_uart_rRecvCellCount == 4'h4 ||
	     WILL_FIRE_RL_uart_uart_receive_stop_last_bit ||
	     WILL_FIRE_RL_uart_uart_receive_stop_first_bit ||
	     WILL_FIRE_RL_uart_uart_receive_parity_bit ||
	     WILL_FIRE_RL_uart_uart_receive_sample_pin ||
	     WILL_FIRE_RL_uart_uart_receive_wait_bit_cell_time_for_sample ||
	     WILL_FIRE_RL_uart_uart_receive_wait_for_start_bit ;
  assign uart_uart_pwRecvResetBitCount_whas =
	     WILL_FIRE_RL_uart_uart_receive_wait_for_start_bit &&
	     uart_uart_rRecvData ;
  assign uart_uart_pwRecvEnableBitCount_whas =
	     WILL_FIRE_RL_uart_uart_receive_stop_first_bit ||
	     WILL_FIRE_RL_uart_uart_receive_parity_bit ||
	     WILL_FIRE_RL_uart_uart_receive_sample_pin ;
  assign uart_uart_pwXmitCellCountReset_whas =
	     WILL_FIRE_RL_uart_uart_transmit_wait_for_start_command &&
	     uart_uart_fifoXmit_EMPTY_N ||
	     _dor2uart_uart_pwXmitCellCountReset_EN_wset &&
	     uart_uart_rXmitCellCount == 4'hF ||
	     WILL_FIRE_RL_uart_uart_transmit_send_stop_bit1_5 &&
	     uart_uart_rXmitCellCount == 4'h7 ;
  assign uart_uart_pwXmitEnableBitCount_whas =
	     WILL_FIRE_RL_uart_uart_transmit_wait_1_bit_cell_time &&
	     uart_uart_rXmitCellCount == 4'hF &&
	     uart_uart_rXmitBitCount != 4'd7 ;
  assign uart_uart_pwXmitLoadBuffer_whas =
	     WILL_FIRE_RL_uart_uart_transmit_wait_for_start_command &&
	     uart_uart_fifoXmit_EMPTY_N ;

  // register delayed_actor
  assign delayed_actor_D_IN = TASK_get_frame___d244[4:0] ;
  assign delayed_actor_EN = rg_initial ;

  // register delayed_actor2
  assign delayed_actor2_D_IN = delayed_actor ;
  assign delayed_actor2_EN = rg_initial ;

  // register delayed_actor3
  assign delayed_actor3_D_IN = delayed_actor2 ;
  assign delayed_actor3_EN = rg_initial ;

  // register delayed_actor4
  assign delayed_actor4_D_IN = delayed_actor3 ;
  assign delayed_actor4_EN = rg_initial ;

  // register delayed_actor5
  assign delayed_actor5_D_IN = delayed_actor4 ;
  assign delayed_actor5_EN = rg_initial ;

  // register dump
  assign dump_D_IN = TASK_fopen___d175 ;
  assign dump_EN =
	     WILL_FIRE_RL_open_file_rtldump && TASK_testplusargs___d174 ;

  // register dump1
  assign dump1_D_IN = TASK_fopen___d186 ;
  assign dump1_EN = rg_cnt_72_ULT_5___d173 ;

  // register rg_client_fd
  assign rg_client_fd_D_IN = b__h16357 ;
  assign rg_client_fd_EN =
	     WILL_FIRE_RL_rl_initial && b__h16357 != 32'hFFFFFFFF ;

  // register rg_cnt
  assign rg_cnt_D_IN = rg_cnt + 5'd1 ;
  assign rg_cnt_EN = rg_cnt_72_ULT_5___d173 ;

  // register rg_end_sim
  assign rg_end_sim_D_IN = 1'b0 ;
  assign rg_end_sim_EN = 1'b0 ;

  // register rg_initial
  assign rg_initial_D_IN = 1'b1 ;
  assign rg_initial_EN =
	     WILL_FIRE_RL_rl_initial && b__h16357 != 32'hFFFFFFFF ;

  // register rg_read_rx
  assign rg_read_rx_D_IN = rg_read_rx_1_whas ;
  assign rg_read_rx_EN = 1'd1 ;

  // register uart_baud_value
  assign uart_baud_value_D_IN = 16'h0 ;
  assign uart_baud_value_EN = 1'b0 ;

  // register uart_uart_fifoRecv_countReg
  assign uart_uart_fifoRecv_countReg_D_IN =
	     CAN_FIRE_RL_uart_uart_receive_stop_last_bit ?
	       uart_uart_fifoRecv_countReg + 5'd1 :
	       uart_uart_fifoRecv_countReg - 5'd1 ;
  assign uart_uart_fifoRecv_countReg_EN =
	     CAN_FIRE_RL_uart_uart_fifoRecv__updateLevelCounter ;

  // register uart_uart_fifoXmit_countReg
  assign uart_uart_fifoXmit_countReg_D_IN =
	     uart_uart_fifoXmit_countReg - 5'd1 ;
  assign uart_uart_fifoXmit_countReg_EN =
	     CAN_FIRE_RL_uart_uart_fifoXmit__updateLevelCounter ;

  // register uart_uart_rRecvBitCount
  assign uart_uart_rRecvBitCount_D_IN =
	     uart_uart_pwRecvResetBitCount_whas ? 4'd0 : x__h5270 ;
  assign uart_uart_rRecvBitCount_EN =
	     uart_uart_pwRecvResetBitCount_whas ||
	     uart_uart_pwRecvEnableBitCount_whas ;

  // register uart_uart_rRecvCellCount
  assign uart_uart_rRecvCellCount_D_IN =
	     uart_uart_pwRecvCellCountReset_whas ? 4'd0 : x__h3566 ;
  assign uart_uart_rRecvCellCount_EN =
	     CAN_FIRE_RL_uart_uart_baudGen_count_baudtick_16x ;

  // register uart_uart_rRecvData
  assign uart_uart_rRecvData_D_IN = soc_uart_io_SOUT ;
  assign uart_uart_rRecvData_EN = 1'd1 ;

  // register uart_uart_rRecvParity
  assign uart_uart_rRecvParity_D_IN = uart_uart_rRecvData ;
  assign uart_uart_rRecvParity_EN = CAN_FIRE_RL_uart_uart_receive_parity_bit ;

  // register uart_uart_rRecvState
  always@(WILL_FIRE_RL_uart_uart_receive_wait_for_start_bit or
	  MUX_uart_uart_rRecvState_write_1__VAL_1 or
	  WILL_FIRE_RL_uart_uart_receive_find_center_of_bit_cell or
	  MUX_uart_uart_rRecvState_write_1__VAL_2 or
	  WILL_FIRE_RL_uart_uart_receive_wait_bit_cell_time_for_sample or
	  MUX_uart_uart_rRecvState_write_1__VAL_3 or
	  WILL_FIRE_RL_uart_uart_receive_stop_first_bit or
	  MUX_uart_uart_rRecvState_write_1__VAL_4 or
	  WILL_FIRE_RL_uart_uart_receive_stop_last_bit or
	  MUX_uart_uart_rRecvState_write_1__SEL_6)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_uart_uart_receive_wait_for_start_bit:
	  uart_uart_rRecvState_D_IN = MUX_uart_uart_rRecvState_write_1__VAL_1;
      WILL_FIRE_RL_uart_uart_receive_find_center_of_bit_cell:
	  uart_uart_rRecvState_D_IN = MUX_uart_uart_rRecvState_write_1__VAL_2;
      WILL_FIRE_RL_uart_uart_receive_wait_bit_cell_time_for_sample:
	  uart_uart_rRecvState_D_IN = MUX_uart_uart_rRecvState_write_1__VAL_3;
      WILL_FIRE_RL_uart_uart_receive_stop_first_bit:
	  uart_uart_rRecvState_D_IN = MUX_uart_uart_rRecvState_write_1__VAL_4;
      WILL_FIRE_RL_uart_uart_receive_stop_last_bit:
	  uart_uart_rRecvState_D_IN = 3'd0;
      MUX_uart_uart_rRecvState_write_1__SEL_6:
	  uart_uart_rRecvState_D_IN = 3'd2;
      default: uart_uart_rRecvState_D_IN = 3'bxxx /* unspecified value */ ;
    endcase
  end
  assign uart_uart_rRecvState_EN =
	     WILL_FIRE_RL_uart_uart_receive_wait_for_start_bit ||
	     WILL_FIRE_RL_uart_uart_receive_find_center_of_bit_cell ||
	     WILL_FIRE_RL_uart_uart_receive_wait_bit_cell_time_for_sample ||
	     WILL_FIRE_RL_uart_uart_receive_stop_first_bit ||
	     WILL_FIRE_RL_uart_uart_receive_stop_last_bit ||
	     WILL_FIRE_RL_uart_uart_receive_parity_bit ||
	     WILL_FIRE_RL_uart_uart_receive_sample_pin ;

  // register uart_uart_rXmitBitCount
  assign uart_uart_rXmitBitCount_D_IN =
	     CAN_FIRE_RL_uart_uart_transmit_wait_for_start_command ?
	       4'd0 :
	       x__h7052 ;
  assign uart_uart_rXmitBitCount_EN =
	     CAN_FIRE_RL_uart_uart_transmit_wait_for_start_command ||
	     uart_uart_pwXmitEnableBitCount_whas ;

  // register uart_uart_rXmitCellCount
  assign uart_uart_rXmitCellCount_D_IN =
	     uart_uart_pwXmitCellCountReset_whas ? 4'd0 : x__h7026 ;
  assign uart_uart_rXmitCellCount_EN =
	     CAN_FIRE_RL_uart_uart_baudGen_count_baudtick_16x ;

  // register uart_uart_rXmitDataOut
  always@(MUX_uart_uart_rXmitDataOut_write_1__SEL_1 or
	  uart_uart_vrXmitBuffer_0 or
	  MUX_uart_uart_rXmitDataOut_write_1__SEL_2 or
	  MUX_uart_uart_rXmitDataOut_write_1__SEL_3)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_uart_uart_rXmitDataOut_write_1__SEL_1:
	  uart_uart_rXmitDataOut_D_IN = uart_uart_vrXmitBuffer_0;
      MUX_uart_uart_rXmitDataOut_write_1__SEL_2:
	  uart_uart_rXmitDataOut_D_IN = 1'b0;
      MUX_uart_uart_rXmitDataOut_write_1__SEL_3:
	  uart_uart_rXmitDataOut_D_IN = 1'b1;
      default: uart_uart_rXmitDataOut_D_IN = 1'bx /* unspecified value */ ;
    endcase
  end
  assign uart_uart_rXmitDataOut_EN =
	     WILL_FIRE_RL_uart_uart_transmit_shift_next_bit ||
	     WILL_FIRE_RL_uart_uart_transmit_wait_1_bit_cell_time ||
	     WILL_FIRE_RL_uart_uart_transmit_send_parity_bit ||
	     WILL_FIRE_RL_uart_uart_transmit_send_start_bit ||
	     WILL_FIRE_RL_uart_uart_transmit_send_stop_bit2 ||
	     WILL_FIRE_RL_uart_uart_transmit_send_stop_bit1_5 ||
	     WILL_FIRE_RL_uart_uart_transmit_send_stop_bit ||
	     WILL_FIRE_RL_uart_uart_transmit_wait_for_start_command ;

  // register uart_uart_rXmitParity
  assign uart_uart_rXmitParity_D_IN = z__h8544 ^ uart_uart_fifoXmit_D_OUT[7] ;
  assign uart_uart_rXmitParity_EN =
	     CAN_FIRE_RL_uart_uart_transmit_buffer_load ;

  // register uart_uart_rXmitState
  always@(WILL_FIRE_RL_uart_uart_transmit_wait_for_start_command or
	  MUX_uart_uart_rXmitState_write_1__VAL_1 or
	  WILL_FIRE_RL_uart_uart_transmit_send_start_bit or
	  MUX_uart_uart_rXmitState_write_1__VAL_2 or
	  WILL_FIRE_RL_uart_uart_transmit_wait_1_bit_cell_time or
	  MUX_uart_uart_rXmitState_write_1__VAL_3 or
	  WILL_FIRE_RL_uart_uart_transmit_send_parity_bit or
	  MUX_uart_uart_rXmitState_write_1__VAL_4 or
	  WILL_FIRE_RL_uart_uart_transmit_send_stop_bit or
	  MUX_uart_uart_rXmitState_write_1__VAL_5 or
	  WILL_FIRE_RL_uart_uart_transmit_send_stop_bit1_5 or
	  MUX_uart_uart_rXmitState_write_1__VAL_6 or
	  WILL_FIRE_RL_uart_uart_transmit_send_stop_bit2 or
	  MUX_uart_uart_rXmitState_write_1__VAL_7 or
	  WILL_FIRE_RL_uart_uart_transmit_shift_next_bit)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_uart_uart_transmit_wait_for_start_command:
	  uart_uart_rXmitState_D_IN = MUX_uart_uart_rXmitState_write_1__VAL_1;
      WILL_FIRE_RL_uart_uart_transmit_send_start_bit:
	  uart_uart_rXmitState_D_IN = MUX_uart_uart_rXmitState_write_1__VAL_2;
      WILL_FIRE_RL_uart_uart_transmit_wait_1_bit_cell_time:
	  uart_uart_rXmitState_D_IN = MUX_uart_uart_rXmitState_write_1__VAL_3;
      WILL_FIRE_RL_uart_uart_transmit_send_parity_bit:
	  uart_uart_rXmitState_D_IN = MUX_uart_uart_rXmitState_write_1__VAL_4;
      WILL_FIRE_RL_uart_uart_transmit_send_stop_bit:
	  uart_uart_rXmitState_D_IN = MUX_uart_uart_rXmitState_write_1__VAL_5;
      WILL_FIRE_RL_uart_uart_transmit_send_stop_bit1_5:
	  uart_uart_rXmitState_D_IN = MUX_uart_uart_rXmitState_write_1__VAL_6;
      WILL_FIRE_RL_uart_uart_transmit_send_stop_bit2:
	  uart_uart_rXmitState_D_IN = MUX_uart_uart_rXmitState_write_1__VAL_7;
      WILL_FIRE_RL_uart_uart_transmit_shift_next_bit:
	  uart_uart_rXmitState_D_IN = 3'd2;
      default: uart_uart_rXmitState_D_IN = 3'bxxx /* unspecified value */ ;
    endcase
  end
  assign uart_uart_rXmitState_EN =
	     WILL_FIRE_RL_uart_uart_transmit_wait_for_start_command ||
	     WILL_FIRE_RL_uart_uart_transmit_send_start_bit ||
	     WILL_FIRE_RL_uart_uart_transmit_wait_1_bit_cell_time ||
	     WILL_FIRE_RL_uart_uart_transmit_send_parity_bit ||
	     WILL_FIRE_RL_uart_uart_transmit_send_stop_bit ||
	     WILL_FIRE_RL_uart_uart_transmit_send_stop_bit1_5 ||
	     WILL_FIRE_RL_uart_uart_transmit_send_stop_bit2 ||
	     WILL_FIRE_RL_uart_uart_transmit_shift_next_bit ;

  // register uart_uart_vrRecvBuffer_0
  assign uart_uart_vrRecvBuffer_0_D_IN = uart_uart_vrRecvBuffer_1 ;
  assign uart_uart_vrRecvBuffer_0_EN =
	     CAN_FIRE_RL_uart_uart_receive_buffer_shift ;

  // register uart_uart_vrRecvBuffer_1
  assign uart_uart_vrRecvBuffer_1_D_IN = uart_uart_vrRecvBuffer_2 ;
  assign uart_uart_vrRecvBuffer_1_EN =
	     CAN_FIRE_RL_uart_uart_receive_buffer_shift ;

  // register uart_uart_vrRecvBuffer_2
  assign uart_uart_vrRecvBuffer_2_D_IN = uart_uart_vrRecvBuffer_3 ;
  assign uart_uart_vrRecvBuffer_2_EN =
	     CAN_FIRE_RL_uart_uart_receive_buffer_shift ;

  // register uart_uart_vrRecvBuffer_3
  assign uart_uart_vrRecvBuffer_3_D_IN = uart_uart_vrRecvBuffer_4 ;
  assign uart_uart_vrRecvBuffer_3_EN =
	     CAN_FIRE_RL_uart_uart_receive_buffer_shift ;

  // register uart_uart_vrRecvBuffer_4
  assign uart_uart_vrRecvBuffer_4_D_IN = uart_uart_vrRecvBuffer_5 ;
  assign uart_uart_vrRecvBuffer_4_EN =
	     CAN_FIRE_RL_uart_uart_receive_buffer_shift ;

  // register uart_uart_vrRecvBuffer_5
  assign uart_uart_vrRecvBuffer_5_D_IN = uart_uart_vrRecvBuffer_6 ;
  assign uart_uart_vrRecvBuffer_5_EN =
	     CAN_FIRE_RL_uart_uart_receive_buffer_shift ;

  // register uart_uart_vrRecvBuffer_6
  assign uart_uart_vrRecvBuffer_6_D_IN = uart_uart_vrRecvBuffer_7 ;
  assign uart_uart_vrRecvBuffer_6_EN =
	     CAN_FIRE_RL_uart_uart_receive_buffer_shift ;

  // register uart_uart_vrRecvBuffer_7
  assign uart_uart_vrRecvBuffer_7_D_IN = uart_uart_rRecvData ;
  assign uart_uart_vrRecvBuffer_7_EN =
	     CAN_FIRE_RL_uart_uart_receive_buffer_shift ;

  // register uart_uart_vrXmitBuffer_0
  assign uart_uart_vrXmitBuffer_0_D_IN =
	     WILL_FIRE_RL_uart_uart_transmit_buffer_load ?
	       uart_uart_fifoXmit_D_OUT[0] :
	       uart_uart_vrXmitBuffer_1 ;
  assign uart_uart_vrXmitBuffer_0_EN =
	     WILL_FIRE_RL_uart_uart_transmit_buffer_load ||
	     WILL_FIRE_RL_uart_uart_transmit_buffer_shift ;

  // register uart_uart_vrXmitBuffer_1
  assign uart_uart_vrXmitBuffer_1_D_IN =
	     WILL_FIRE_RL_uart_uart_transmit_buffer_load ?
	       uart_uart_fifoXmit_D_OUT[1] :
	       uart_uart_vrXmitBuffer_2 ;
  assign uart_uart_vrXmitBuffer_1_EN =
	     WILL_FIRE_RL_uart_uart_transmit_buffer_load ||
	     WILL_FIRE_RL_uart_uart_transmit_buffer_shift ;

  // register uart_uart_vrXmitBuffer_2
  assign uart_uart_vrXmitBuffer_2_D_IN =
	     WILL_FIRE_RL_uart_uart_transmit_buffer_load ?
	       uart_uart_fifoXmit_D_OUT[2] :
	       uart_uart_vrXmitBuffer_3 ;
  assign uart_uart_vrXmitBuffer_2_EN =
	     WILL_FIRE_RL_uart_uart_transmit_buffer_load ||
	     WILL_FIRE_RL_uart_uart_transmit_buffer_shift ;

  // register uart_uart_vrXmitBuffer_3
  assign uart_uart_vrXmitBuffer_3_D_IN =
	     WILL_FIRE_RL_uart_uart_transmit_buffer_load ?
	       uart_uart_fifoXmit_D_OUT[3] :
	       uart_uart_vrXmitBuffer_4 ;
  assign uart_uart_vrXmitBuffer_3_EN =
	     WILL_FIRE_RL_uart_uart_transmit_buffer_load ||
	     WILL_FIRE_RL_uart_uart_transmit_buffer_shift ;

  // register uart_uart_vrXmitBuffer_4
  assign uart_uart_vrXmitBuffer_4_D_IN =
	     WILL_FIRE_RL_uart_uart_transmit_buffer_load ?
	       uart_uart_fifoXmit_D_OUT[4] :
	       uart_uart_vrXmitBuffer_5 ;
  assign uart_uart_vrXmitBuffer_4_EN =
	     WILL_FIRE_RL_uart_uart_transmit_buffer_load ||
	     WILL_FIRE_RL_uart_uart_transmit_buffer_shift ;

  // register uart_uart_vrXmitBuffer_5
  assign uart_uart_vrXmitBuffer_5_D_IN =
	     WILL_FIRE_RL_uart_uart_transmit_buffer_load ?
	       uart_uart_fifoXmit_D_OUT[5] :
	       uart_uart_vrXmitBuffer_6 ;
  assign uart_uart_vrXmitBuffer_5_EN =
	     WILL_FIRE_RL_uart_uart_transmit_buffer_load ||
	     WILL_FIRE_RL_uart_uart_transmit_buffer_shift ;

  // register uart_uart_vrXmitBuffer_6
  assign uart_uart_vrXmitBuffer_6_D_IN =
	     WILL_FIRE_RL_uart_uart_transmit_buffer_load ?
	       uart_uart_fifoXmit_D_OUT[6] :
	       uart_uart_vrXmitBuffer_7 ;
  assign uart_uart_vrXmitBuffer_6_EN =
	     WILL_FIRE_RL_uart_uart_transmit_buffer_load ||
	     WILL_FIRE_RL_uart_uart_transmit_buffer_shift ;

  // register uart_uart_vrXmitBuffer_7
  assign uart_uart_vrXmitBuffer_7_D_IN =
	     !WILL_FIRE_RL_uart_uart_transmit_buffer_load ||
	     uart_uart_fifoXmit_D_OUT[7] ;
  assign uart_uart_vrXmitBuffer_7_EN =
	     WILL_FIRE_RL_uart_uart_transmit_buffer_load ||
	     WILL_FIRE_RL_uart_uart_transmit_buffer_shift ;

  // submodule soc
  assign soc_correlator_master_ARREADY = correlator_master_ARREADY ;
  assign soc_correlator_master_AWREADY = correlator_master_AWREADY ;
  assign soc_correlator_master_BID = correlator_master_BID ;
  assign soc_correlator_master_BRESP = correlator_master_BRESP ;
  assign soc_correlator_master_BVALID = correlator_master_BVALID ;
  assign soc_correlator_master_RDATA = correlator_master_RDATA ;
  assign soc_correlator_master_RID = correlator_master_RID ;
  assign soc_correlator_master_RLAST = correlator_master_RLAST ;
  assign soc_correlator_master_RRESP = correlator_master_RRESP ;
  assign soc_correlator_master_RVALID = correlator_master_RVALID ;
  assign soc_correlator_master_WREADY = correlator_master_WREADY ;
  assign soc_gpio_io_gpio_in_inp = gpio_io_gpio_in_inp ;
  assign soc_interrupts_inp = interrupts_inp ;
  assign soc_uart_io_SIN = uart_uart_rXmitDataOut ;
  assign soc_wire_tdi_tdi_in = delayed_actor[0] ;
  assign soc_wire_tms_tms_in = delayed_actor[1] ;
  assign soc_EN_io_dump_get = CAN_FIRE_RL_write_dump_file ;

  // submodule tck_clk
  assign tck_clk_CLK_IN = delayed_actor2[2] ;
  assign tck_clk_COND_IN = 1'b0 ;
  assign tck_clk_CLK_IN_EN = rg_initial ;
  assign tck_clk_COND_IN_EN = 1'b0 ;

  // submodule trst
  assign trst_ASSERT_IN = rg_initial && delayed_actor2[4] ;

  // submodule uart_uart_baudGen_rBaudCounter
  assign uart_uart_baudGen_rBaudCounter_DATA_A = 16'd1 ;
  assign uart_uart_baudGen_rBaudCounter_DATA_B = 16'h0 ;
  assign uart_uart_baudGen_rBaudCounter_DATA_C = 16'h0 ;
  assign uart_uart_baudGen_rBaudCounter_DATA_F = 16'd0 ;
  assign uart_uart_baudGen_rBaudCounter_ADDA =
	     uart_uart_baudGen_rBaudCounter_value_PLUS_1_8__ETC___d30 ;
  assign uart_uart_baudGen_rBaudCounter_ADDB = 1'b0 ;
  assign uart_uart_baudGen_rBaudCounter_SETC = 1'b0 ;
  assign uart_uart_baudGen_rBaudCounter_SETF =
	     CAN_FIRE_RL_uart_uart_baudGen_count_baudtick_16x ;

  // submodule uart_uart_baudGen_rBaudTickCounter
  assign uart_uart_baudGen_rBaudTickCounter_DATA_A = 3'd1 ;
  assign uart_uart_baudGen_rBaudTickCounter_DATA_B = 3'h0 ;
  assign uart_uart_baudGen_rBaudTickCounter_DATA_C = 3'h0 ;
  assign uart_uart_baudGen_rBaudTickCounter_DATA_F = 3'h0 ;
  assign uart_uart_baudGen_rBaudTickCounter_ADDA =
	     CAN_FIRE_RL_uart_uart_baudGen_count_baudtick_16x ;
  assign uart_uart_baudGen_rBaudTickCounter_ADDB = 1'b0 ;
  assign uart_uart_baudGen_rBaudTickCounter_SETC = 1'b0 ;
  assign uart_uart_baudGen_rBaudTickCounter_SETF = 1'b0 ;

  // submodule uart_uart_fifoRecv
  assign uart_uart_fifoRecv_D_IN =
	     { uart_uart_vrRecvBuffer_7,
	       uart_uart_vrRecvBuffer_6,
	       uart_uart_vrRecvBuffer_5,
	       uart_uart_vrRecvBuffer_4,
	       uart_uart_vrRecvBuffer_3,
	       uart_uart_vrRecvBuffer_2,
	       uart_uart_vrRecvBuffer_1,
	       uart_uart_vrRecvBuffer_0 } ;
  assign uart_uart_fifoRecv_ENQ =
	     CAN_FIRE_RL_uart_uart_receive_stop_last_bit ;
  assign uart_uart_fifoRecv_DEQ = uart_uart_fifoRecv_r_deq_whas ;
  assign uart_uart_fifoRecv_CLR = 1'b0 ;

  // submodule uart_uart_fifoXmit
  assign uart_uart_fifoXmit_D_IN = 8'h0 ;
  assign uart_uart_fifoXmit_ENQ = 1'b0 ;
  assign uart_uart_fifoXmit_DEQ = CAN_FIRE_RL_uart_uart_transmit_buffer_load ;
  assign uart_uart_fifoXmit_CLR = 1'b0 ;

  // remaining internal signals
  assign _dor2uart_uart_pwXmitCellCountReset_EN_wset =
	     WILL_FIRE_RL_uart_uart_transmit_send_stop_bit2 ||
	     WILL_FIRE_RL_uart_uart_transmit_send_stop_bit ||
	     WILL_FIRE_RL_uart_uart_transmit_send_parity_bit ||
	     WILL_FIRE_RL_uart_uart_transmit_wait_1_bit_cell_time ||
	     WILL_FIRE_RL_uart_uart_transmit_send_start_bit ;
  assign data__h13998 =
	     uart_uart_fifoRecv_EMPTY_N ?
	       {8{uart_uart_fifoRecv_D_OUT}} :
	       64'd0 ;
  assign rg_cnt_72_ULT_5___d173 = rg_cnt < 5'd5 ;
  assign uart_uart_baudGen_rBaudCounter_value_PLUS_1_8__ETC___d30 =
	     uart_uart_baudGen_rBaudCounter_Q_OUT + 16'd1 < uart_baud_value ;
  assign x__h3566 = uart_uart_rRecvCellCount + 4'd1 ;
  assign x__h5270 = uart_uart_rRecvBitCount + 4'd1 ;
  assign x__h7026 = uart_uart_rXmitCellCount + 4'd1 ;
  assign x__h7052 = uart_uart_rXmitBitCount + 4'd1 ;
  assign x__read__h11422 =
	     { uart_uart_fifoRecv_EMPTY_N,
	       uart_uart_fifoRecv_FULL_N,
	       uart_uart_fifoXmit_FULL_N,
	       !uart_uart_fifoXmit_EMPTY_N && uart_uart_rXmitState == 3'd0 } ;
  assign z__h8509 =
	     uart_uart_fifoXmit_D_OUT[0] ^ uart_uart_fifoXmit_D_OUT[1] ;
  assign z__h8516 = z__h8509 ^ uart_uart_fifoXmit_D_OUT[2] ;
  assign z__h8523 = z__h8516 ^ uart_uart_fifoXmit_D_OUT[3] ;
  assign z__h8530 = z__h8523 ^ uart_uart_fifoXmit_D_OUT[4] ;
  assign z__h8537 = z__h8530 ^ uart_uart_fifoXmit_D_OUT[5] ;
  assign z__h8544 = z__h8537 ^ uart_uart_fifoXmit_D_OUT[6] ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        delayed_actor <= `BSV_ASSIGNMENT_DELAY 5'd0;
	delayed_actor2 <= `BSV_ASSIGNMENT_DELAY 5'd0;
	delayed_actor3 <= `BSV_ASSIGNMENT_DELAY 5'd0;
	delayed_actor4 <= `BSV_ASSIGNMENT_DELAY 5'd0;
	delayed_actor5 <= `BSV_ASSIGNMENT_DELAY 5'd0;
	dump <= `BSV_ASSIGNMENT_DELAY 32'd0;
	dump1 <= `BSV_ASSIGNMENT_DELAY 32'd0;
	rg_cnt <= `BSV_ASSIGNMENT_DELAY 5'd0;
	rg_read_rx <= `BSV_ASSIGNMENT_DELAY 1'd0;
	uart_baud_value <= `BSV_ASSIGNMENT_DELAY 16'd5;
	uart_uart_fifoRecv_countReg <= `BSV_ASSIGNMENT_DELAY 5'd0;
	uart_uart_fifoXmit_countReg <= `BSV_ASSIGNMENT_DELAY 5'd0;
	uart_uart_rRecvData <= `BSV_ASSIGNMENT_DELAY 1'd1;
      end
    else
      begin
        if (delayed_actor_EN)
	  delayed_actor <= `BSV_ASSIGNMENT_DELAY delayed_actor_D_IN;
	if (delayed_actor2_EN)
	  delayed_actor2 <= `BSV_ASSIGNMENT_DELAY delayed_actor2_D_IN;
	if (delayed_actor3_EN)
	  delayed_actor3 <= `BSV_ASSIGNMENT_DELAY delayed_actor3_D_IN;
	if (delayed_actor4_EN)
	  delayed_actor4 <= `BSV_ASSIGNMENT_DELAY delayed_actor4_D_IN;
	if (delayed_actor5_EN)
	  delayed_actor5 <= `BSV_ASSIGNMENT_DELAY delayed_actor5_D_IN;
	if (dump_EN) dump <= `BSV_ASSIGNMENT_DELAY dump_D_IN;
	if (dump1_EN) dump1 <= `BSV_ASSIGNMENT_DELAY dump1_D_IN;
	if (rg_cnt_EN) rg_cnt <= `BSV_ASSIGNMENT_DELAY rg_cnt_D_IN;
	if (rg_read_rx_EN)
	  rg_read_rx <= `BSV_ASSIGNMENT_DELAY rg_read_rx_D_IN;
	if (uart_baud_value_EN)
	  uart_baud_value <= `BSV_ASSIGNMENT_DELAY uart_baud_value_D_IN;
	if (uart_uart_fifoRecv_countReg_EN)
	  uart_uart_fifoRecv_countReg <= `BSV_ASSIGNMENT_DELAY
	      uart_uart_fifoRecv_countReg_D_IN;
	if (uart_uart_fifoXmit_countReg_EN)
	  uart_uart_fifoXmit_countReg <= `BSV_ASSIGNMENT_DELAY
	      uart_uart_fifoXmit_countReg_D_IN;
	if (uart_uart_rRecvData_EN)
	  uart_uart_rRecvData <= `BSV_ASSIGNMENT_DELAY
	      uart_uart_rRecvData_D_IN;
      end
    if (uart_uart_vrRecvBuffer_0_EN)
      uart_uart_vrRecvBuffer_0 <= `BSV_ASSIGNMENT_DELAY
	  uart_uart_vrRecvBuffer_0_D_IN;
    if (uart_uart_vrRecvBuffer_1_EN)
      uart_uart_vrRecvBuffer_1 <= `BSV_ASSIGNMENT_DELAY
	  uart_uart_vrRecvBuffer_1_D_IN;
    if (uart_uart_vrRecvBuffer_2_EN)
      uart_uart_vrRecvBuffer_2 <= `BSV_ASSIGNMENT_DELAY
	  uart_uart_vrRecvBuffer_2_D_IN;
    if (uart_uart_vrRecvBuffer_3_EN)
      uart_uart_vrRecvBuffer_3 <= `BSV_ASSIGNMENT_DELAY
	  uart_uart_vrRecvBuffer_3_D_IN;
    if (uart_uart_vrRecvBuffer_4_EN)
      uart_uart_vrRecvBuffer_4 <= `BSV_ASSIGNMENT_DELAY
	  uart_uart_vrRecvBuffer_4_D_IN;
    if (uart_uart_vrRecvBuffer_5_EN)
      uart_uart_vrRecvBuffer_5 <= `BSV_ASSIGNMENT_DELAY
	  uart_uart_vrRecvBuffer_5_D_IN;
    if (uart_uart_vrRecvBuffer_6_EN)
      uart_uart_vrRecvBuffer_6 <= `BSV_ASSIGNMENT_DELAY
	  uart_uart_vrRecvBuffer_6_D_IN;
    if (uart_uart_vrRecvBuffer_7_EN)
      uart_uart_vrRecvBuffer_7 <= `BSV_ASSIGNMENT_DELAY
	  uart_uart_vrRecvBuffer_7_D_IN;
    if (uart_uart_vrXmitBuffer_0_EN)
      uart_uart_vrXmitBuffer_0 <= `BSV_ASSIGNMENT_DELAY
	  uart_uart_vrXmitBuffer_0_D_IN;
    if (uart_uart_vrXmitBuffer_1_EN)
      uart_uart_vrXmitBuffer_1 <= `BSV_ASSIGNMENT_DELAY
	  uart_uart_vrXmitBuffer_1_D_IN;
    if (uart_uart_vrXmitBuffer_2_EN)
      uart_uart_vrXmitBuffer_2 <= `BSV_ASSIGNMENT_DELAY
	  uart_uart_vrXmitBuffer_2_D_IN;
    if (uart_uart_vrXmitBuffer_3_EN)
      uart_uart_vrXmitBuffer_3 <= `BSV_ASSIGNMENT_DELAY
	  uart_uart_vrXmitBuffer_3_D_IN;
    if (uart_uart_vrXmitBuffer_4_EN)
      uart_uart_vrXmitBuffer_4 <= `BSV_ASSIGNMENT_DELAY
	  uart_uart_vrXmitBuffer_4_D_IN;
    if (uart_uart_vrXmitBuffer_5_EN)
      uart_uart_vrXmitBuffer_5 <= `BSV_ASSIGNMENT_DELAY
	  uart_uart_vrXmitBuffer_5_D_IN;
    if (uart_uart_vrXmitBuffer_6_EN)
      uart_uart_vrXmitBuffer_6 <= `BSV_ASSIGNMENT_DELAY
	  uart_uart_vrXmitBuffer_6_D_IN;
    if (uart_uart_vrXmitBuffer_7_EN)
      uart_uart_vrXmitBuffer_7 <= `BSV_ASSIGNMENT_DELAY
	  uart_uart_vrXmitBuffer_7_D_IN;
  end

  always@(posedge CLK or `BSV_RESET_EDGE RST_N)
  if (RST_N == `BSV_RESET_VALUE)
    begin
      rg_client_fd <= `BSV_ASSIGNMENT_DELAY 32'hFFFFFFFF;
      rg_end_sim <= `BSV_ASSIGNMENT_DELAY 1'd0;
      rg_initial <= `BSV_ASSIGNMENT_DELAY 1'd0;
      uart_uart_rRecvBitCount <= `BSV_ASSIGNMENT_DELAY 4'd0;
      uart_uart_rRecvCellCount <= `BSV_ASSIGNMENT_DELAY 4'd0;
      uart_uart_rRecvParity <= `BSV_ASSIGNMENT_DELAY 1'd0;
      uart_uart_rRecvState <= `BSV_ASSIGNMENT_DELAY 3'd0;
      uart_uart_rXmitBitCount <= `BSV_ASSIGNMENT_DELAY 4'd0;
      uart_uart_rXmitCellCount <= `BSV_ASSIGNMENT_DELAY 4'd0;
      uart_uart_rXmitDataOut <= `BSV_ASSIGNMENT_DELAY 1'd1;
      uart_uart_rXmitParity <= `BSV_ASSIGNMENT_DELAY 1'd0;
      uart_uart_rXmitState <= `BSV_ASSIGNMENT_DELAY 3'd0;
    end
  else
    begin
      if (rg_client_fd_EN)
	rg_client_fd <= `BSV_ASSIGNMENT_DELAY rg_client_fd_D_IN;
      if (rg_end_sim_EN) rg_end_sim <= `BSV_ASSIGNMENT_DELAY rg_end_sim_D_IN;
      if (rg_initial_EN) rg_initial <= `BSV_ASSIGNMENT_DELAY rg_initial_D_IN;
      if (uart_uart_rRecvBitCount_EN)
	uart_uart_rRecvBitCount <= `BSV_ASSIGNMENT_DELAY
	    uart_uart_rRecvBitCount_D_IN;
      if (uart_uart_rRecvCellCount_EN)
	uart_uart_rRecvCellCount <= `BSV_ASSIGNMENT_DELAY
	    uart_uart_rRecvCellCount_D_IN;
      if (uart_uart_rRecvParity_EN)
	uart_uart_rRecvParity <= `BSV_ASSIGNMENT_DELAY
	    uart_uart_rRecvParity_D_IN;
      if (uart_uart_rRecvState_EN)
	uart_uart_rRecvState <= `BSV_ASSIGNMENT_DELAY
	    uart_uart_rRecvState_D_IN;
      if (uart_uart_rXmitBitCount_EN)
	uart_uart_rXmitBitCount <= `BSV_ASSIGNMENT_DELAY
	    uart_uart_rXmitBitCount_D_IN;
      if (uart_uart_rXmitCellCount_EN)
	uart_uart_rXmitCellCount <= `BSV_ASSIGNMENT_DELAY
	    uart_uart_rXmitCellCount_D_IN;
      if (uart_uart_rXmitDataOut_EN)
	uart_uart_rXmitDataOut <= `BSV_ASSIGNMENT_DELAY
	    uart_uart_rXmitDataOut_D_IN;
      if (uart_uart_rXmitParity_EN)
	uart_uart_rXmitParity <= `BSV_ASSIGNMENT_DELAY
	    uart_uart_rXmitParity_D_IN;
      if (uart_uart_rXmitState_EN)
	uart_uart_rXmitState <= `BSV_ASSIGNMENT_DELAY
	    uart_uart_rXmitState_D_IN;
    end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    delayed_actor = 5'h0A;
    delayed_actor2 = 5'h0A;
    delayed_actor3 = 5'h0A;
    delayed_actor4 = 5'h0A;
    delayed_actor5 = 5'h0A;
    dump = 32'hAAAAAAAA;
    dump1 = 32'hAAAAAAAA;
    rg_client_fd = 32'hAAAAAAAA;
    rg_cnt = 5'h0A;
    rg_end_sim = 1'h0;
    rg_initial = 1'h0;
    rg_read_rx = 1'h0;
    uart_baud_value = 16'hAAAA;
    uart_uart_fifoRecv_countReg = 5'h0A;
    uart_uart_fifoXmit_countReg = 5'h0A;
    uart_uart_rRecvBitCount = 4'hA;
    uart_uart_rRecvCellCount = 4'hA;
    uart_uart_rRecvData = 1'h0;
    uart_uart_rRecvParity = 1'h0;
    uart_uart_rRecvState = 3'h2;
    uart_uart_rXmitBitCount = 4'hA;
    uart_uart_rXmitCellCount = 4'hA;
    uart_uart_rXmitDataOut = 1'h0;
    uart_uart_rXmitParity = 1'h0;
    uart_uart_rXmitState = 3'h2;
    uart_uart_vrRecvBuffer_0 = 1'h0;
    uart_uart_vrRecvBuffer_1 = 1'h0;
    uart_uart_vrRecvBuffer_2 = 1'h0;
    uart_uart_vrRecvBuffer_3 = 1'h0;
    uart_uart_vrRecvBuffer_4 = 1'h0;
    uart_uart_vrRecvBuffer_5 = 1'h0;
    uart_uart_vrRecvBuffer_6 = 1'h0;
    uart_uart_vrRecvBuffer_7 = 1'h0;
    uart_uart_vrXmitBuffer_0 = 1'h0;
    uart_uart_vrXmitBuffer_1 = 1'h0;
    uart_uart_vrXmitBuffer_2 = 1'h0;
    uart_uart_vrXmitBuffer_3 = 1'h0;
    uart_uart_vrXmitBuffer_4 = 1'h0;
    uart_uart_vrXmitBuffer_5 = 1'h0;
    uart_uart_vrXmitBuffer_6 = 1'h0;
    uart_uart_vrXmitBuffer_7 = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    begin
      v__h11693 = $time;
      #0;
    end
    begin
      TASK_testplusargs___d165 = $test$plusargs("fullverbose");
      #0;
    end
    begin
      TASK_testplusargs___d166 = $test$plusargs("mtb");
      #0;
    end
    begin
      TASK_testplusargs___d167 = $test$plusargs("l0");
      #0;
    end
    begin
      v__h11763 = $time;
      #0;
    end
    if (TASK_testplusargs___d165 ||
	TASK_testplusargs___d166 && TASK_testplusargs___d167)
      $write("[%10d", v__h11763, "] ");
    if (TASK_testplusargs___d165 ||
	TASK_testplusargs___d166 && TASK_testplusargs___d167)
      $write("\n[%10d]", v__h11693);
    if (TASK_testplusargs___d165 ||
	TASK_testplusargs___d166 && TASK_testplusargs___d167)
      $write("\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_open_file_rtldump)
	begin
	  TASK_testplusargs___d174 = $test$plusargs("rtldump");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_open_file_rtldump && TASK_testplusargs___d174)
	begin
	  TASK_fopen___d175 = $fopen("rtl.dump", "w");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_open_file_rtldump && TASK_testplusargs___d174 &&
	  TASK_fopen___d175 == 32'd0)
	begin
	  TASK_testplusargs___d178 = $test$plusargs("fullverbose");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_open_file_rtldump && TASK_testplusargs___d174 &&
	  TASK_fopen___d175 == 32'd0)
	begin
	  TASK_testplusargs___d179 = $test$plusargs("mtb");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_open_file_rtldump && TASK_testplusargs___d174 &&
	  TASK_fopen___d175 == 32'd0)
	begin
	  TASK_testplusargs___d180 = $test$plusargs("l0");
	  #0;
	end
    TASK_fopen_75_EQ_0_76_AND_TASK_testplusargs_78_ETC___d183 =
	TASK_fopen___d175 == 32'd0 &&
	(TASK_testplusargs___d178 ||
	 TASK_testplusargs___d179 && TASK_testplusargs___d180);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_open_file_rtldump && TASK_testplusargs___d174 &&
	  TASK_fopen___d175 == 32'd0)
	begin
	  v__h12052 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_open_file_rtldump && TASK_testplusargs___d174 &&
	  TASK_fopen_75_EQ_0_76_AND_TASK_testplusargs_78_ETC___d183)
	$write("[%10d", v__h12052, "] ");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_open_file_rtldump && TASK_testplusargs___d174 &&
	  TASK_fopen_75_EQ_0_76_AND_TASK_testplusargs_78_ETC___d183)
	$write("TB: cannot open %s", "rtl.dump");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_open_file_rtldump && TASK_testplusargs___d174 &&
	  TASK_fopen_75_EQ_0_76_AND_TASK_testplusargs_78_ETC___d183)
	$write("\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_open_file_rtldump && TASK_testplusargs___d174 &&
	  TASK_fopen___d175 == 32'd0)
	$finish(32'd0);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_open_file_app)
	begin
	  TASK_fopen___d186 = $fopen("app_log", "w");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_open_file_app && TASK_fopen___d186 == 32'd0)
	begin
	  TASK_testplusargs___d188 = $test$plusargs("fullverbose");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_open_file_app && TASK_fopen___d186 == 32'd0)
	begin
	  TASK_testplusargs___d189 = $test$plusargs("mtb");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_open_file_app && TASK_fopen___d186 == 32'd0)
	begin
	  TASK_testplusargs___d190 = $test$plusargs("l0");
	  #0;
	end
    TASK_fopen_86_EQ_0_87_AND_TASK_testplusargs_88_ETC___d193 =
	TASK_fopen___d186 == 32'd0 &&
	(TASK_testplusargs___d188 ||
	 TASK_testplusargs___d189 && TASK_testplusargs___d190);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_open_file_app && TASK_fopen___d186 == 32'd0)
	begin
	  v__h12464 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_open_file_app &&
	  TASK_fopen_86_EQ_0_87_AND_TASK_testplusargs_88_ETC___d193)
	$write("[%10d", v__h12464, "] ");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_open_file_app &&
	  TASK_fopen_86_EQ_0_87_AND_TASK_testplusargs_88_ETC___d193)
	$write("TB: cannot open %s", "app_log");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_open_file_app &&
	  TASK_fopen_86_EQ_0_87_AND_TASK_testplusargs_88_ETC___d193)
	$write("\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_open_file_app && TASK_fopen___d186 == 32'd0)
	$finish(32'd0);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_write_dump_file)
	begin
	  TASK_testplusargs___d216 = $test$plusargs("rtldump");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_write_dump_file && TASK_testplusargs___d216)
	$fwrite(dump,
		soc_io_dump_get[167:166],
		" 0x%16h",
		soc_io_dump_get[165:102],
		" (0x%8h",
		soc_io_dump_get[101:70],
		")");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_write_dump_file && TASK_testplusargs___d216 &&
	  soc_io_dump_get[0])
	$fwrite(dump,
		" f%d",
		soc_io_dump_get[69:65],
		" 0x%16h",
		soc_io_dump_get[64:1],
		"\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_write_dump_file && TASK_testplusargs___d216 &&
	  !soc_io_dump_get[0])
	$fwrite(dump,
		" x%d",
		soc_io_dump_get[69:65],
		" 0x%16h",
		soc_io_dump_get[64:1],
		"\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_initial)
	begin
	  b__h16357 = $imported_init_rbb_jtag(1'd0);
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (rg_initial)
	begin
	  TASK_get_frame___d244 = $imported_get_frame(rg_client_fd);
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (rg_initial && delayed_actor5[3])
	$imported_send_tdo(soc_wire_tdo, rg_client_fd);
    if (RST_N != `BSV_RESET_VALUE)
      if (rg_initial && TASK_get_frame___d244[5]) $display("OpenOcd Exit");
    if (RST_N != `BSV_RESET_VALUE)
      if (rg_initial && TASK_get_frame___d244[5]) $finish(32'd1);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_write_received_character)
	$fwrite(dump1, "%c", data__h13998);
  end
  // synopsys translate_on
endmodule  // mkTbSoc

