//
// Generated by Bluespec Compiler, version 2021.07-1-gaf77efcd (build af77efcd)
//
// On Mon Dec  6 11:46:31 IST 2021
//
//
// Ports:
// Name                         I/O  size props
// RDY_debug_tdi_i                O     1 const
// RDY_bs_chain_i                 O     1 const
// tdo                            O     1 reg
// tdo_oe                         O     1
// RDY_tdo_oe                     O     1 const
// shift_dr                       O     1
// RDY_shift_dr                   O     1 const
// pause_dr                       O     1
// RDY_pause_dr                   O     1 const
// update_dr                      O     1
// RDY_update_dr                  O     1 const
// capture_dr                     O     1
// RDY_capture_dr                 O     1 const
// extest_select                  O     1
// RDY_extest_select              O     1 const
// sample_preload_select          O     1
// RDY_sample_preload_select      O     1 const
// debug_select                   O     1
// RDY_debug_select               O     1 const
// debug_tdo                      O     1
// RDY_debug_tdo                  O     1 const
// RDY_response_from_dm           O     1 reg
// request_to_dm                  O    40 reg
// RDY_request_to_dm              O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// tms_i_tms                      I     1
// tdi_i_tdi                      I     1
// debug_tdi_i_debug_tdi          I     1 reg
// bs_chain_i_bs_chain            I     1 reg
// response_from_dm_responsedm    I    34 reg
// EN_debug_tdi_i                 I     1
// EN_bs_chain_i                  I     1
// EN_response_from_dm            I     1
// EN_request_to_dm               I     1
//
// Combinational paths from inputs to outputs:
//   tdi_i_tdi -> debug_tdo
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkjtagdtm(CLK,
		 RST_N,

		 tms_i_tms,

		 tdi_i_tdi,

		 debug_tdi_i_debug_tdi,
		 EN_debug_tdi_i,
		 RDY_debug_tdi_i,

		 bs_chain_i_bs_chain,
		 EN_bs_chain_i,
		 RDY_bs_chain_i,

		 tdo,

		 tdo_oe,
		 RDY_tdo_oe,

		 shift_dr,
		 RDY_shift_dr,

		 pause_dr,
		 RDY_pause_dr,

		 update_dr,
		 RDY_update_dr,

		 capture_dr,
		 RDY_capture_dr,

		 extest_select,
		 RDY_extest_select,

		 sample_preload_select,
		 RDY_sample_preload_select,

		 debug_select,
		 RDY_debug_select,

		 debug_tdo,
		 RDY_debug_tdo,

		 response_from_dm_responsedm,
		 EN_response_from_dm,
		 RDY_response_from_dm,

		 EN_request_to_dm,
		 request_to_dm,
		 RDY_request_to_dm);
  input  CLK;
  input  RST_N;

  // action method tms_i
  input  tms_i_tms;

  // action method tdi_i
  input  tdi_i_tdi;

  // action method debug_tdi_i
  input  debug_tdi_i_debug_tdi;
  input  EN_debug_tdi_i;
  output RDY_debug_tdi_i;

  // action method bs_chain_i
  input  bs_chain_i_bs_chain;
  input  EN_bs_chain_i;
  output RDY_bs_chain_i;

  // value method tdo
  output tdo;

  // value method tdo_oe
  output tdo_oe;
  output RDY_tdo_oe;

  // value method shift_dr
  output shift_dr;
  output RDY_shift_dr;

  // value method pause_dr
  output pause_dr;
  output RDY_pause_dr;

  // value method update_dr
  output update_dr;
  output RDY_update_dr;

  // value method capture_dr
  output capture_dr;
  output RDY_capture_dr;

  // value method extest_select
  output extest_select;
  output RDY_extest_select;

  // value method sample_preload_select
  output sample_preload_select;
  output RDY_sample_preload_select;

  // value method debug_select
  output debug_select;
  output RDY_debug_select;

  // value method debug_tdo
  output debug_tdo;
  output RDY_debug_tdo;

  // action method response_from_dm
  input  [33 : 0] response_from_dm_responsedm;
  input  EN_response_from_dm;
  output RDY_response_from_dm;

  // actionvalue method request_to_dm
  input  EN_request_to_dm;
  output [39 : 0] request_to_dm;
  output RDY_request_to_dm;

  // signals for module outputs
  wire [39 : 0] request_to_dm;
  wire RDY_bs_chain_i,
       RDY_capture_dr,
       RDY_debug_select,
       RDY_debug_tdi_i,
       RDY_debug_tdo,
       RDY_extest_select,
       RDY_pause_dr,
       RDY_request_to_dm,
       RDY_response_from_dm,
       RDY_sample_preload_select,
       RDY_shift_dr,
       RDY_tdo_oe,
       RDY_update_dr,
       capture_dr,
       debug_select,
       debug_tdo,
       extest_select,
       pause_dr,
       sample_preload_select,
       shift_dr,
       tdo,
       tdo_oe,
       update_dr;

  // inlined wires
  reg [39 : 0] dmiaccess_shiftreg_port0__write_1;
  wire [39 : 0] dmiaccess_shiftreg_port1__read,
		dmiaccess_shiftreg_port1__write_1,
		dmiaccess_shiftreg_port2__read;
  wire dmiaccess_shiftreg_EN_port0__write,
       rg_dmireset_1_whas,
       wr_dmihardreset_generated_whas,
       wr_dmireset_generated_whas;

  // register bypass_sr
  reg bypass_sr;
  wire bypass_sr_D_IN, bypass_sr_EN;

  // register capture_repsonse_from_dm
  reg capture_repsonse_from_dm;
  reg capture_repsonse_from_dm_D_IN;
  wire capture_repsonse_from_dm_EN;

  // register dmiaccess_shiftreg
  reg [39 : 0] dmiaccess_shiftreg;
  wire [39 : 0] dmiaccess_shiftreg_D_IN;
  wire dmiaccess_shiftreg_EN;

  // register dmistat
  reg [1 : 0] dmistat;
  wire [1 : 0] dmistat_D_IN;
  wire dmistat_EN;

  // register dtmcontrol_shiftreg
  reg [31 : 0] dtmcontrol_shiftreg;
  wire [31 : 0] dtmcontrol_shiftreg_D_IN;
  wire dtmcontrol_shiftreg_EN;

  // register idcode_sr
  reg [31 : 0] idcode_sr;
  reg [31 : 0] idcode_sr_D_IN;
  wire idcode_sr_EN;

  // register instruction
  reg [4 : 0] instruction;
  wire [4 : 0] instruction_D_IN;
  wire instruction_EN;

  // register instruction_shiftreg
  reg [4 : 0] instruction_shiftreg;
  wire [4 : 0] instruction_shiftreg_D_IN;
  wire instruction_shiftreg_EN;

  // register response_status
  reg [1 : 0] response_status;
  wire [1 : 0] response_status_D_IN;
  wire response_status_EN;

  // register rg_dmihardreset
  reg rg_dmihardreset;
  wire rg_dmihardreset_D_IN, rg_dmihardreset_EN;

  // register rg_dmireset
  reg rg_dmireset;
  wire rg_dmireset_D_IN, rg_dmireset_EN;

  // register rg_tdo
  reg rg_tdo;
  wire rg_tdo_D_IN, rg_tdo_EN;

  // register tapstate
  reg [3 : 0] tapstate;
  reg [3 : 0] tapstate_D_IN;
  wire tapstate_EN;

  // register wr_bs_chain_tdi
  reg wr_bs_chain_tdi;
  wire wr_bs_chain_tdi_D_IN, wr_bs_chain_tdi_EN;

  // register wr_debug_tdi
  reg wr_debug_tdi;
  wire wr_debug_tdi_D_IN, wr_debug_tdi_EN;

  // ports of submodule invert_clock
  wire invert_clock_CLK_OUT;

  // ports of submodule invert_reset
  wire invert_reset_OUT_RST;

  // ports of submodule request_to_DM
  wire [39 : 0] request_to_DM_D_IN, request_to_DM_D_OUT;
  wire request_to_DM_CLR,
       request_to_DM_DEQ,
       request_to_DM_EMPTY_N,
       request_to_DM_ENQ,
       request_to_DM_FULL_N;

  // ports of submodule response_from_DM
  wire [33 : 0] response_from_DM_D_IN, response_from_DM_D_OUT;
  wire response_from_DM_CLR,
       response_from_DM_DEQ,
       response_from_DM_EMPTY_N,
       response_from_DM_ENQ,
       response_from_DM_FULL_N;

  // rule scheduling signals
  wire CAN_FIRE_RL_bypass_logic,
       CAN_FIRE_RL_crossed_bs_chain_tdi_clock_domain_crossing,
       CAN_FIRE_RL_crossed_bypass_sr_clock_domain_crossing,
       CAN_FIRE_RL_crossed_debug_tdi_clock_domain_crossing,
       CAN_FIRE_RL_crossed_dmiaccess_shiftreg_clock_domain_crossing,
       CAN_FIRE_RL_crossed_dtmcontrol_shiftreg_clock_domain_crossing,
       CAN_FIRE_RL_crossed_idcode_sr_clock_domain_crossing,
       CAN_FIRE_RL_crossed_instruction_clock_domain_crossing,
       CAN_FIRE_RL_crossed_instruction_shiftreg_clock_domain_crossing,
       CAN_FIRE_RL_crossed_output_tdo_clock_domain_crossing,
       CAN_FIRE_RL_crossed_tapstate_clock_domain_crossing,
       CAN_FIRE_RL_dmihardreset_generated,
       CAN_FIRE_RL_dmireset_generated,
       CAN_FIRE_RL_generate_tdo_outputpin,
       CAN_FIRE_RL_idcode_logic,
       CAN_FIRE_RL_just_display,
       CAN_FIRE_RL_rg_dmireset__dreg_update,
       CAN_FIRE_RL_shift_dmiaccess,
       CAN_FIRE_RL_shift_dtm,
       CAN_FIRE_RL_shift_reg,
       CAN_FIRE_RL_tap_state_machine,
       CAN_FIRE_RL_transfer_instruction_on_nedge,
       CAN_FIRE_bs_chain_i,
       CAN_FIRE_debug_tdi_i,
       CAN_FIRE_request_to_dm,
       CAN_FIRE_response_from_dm,
       CAN_FIRE_tdi_i,
       CAN_FIRE_tms_i,
       WILL_FIRE_RL_bypass_logic,
       WILL_FIRE_RL_crossed_bs_chain_tdi_clock_domain_crossing,
       WILL_FIRE_RL_crossed_bypass_sr_clock_domain_crossing,
       WILL_FIRE_RL_crossed_debug_tdi_clock_domain_crossing,
       WILL_FIRE_RL_crossed_dmiaccess_shiftreg_clock_domain_crossing,
       WILL_FIRE_RL_crossed_dtmcontrol_shiftreg_clock_domain_crossing,
       WILL_FIRE_RL_crossed_idcode_sr_clock_domain_crossing,
       WILL_FIRE_RL_crossed_instruction_clock_domain_crossing,
       WILL_FIRE_RL_crossed_instruction_shiftreg_clock_domain_crossing,
       WILL_FIRE_RL_crossed_output_tdo_clock_domain_crossing,
       WILL_FIRE_RL_crossed_tapstate_clock_domain_crossing,
       WILL_FIRE_RL_dmihardreset_generated,
       WILL_FIRE_RL_dmireset_generated,
       WILL_FIRE_RL_generate_tdo_outputpin,
       WILL_FIRE_RL_idcode_logic,
       WILL_FIRE_RL_just_display,
       WILL_FIRE_RL_rg_dmireset__dreg_update,
       WILL_FIRE_RL_shift_dmiaccess,
       WILL_FIRE_RL_shift_dtm,
       WILL_FIRE_RL_shift_reg,
       WILL_FIRE_RL_tap_state_machine,
       WILL_FIRE_RL_transfer_instruction_on_nedge,
       WILL_FIRE_bs_chain_i,
       WILL_FIRE_debug_tdi_i,
       WILL_FIRE_request_to_dm,
       WILL_FIRE_response_from_dm,
       WILL_FIRE_tdi_i,
       WILL_FIRE_tms_i;

  // inputs to muxes for submodule ports
  wire [1 : 0] MUX_response_status_write_1__VAL_2;
  wire MUX_capture_repsonse_from_dm_write_1__SEL_2;

  // declarations used by system tasks
  // synopsys translate_off
  reg TASK_testplusargs___d15;
  reg TASK_testplusargs___d16;
  reg TASK_testplusargs___d17;
  reg [63 : 0] v__h2627;
  reg TASK_testplusargs___d225;
  reg TASK_testplusargs___d226;
  reg TASK_testplusargs___d227;
  reg [63 : 0] v__h4481;
  reg TASK_testplusargs___d234;
  reg TASK_testplusargs___d235;
  reg TASK_testplusargs___d236;
  reg [63 : 0] v__h5003;
  reg TASK_testplusargs___d246;
  reg TASK_testplusargs___d247;
  reg TASK_testplusargs___d248;
  reg [63 : 0] v__h5195;
  reg TASK_testplusargs___d255;
  reg TASK_testplusargs___d256;
  reg TASK_testplusargs___d257;
  reg [63 : 0] v__h5441;
  reg TASK_testplusargs___d269;
  reg TASK_testplusargs___d270;
  reg TASK_testplusargs___d271;
  reg [63 : 0] v__h5521;
  reg TASK_testplusargs___d139;
  reg TASK_testplusargs___d140;
  reg TASK_testplusargs___d141;
  reg [63 : 0] v__h3298;
  reg response_from_DM_i_notEmpty__86_AND_TASK_testp_ETC___d230;
  reg response_from_DM_i_notEmpty__86_AND_TASK_testp_ETC___d239;
  reg NOT_response_from_DM_i_notEmpty__86_43_AND_TAS_ETC___d251;
  reg request_to_DM_i_notFull__90_AND_NOT_dmiaccess__ETC___d260;
  reg NOT_request_to_DM_i_notFull__90_64_OR_dmiacces_ETC___d274;
  reg TASK_testplusargs_5_OR_TASK_testplusargs_6_AND_ETC___d22;
  reg TASK_testplusargs_5_OR_TASK_testplusargs_6_AND_ETC___d24;
  reg TASK_testplusargs_5_OR_TASK_testplusargs_6_AND_ETC___d26;
  reg TASK_testplusargs_5_OR_TASK_testplusargs_6_AND_ETC___d28;
  reg TASK_testplusargs_5_OR_TASK_testplusargs_6_AND_ETC___d30;
  reg TASK_testplusargs_5_OR_TASK_testplusargs_6_AND_ETC___d32;
  reg TASK_testplusargs_5_OR_TASK_testplusargs_6_AND_ETC___d34;
  reg TASK_testplusargs_5_OR_TASK_testplusargs_6_AND_ETC___d36;
  reg TASK_testplusargs_5_OR_TASK_testplusargs_6_AND_ETC___d38;
  reg TASK_testplusargs_5_OR_TASK_testplusargs_6_AND_ETC___d40;
  reg TASK_testplusargs_5_OR_TASK_testplusargs_6_AND_ETC___d42;
  reg TASK_testplusargs_5_OR_TASK_testplusargs_6_AND_ETC___d44;
  reg TASK_testplusargs_5_OR_TASK_testplusargs_6_AND_ETC___d46;
  reg TASK_testplusargs_5_OR_TASK_testplusargs_6_AND_ETC___d48;
  reg TASK_testplusargs_5_OR_TASK_testplusargs_6_AND_ETC___d50;
  reg TASK_testplusargs_5_OR_TASK_testplusargs_6_AND_ETC___d80;
  // synopsys translate_on

  // remaining internal signals
  reg IF_instruction_EQ_0x1_02_THEN_crossed_idcode_s_ETC___d324;
  wire [39 : 0] x1__h4327, x1__h4732, x1__h5285;
  wire [33 : 0] x__h4715;
  wire [31 : 0] x__h3607, x__h3621, x__h5780;
  wire [27 : 0] r1__read__h3668;
  wire [21 : 0] r1__read__h3680;
  wire [19 : 0] r1__read__h3692;
  wire [16 : 0] r1__read__h3704;
  wire [15 : 0] r1__read__h3716;
  wire [14 : 0] r1__read__h3728;
  wire [4 : 0] x__h5585;
  wire [3 : 0] IF_wr_tms_whas__1_AND_wr_tms_wget__3_7_THEN_2__ETC___d114;
  wire [1 : 0] spliced_bits__h4792;
  wire crossed_instruction_wget__51_EQ_0x11_85_AND_NO_ETC___d267,
       crossed_instruction_wget__51_EQ_0x11_85_AND_re_ETC___d198,
       tapstate_EQ_3_7_AND_crossed_instruction_wget___ETC___d202,
       tapstate_EQ_3_7_AND_crossed_instruction_wget___ETC___d219,
       tapstate_EQ_3_7_AND_crossed_instruction_wget___ETC___d223,
       x__h983;

  // action method tms_i
  assign CAN_FIRE_tms_i = 1'd1 ;
  assign WILL_FIRE_tms_i = 1'd1 ;

  // action method tdi_i
  assign CAN_FIRE_tdi_i = 1'd1 ;
  assign WILL_FIRE_tdi_i = 1'd1 ;

  // action method debug_tdi_i
  assign RDY_debug_tdi_i = 1'd1 ;
  assign CAN_FIRE_debug_tdi_i = 1'd1 ;
  assign WILL_FIRE_debug_tdi_i = EN_debug_tdi_i ;

  // action method bs_chain_i
  assign RDY_bs_chain_i = 1'd1 ;
  assign CAN_FIRE_bs_chain_i = 1'd1 ;
  assign WILL_FIRE_bs_chain_i = EN_bs_chain_i ;

  // value method tdo
  assign tdo = rg_tdo ;

  // value method tdo_oe
  assign tdo_oe = tapstate == 4'd11 || tapstate == 4'd4 ;
  assign RDY_tdo_oe = 1'd1 ;

  // value method shift_dr
  assign shift_dr = tapstate == 4'd4 ;
  assign RDY_shift_dr = 1'd1 ;

  // value method pause_dr
  assign pause_dr = tapstate == 4'd6 ;
  assign RDY_pause_dr = 1'd1 ;

  // value method update_dr
  assign update_dr = tapstate == 4'd8 ;
  assign RDY_update_dr = 1'd1 ;

  // value method capture_dr
  assign capture_dr = tapstate == 4'd3 ;
  assign RDY_capture_dr = 1'd1 ;

  // value method extest_select
  assign extest_select = instruction == 5'h0 ;
  assign RDY_extest_select = 1'd1 ;

  // value method sample_preload_select
  assign sample_preload_select = instruction == 5'h02 ;
  assign RDY_sample_preload_select = 1'd1 ;

  // value method debug_select
  assign debug_select = instruction == 5'h08 ;
  assign RDY_debug_select = 1'd1 ;

  // value method debug_tdo
  assign debug_tdo = tdi_i_tdi ;
  assign RDY_debug_tdo = 1'd1 ;

  // action method response_from_dm
  assign RDY_response_from_dm = response_from_DM_FULL_N ;
  assign CAN_FIRE_response_from_dm = response_from_DM_FULL_N ;
  assign WILL_FIRE_response_from_dm = EN_response_from_dm ;

  // actionvalue method request_to_dm
  assign request_to_dm = request_to_DM_D_OUT ;
  assign RDY_request_to_dm = request_to_DM_EMPTY_N ;
  assign CAN_FIRE_request_to_dm = request_to_DM_EMPTY_N ;
  assign WILL_FIRE_request_to_dm = EN_request_to_dm ;

  // submodule invert_clock
  ClockInverter invert_clock(.CLK_IN(CLK),
			     .PREEDGE(),
			     .CLK_OUT(invert_clock_CLK_OUT));

  // submodule invert_reset
  SyncReset0 invert_reset(.IN_RST(RST_N), .OUT_RST(invert_reset_OUT_RST));

  // submodule request_to_DM
  FIFO1 #(.width(32'd40), .guarded(1'd0)) request_to_DM(.RST(RST_N),
							.CLK(CLK),
							.D_IN(request_to_DM_D_IN),
							.ENQ(request_to_DM_ENQ),
							.DEQ(request_to_DM_DEQ),
							.CLR(request_to_DM_CLR),
							.D_OUT(request_to_DM_D_OUT),
							.FULL_N(request_to_DM_FULL_N),
							.EMPTY_N(request_to_DM_EMPTY_N));

  // submodule response_from_DM
  FIFO1 #(.width(32'd34), .guarded(1'd0)) response_from_DM(.RST(RST_N),
							   .CLK(CLK),
							   .D_IN(response_from_DM_D_IN),
							   .ENQ(response_from_DM_ENQ),
							   .DEQ(response_from_DM_DEQ),
							   .CLR(response_from_DM_CLR),
							   .D_OUT(response_from_DM_D_OUT),
							   .FULL_N(response_from_DM_FULL_N),
							   .EMPTY_N(response_from_DM_EMPTY_N));

  // rule RL_just_display
  assign CAN_FIRE_RL_just_display = 1'd1 ;
  assign WILL_FIRE_RL_just_display = 1'd1 ;

  // rule RL_crossed_tapstate_clock_domain_crossing
  assign CAN_FIRE_RL_crossed_tapstate_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_crossed_tapstate_clock_domain_crossing = 1'd1 ;

  // rule RL_crossed_instruction_clock_domain_crossing
  assign CAN_FIRE_RL_crossed_instruction_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_crossed_instruction_clock_domain_crossing = 1'd1 ;

  // rule RL_crossed_instruction_shiftreg_clock_domain_crossing
  assign CAN_FIRE_RL_crossed_instruction_shiftreg_clock_domain_crossing =
	     1'd1 ;
  assign WILL_FIRE_RL_crossed_instruction_shiftreg_clock_domain_crossing =
	     1'd1 ;

  // rule RL_shift_reg
  assign CAN_FIRE_RL_shift_reg = 1'd1 ;
  assign WILL_FIRE_RL_shift_reg = 1'd1 ;

  // rule RL_crossed_bypass_sr_clock_domain_crossing
  assign CAN_FIRE_RL_crossed_bypass_sr_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_crossed_bypass_sr_clock_domain_crossing = 1'd1 ;

  // rule RL_bypass_logic
  assign CAN_FIRE_RL_bypass_logic = 1'd1 ;
  assign WILL_FIRE_RL_bypass_logic = 1'd1 ;

  // rule RL_crossed_idcode_sr_clock_domain_crossing
  assign CAN_FIRE_RL_crossed_idcode_sr_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_crossed_idcode_sr_clock_domain_crossing = 1'd1 ;

  // rule RL_idcode_logic
  assign CAN_FIRE_RL_idcode_logic = 1'd1 ;
  assign WILL_FIRE_RL_idcode_logic = 1'd1 ;

  // rule RL_crossed_bs_chain_tdi_clock_domain_crossing
  assign CAN_FIRE_RL_crossed_bs_chain_tdi_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_crossed_bs_chain_tdi_clock_domain_crossing = 1'd1 ;

  // rule RL_crossed_debug_tdi_clock_domain_crossing
  assign CAN_FIRE_RL_crossed_debug_tdi_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_crossed_debug_tdi_clock_domain_crossing = 1'd1 ;

  // rule RL_crossed_dtmcontrol_shiftreg_clock_domain_crossing
  assign CAN_FIRE_RL_crossed_dtmcontrol_shiftreg_clock_domain_crossing =
	     1'd1 ;
  assign WILL_FIRE_RL_crossed_dtmcontrol_shiftreg_clock_domain_crossing =
	     1'd1 ;

  // rule RL_shift_dtm
  assign CAN_FIRE_RL_shift_dtm = 1'd1 ;
  assign WILL_FIRE_RL_shift_dtm = 1'd1 ;

  // rule RL_dmihardreset_generated
  assign CAN_FIRE_RL_dmihardreset_generated = wr_dmihardreset_generated_whas ;
  assign WILL_FIRE_RL_dmihardreset_generated =
	     wr_dmihardreset_generated_whas && !EN_request_to_dm ;

  // rule RL_rg_dmireset__dreg_update
  assign CAN_FIRE_RL_rg_dmireset__dreg_update = 1'd1 ;
  assign WILL_FIRE_RL_rg_dmireset__dreg_update = 1'd1 ;

  // rule RL_crossed_output_tdo_clock_domain_crossing
  assign CAN_FIRE_RL_crossed_output_tdo_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_crossed_output_tdo_clock_domain_crossing = 1'd1 ;

  // rule RL_generate_tdo_outputpin
  assign CAN_FIRE_RL_generate_tdo_outputpin = 1'd1 ;
  assign WILL_FIRE_RL_generate_tdo_outputpin = 1'd1 ;

  // rule RL_transfer_instruction_on_nedge
  assign CAN_FIRE_RL_transfer_instruction_on_nedge = 1'd1 ;
  assign WILL_FIRE_RL_transfer_instruction_on_nedge = 1'd1 ;

  // rule RL_crossed_dmiaccess_shiftreg_clock_domain_crossing
  assign CAN_FIRE_RL_crossed_dmiaccess_shiftreg_clock_domain_crossing = 1'd1 ;
  assign WILL_FIRE_RL_crossed_dmiaccess_shiftreg_clock_domain_crossing =
	     1'd1 ;

  // rule RL_shift_dmiaccess
  assign CAN_FIRE_RL_shift_dmiaccess = !wr_dmihardreset_generated_whas ;
  assign WILL_FIRE_RL_shift_dmiaccess = CAN_FIRE_RL_shift_dmiaccess ;

  // rule RL_tap_state_machine
  assign CAN_FIRE_RL_tap_state_machine = 1'd1 ;
  assign WILL_FIRE_RL_tap_state_machine = 1'd1 ;

  // rule RL_dmireset_generated
  assign CAN_FIRE_RL_dmireset_generated = wr_dmireset_generated_whas ;
  assign WILL_FIRE_RL_dmireset_generated = wr_dmireset_generated_whas ;

  // inputs to muxes for submodule ports
  assign MUX_capture_repsonse_from_dm_write_1__SEL_2 =
	     WILL_FIRE_RL_shift_dmiaccess && tapstate != 4'd0 &&
	     tapstate_EQ_3_7_AND_crossed_instruction_wget___ETC___d219 ;
  assign MUX_response_status_write_1__VAL_2 =
	     response_from_DM_EMPTY_N ? spliced_bits__h4792 : 2'd3 ;

  // inlined wires
  assign wr_dmihardreset_generated_whas =
	     tapstate == 4'd8 && instruction == 5'h10 &&
	     dtmcontrol_shiftreg[17] ;
  assign wr_dmireset_generated_whas =
	     tapstate == 4'd8 && instruction == 5'h10 &&
	     dtmcontrol_shiftreg[16] ;
  assign rg_dmireset_1_whas =
	     tapstate == 4'd0 || tapstate == 4'd8 && instruction == 5'h10 ;
  assign dmiaccess_shiftreg_EN_port0__write =
	     WILL_FIRE_RL_shift_dmiaccess &&
	     (tapstate == 4'd0 ||
	      tapstate_EQ_3_7_AND_crossed_instruction_wget___ETC___d202) ;
  always@(tapstate or x1__h5285 or x1__h4732 or x1__h4327)
  begin
    case (tapstate)
      4'd0: dmiaccess_shiftreg_port0__write_1 = 40'd0;
      4'd3: dmiaccess_shiftreg_port0__write_1 = x1__h4732;
      4'd4: dmiaccess_shiftreg_port0__write_1 = x1__h4327;
      default: dmiaccess_shiftreg_port0__write_1 = x1__h5285;
    endcase
  end
  assign dmiaccess_shiftreg_port1__read =
	     dmiaccess_shiftreg_EN_port0__write ?
	       dmiaccess_shiftreg_port0__write_1 :
	       dmiaccess_shiftreg ;
  assign dmiaccess_shiftreg_port1__write_1 =
	     { dmiaccess_shiftreg_port1__read[39:2], 2'd0 } ;
  assign dmiaccess_shiftreg_port2__read =
	     wr_dmireset_generated_whas ?
	       dmiaccess_shiftreg_port1__write_1 :
	       dmiaccess_shiftreg_port1__read ;

  // register bypass_sr
  assign bypass_sr_D_IN = tapstate != 4'd0 && tapstate != 4'd3 && tdi_i_tdi ;
  assign bypass_sr_EN =
	     tapstate == 4'd0 ||
	     (tapstate == 4'd3 || tapstate == 4'd4) && instruction == 5'h1F ;

  // register capture_repsonse_from_dm
  always@(wr_dmireset_generated_whas or
	  MUX_capture_repsonse_from_dm_write_1__SEL_2 or
	  tapstate or WILL_FIRE_RL_dmihardreset_generated)
  case (1'b1)
    wr_dmireset_generated_whas: capture_repsonse_from_dm_D_IN = 1'd0;
    MUX_capture_repsonse_from_dm_write_1__SEL_2:
	capture_repsonse_from_dm_D_IN = tapstate != 4'd3;
    WILL_FIRE_RL_dmihardreset_generated: capture_repsonse_from_dm_D_IN = 1'd0;
    default: capture_repsonse_from_dm_D_IN = 1'bx /* unspecified value */ ;
  endcase
  assign capture_repsonse_from_dm_EN =
	     WILL_FIRE_RL_shift_dmiaccess && tapstate != 4'd0 &&
	     tapstate_EQ_3_7_AND_crossed_instruction_wget___ETC___d219 ||
	     WILL_FIRE_RL_dmihardreset_generated ||
	     wr_dmireset_generated_whas ;

  // register dmiaccess_shiftreg
  assign dmiaccess_shiftreg_D_IN = dmiaccess_shiftreg_port2__read ;
  assign dmiaccess_shiftreg_EN = 1'b1 ;

  // register dmistat
  assign dmistat_D_IN = spliced_bits__h4792 ;
  assign dmistat_EN =
	     WILL_FIRE_RL_shift_dmiaccess && tapstate == 4'd3 &&
	     instruction == 5'h11 &&
	     response_from_DM_EMPTY_N ;

  // register dtmcontrol_shiftreg
  assign dtmcontrol_shiftreg_D_IN = (tapstate == 4'd3) ? x__h3607 : x__h3621 ;
  assign dtmcontrol_shiftreg_EN =
	     (tapstate == 4'd3 || tapstate == 4'd4) && instruction == 5'h10 ;

  // register idcode_sr
  always@(tapstate or x__h5780)
  begin
    case (tapstate)
      4'd0, 4'd3: idcode_sr_D_IN = 32'h100039D3;
      default: idcode_sr_D_IN = x__h5780;
    endcase
  end
  assign idcode_sr_EN =
	     tapstate == 4'd0 ||
	     (tapstate == 4'd3 || tapstate == 4'd4) && instruction == 5'h01 ;

  // register instruction
  assign instruction_D_IN =
	     (tapstate == 4'd0) ? 5'h01 : instruction_shiftreg ;
  assign instruction_EN = tapstate == 4'd0 || tapstate == 4'd15 ;

  // register instruction_shiftreg
  assign instruction_shiftreg_D_IN =
	     (tapstate == 4'd10) ? 5'b10101 : x__h5585 ;
  assign instruction_shiftreg_EN = tapstate == 4'd10 || tapstate == 4'd11 ;

  // register response_status
  assign response_status_D_IN =
	     wr_dmireset_generated_whas ?
	       2'd0 :
	       MUX_response_status_write_1__VAL_2 ;
  assign response_status_EN =
	     WILL_FIRE_RL_shift_dmiaccess &&
	     tapstate_EQ_3_7_AND_crossed_instruction_wget___ETC___d223 ||
	     wr_dmireset_generated_whas ;

  // register rg_dmihardreset
  assign rg_dmihardreset_D_IN = tapstate != 4'd0 && dtmcontrol_shiftreg[17] ;
  assign rg_dmihardreset_EN = rg_dmireset_1_whas ;

  // register rg_dmireset
  assign rg_dmireset_D_IN = rg_dmireset_1_whas && x__h983 ;
  assign rg_dmireset_EN = 1'd1 ;

  // register rg_tdo
  assign rg_tdo_D_IN =
	     (tapstate == 4'd11) ?
	       instruction_shiftreg[0] :
	       IF_instruction_EQ_0x1_02_THEN_crossed_idcode_s_ETC___d324 ;
  assign rg_tdo_EN = 1'd1 ;

  // register tapstate
  always@(tapstate or
	  tms_i_tms or
	  IF_wr_tms_whas__1_AND_wr_tms_wget__3_7_THEN_2__ETC___d114)
  begin
    case (tapstate)
      4'd0: tapstate_D_IN = 4'd1;
      4'd1: tapstate_D_IN = 4'd2;
      4'd2: tapstate_D_IN = tms_i_tms ? 4'd9 : 4'd3;
      4'd3: tapstate_D_IN = tms_i_tms ? 4'd5 : 4'd4;
      4'd4: tapstate_D_IN = 4'd5;
      4'd5: tapstate_D_IN = tms_i_tms ? 4'd8 : 4'd6;
      4'd6: tapstate_D_IN = 4'd7;
      4'd7: tapstate_D_IN = tms_i_tms ? 4'd8 : 4'd4;
      4'd8, 4'd15:
	  tapstate_D_IN =
	      IF_wr_tms_whas__1_AND_wr_tms_wget__3_7_THEN_2__ETC___d114;
      4'd9: tapstate_D_IN = tms_i_tms ? 4'd0 : 4'd10;
      4'd10: tapstate_D_IN = tms_i_tms ? 4'd12 : 4'd11;
      4'd11: tapstate_D_IN = 4'd12;
      4'd12: tapstate_D_IN = tms_i_tms ? 4'd15 : 4'd13;
      4'd13: tapstate_D_IN = 4'd14;
      4'd14: tapstate_D_IN = tms_i_tms ? 4'd15 : 4'd11;
    endcase
  end
  assign tapstate_EN =
	     tapstate == 4'd0 && !tms_i_tms ||
	     tapstate != 4'd0 &&
	     (tapstate == 4'd1 && tms_i_tms ||
	      tapstate != 4'd1 &&
	      (tapstate == 4'd4 && tms_i_tms ||
	       tapstate != 4'd4 &&
	       (tapstate == 4'd6 && tms_i_tms ||
		tapstate != 4'd6 &&
		(tapstate == 4'd11 && tms_i_tms ||
		 tapstate != 4'd11 && (tms_i_tms || tapstate != 4'd13))))) ;

  // register wr_bs_chain_tdi
  assign wr_bs_chain_tdi_D_IN = bs_chain_i_bs_chain ;
  assign wr_bs_chain_tdi_EN = EN_bs_chain_i ;

  // register wr_debug_tdi
  assign wr_debug_tdi_D_IN = debug_tdi_i_debug_tdi ;
  assign wr_debug_tdi_EN = EN_debug_tdi_i ;

  // submodule request_to_DM
  assign request_to_DM_D_IN = dmiaccess_shiftreg ;
  assign request_to_DM_ENQ =
	     WILL_FIRE_RL_shift_dmiaccess && tapstate == 4'd8 &&
	     crossed_instruction_wget__51_EQ_0x11_85_AND_re_ETC___d198 ;
  assign request_to_DM_DEQ =
	     WILL_FIRE_RL_dmihardreset_generated || EN_request_to_dm ;
  assign request_to_DM_CLR = 1'b0 ;

  // submodule response_from_DM
  assign response_from_DM_D_IN = response_from_dm_responsedm ;
  assign response_from_DM_ENQ =
	     EN_response_from_dm && capture_repsonse_from_dm ;
  assign response_from_DM_DEQ =
	     WILL_FIRE_RL_shift_dmiaccess && tapstate == 4'd3 &&
	     instruction == 5'h11 &&
	     response_from_DM_EMPTY_N ||
	     WILL_FIRE_RL_dmihardreset_generated ;
  assign response_from_DM_CLR = 1'b0 ;

  // remaining internal signals
  assign IF_wr_tms_whas__1_AND_wr_tms_wget__3_7_THEN_2__ETC___d114 =
	     tms_i_tms ? 4'd2 : 4'd1 ;
  assign crossed_instruction_wget__51_EQ_0x11_85_AND_NO_ETC___d267 =
	     instruction == 5'h11 &&
	     (!request_to_DM_FULL_N || dmiaccess_shiftreg[1:0] == 2'd0 ||
	      capture_repsonse_from_dm) ;
  assign crossed_instruction_wget__51_EQ_0x11_85_AND_re_ETC___d198 =
	     instruction == 5'h11 && request_to_DM_FULL_N &&
	     dmiaccess_shiftreg[1:0] != 2'd0 &&
	     !capture_repsonse_from_dm ;
  assign r1__read__h3668 = { r1__read__h3680, 6'd6 } ;
  assign r1__read__h3680 = { r1__read__h3692, dmistat } ;
  assign r1__read__h3692 = { r1__read__h3704, 3'd7 } ;
  assign r1__read__h3704 = { r1__read__h3716, 1'd0 } ;
  assign r1__read__h3716 = { r1__read__h3728, rg_dmireset } ;
  assign r1__read__h3728 = { 14'd0, rg_dmihardreset } ;
  assign spliced_bits__h4792 = response_from_DM_D_OUT[1:0] | response_status ;
  assign tapstate_EQ_3_7_AND_crossed_instruction_wget___ETC___d202 =
	     tapstate == 4'd3 && instruction == 5'h11 &&
	     response_from_DM_EMPTY_N ||
	     tapstate == 4'd4 && instruction == 5'h11 ||
	     tapstate == 4'd8 &&
	     crossed_instruction_wget__51_EQ_0x11_85_AND_re_ETC___d198 ;
  assign tapstate_EQ_3_7_AND_crossed_instruction_wget___ETC___d219 =
	     tapstate == 4'd3 && instruction == 5'h11 &&
	     response_from_DM_EMPTY_N ||
	     tapstate == 4'd8 &&
	     crossed_instruction_wget__51_EQ_0x11_85_AND_re_ETC___d198 ;
  assign tapstate_EQ_3_7_AND_crossed_instruction_wget___ETC___d223 =
	     tapstate == 4'd3 && instruction == 5'h11 &&
	     (response_from_DM_EMPTY_N || capture_repsonse_from_dm) ;
  assign x1__h4327 = { tdi_i_tdi, dmiaccess_shiftreg[39:1] } ;
  assign x1__h4732 = { dmiaccess_shiftreg[39:34], x__h4715 } ;
  assign x1__h5285 = { dmiaccess_shiftreg[39:2], 2'd3 } ;
  assign x__h3607 = { r1__read__h3668, 4'd1 } ;
  assign x__h3621 = { tdi_i_tdi, dtmcontrol_shiftreg[31:1] } ;
  assign x__h4715 = { response_from_DM_D_OUT[33:2], spliced_bits__h4792 } ;
  assign x__h5585 = { tdi_i_tdi, instruction_shiftreg[4:1] } ;
  assign x__h5780 = { tdi_i_tdi, idcode_sr[31:1] } ;
  assign x__h983 = tapstate != 4'd0 && dtmcontrol_shiftreg[16] ;
  always@(instruction or
	  bypass_sr or
	  wr_bs_chain_tdi or
	  idcode_sr or
	  wr_debug_tdi or dtmcontrol_shiftreg or dmiaccess_shiftreg)
  begin
    case (instruction)
      5'h0, 5'h02:
	  IF_instruction_EQ_0x1_02_THEN_crossed_idcode_s_ETC___d324 =
	      wr_bs_chain_tdi;
      5'h01:
	  IF_instruction_EQ_0x1_02_THEN_crossed_idcode_s_ETC___d324 =
	      idcode_sr[0];
      5'h08:
	  IF_instruction_EQ_0x1_02_THEN_crossed_idcode_s_ETC___d324 =
	      wr_debug_tdi;
      5'h10:
	  IF_instruction_EQ_0x1_02_THEN_crossed_idcode_s_ETC___d324 =
	      dtmcontrol_shiftreg[0];
      5'h11:
	  IF_instruction_EQ_0x1_02_THEN_crossed_idcode_s_ETC___d324 =
	      dmiaccess_shiftreg[0];
      5'h1F:
	  IF_instruction_EQ_0x1_02_THEN_crossed_idcode_s_ETC___d324 =
	      bypass_sr;
      default: IF_instruction_EQ_0x1_02_THEN_crossed_idcode_s_ETC___d324 =
		   bypass_sr;
    endcase
  end

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        dmiaccess_shiftreg <= `BSV_ASSIGNMENT_DELAY 40'd2;
	response_status <= `BSV_ASSIGNMENT_DELAY 2'd0;
	rg_dmireset <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (dmiaccess_shiftreg_EN)
	  dmiaccess_shiftreg <= `BSV_ASSIGNMENT_DELAY dmiaccess_shiftreg_D_IN;
	if (response_status_EN)
	  response_status <= `BSV_ASSIGNMENT_DELAY response_status_D_IN;
	if (rg_dmireset_EN)
	  rg_dmireset <= `BSV_ASSIGNMENT_DELAY rg_dmireset_D_IN;
      end
  end

  always@(posedge CLK or `BSV_RESET_EDGE RST_N)
  if (RST_N == `BSV_RESET_VALUE)
    begin
      bypass_sr <= `BSV_ASSIGNMENT_DELAY 1'd0;
      capture_repsonse_from_dm <= `BSV_ASSIGNMENT_DELAY 1'd0;
      dmistat <= `BSV_ASSIGNMENT_DELAY 2'd0;
      dtmcontrol_shiftreg <= `BSV_ASSIGNMENT_DELAY 32'd28769;
      idcode_sr <= `BSV_ASSIGNMENT_DELAY 32'h100039D3;
      instruction_shiftreg <= `BSV_ASSIGNMENT_DELAY 5'd0;
      rg_dmihardreset <= `BSV_ASSIGNMENT_DELAY 1'd0;
      tapstate <= `BSV_ASSIGNMENT_DELAY 4'd0;
      wr_bs_chain_tdi <= `BSV_ASSIGNMENT_DELAY 1'd0;
      wr_debug_tdi <= `BSV_ASSIGNMENT_DELAY 1'd0;
    end
  else
    begin
      if (bypass_sr_EN) bypass_sr <= `BSV_ASSIGNMENT_DELAY bypass_sr_D_IN;
      if (capture_repsonse_from_dm_EN)
	capture_repsonse_from_dm <= `BSV_ASSIGNMENT_DELAY
	    capture_repsonse_from_dm_D_IN;
      if (dmistat_EN) dmistat <= `BSV_ASSIGNMENT_DELAY dmistat_D_IN;
      if (dtmcontrol_shiftreg_EN)
	dtmcontrol_shiftreg <= `BSV_ASSIGNMENT_DELAY dtmcontrol_shiftreg_D_IN;
      if (idcode_sr_EN) idcode_sr <= `BSV_ASSIGNMENT_DELAY idcode_sr_D_IN;
      if (instruction_shiftreg_EN)
	instruction_shiftreg <= `BSV_ASSIGNMENT_DELAY
	    instruction_shiftreg_D_IN;
      if (rg_dmihardreset_EN)
	rg_dmihardreset <= `BSV_ASSIGNMENT_DELAY rg_dmihardreset_D_IN;
      if (tapstate_EN) tapstate <= `BSV_ASSIGNMENT_DELAY tapstate_D_IN;
      if (wr_bs_chain_tdi_EN)
	wr_bs_chain_tdi <= `BSV_ASSIGNMENT_DELAY wr_bs_chain_tdi_D_IN;
      if (wr_debug_tdi_EN)
	wr_debug_tdi <= `BSV_ASSIGNMENT_DELAY wr_debug_tdi_D_IN;
    end

  always@(posedge invert_clock_CLK_OUT or
	  `BSV_RESET_EDGE invert_reset_OUT_RST)
  if (invert_reset_OUT_RST == `BSV_RESET_VALUE)
    begin
      instruction <= `BSV_ASSIGNMENT_DELAY 5'h01;
      rg_tdo <= `BSV_ASSIGNMENT_DELAY 1'd0;
    end
  else
    begin
      if (instruction_EN)
	instruction <= `BSV_ASSIGNMENT_DELAY instruction_D_IN;
      if (rg_tdo_EN) rg_tdo <= `BSV_ASSIGNMENT_DELAY rg_tdo_D_IN;
    end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    bypass_sr = 1'h0;
    capture_repsonse_from_dm = 1'h0;
    dmiaccess_shiftreg = 40'hAAAAAAAAAA;
    dmistat = 2'h2;
    dtmcontrol_shiftreg = 32'hAAAAAAAA;
    idcode_sr = 32'hAAAAAAAA;
    instruction = 5'h0A;
    instruction_shiftreg = 5'h0A;
    response_status = 2'h2;
    rg_dmihardreset = 1'h0;
    rg_dmireset = 1'h0;
    rg_tdo = 1'h0;
    tapstate = 4'hA;
    wr_bs_chain_tdi = 1'h0;
    wr_debug_tdi = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      begin
        TASK_testplusargs___d15 = $test$plusargs("fullverbose");
	#0;
      end
    if (RST_N != `BSV_RESET_VALUE)
      begin
        TASK_testplusargs___d16 = $test$plusargs("mjtag");
	#0;
      end
    if (RST_N != `BSV_RESET_VALUE)
      begin
        TASK_testplusargs___d17 = $test$plusargs("l0");
	#0;
      end
    TASK_testplusargs_5_OR_TASK_testplusargs_6_AND_ETC___d22 =
	(TASK_testplusargs___d15 ||
	 TASK_testplusargs___d16 && TASK_testplusargs___d17) &&
	tapstate == 4'd0;
    TASK_testplusargs_5_OR_TASK_testplusargs_6_AND_ETC___d24 =
	(TASK_testplusargs___d15 ||
	 TASK_testplusargs___d16 && TASK_testplusargs___d17) &&
	tapstate == 4'd1;
    TASK_testplusargs_5_OR_TASK_testplusargs_6_AND_ETC___d26 =
	(TASK_testplusargs___d15 ||
	 TASK_testplusargs___d16 && TASK_testplusargs___d17) &&
	tapstate == 4'd2;
    TASK_testplusargs_5_OR_TASK_testplusargs_6_AND_ETC___d28 =
	(TASK_testplusargs___d15 ||
	 TASK_testplusargs___d16 && TASK_testplusargs___d17) &&
	tapstate == 4'd3;
    TASK_testplusargs_5_OR_TASK_testplusargs_6_AND_ETC___d30 =
	(TASK_testplusargs___d15 ||
	 TASK_testplusargs___d16 && TASK_testplusargs___d17) &&
	tapstate == 4'd4;
    TASK_testplusargs_5_OR_TASK_testplusargs_6_AND_ETC___d32 =
	(TASK_testplusargs___d15 ||
	 TASK_testplusargs___d16 && TASK_testplusargs___d17) &&
	tapstate == 4'd5;
    TASK_testplusargs_5_OR_TASK_testplusargs_6_AND_ETC___d34 =
	(TASK_testplusargs___d15 ||
	 TASK_testplusargs___d16 && TASK_testplusargs___d17) &&
	tapstate == 4'd6;
    TASK_testplusargs_5_OR_TASK_testplusargs_6_AND_ETC___d36 =
	(TASK_testplusargs___d15 ||
	 TASK_testplusargs___d16 && TASK_testplusargs___d17) &&
	tapstate == 4'd7;
    TASK_testplusargs_5_OR_TASK_testplusargs_6_AND_ETC___d38 =
	(TASK_testplusargs___d15 ||
	 TASK_testplusargs___d16 && TASK_testplusargs___d17) &&
	tapstate == 4'd8;
    TASK_testplusargs_5_OR_TASK_testplusargs_6_AND_ETC___d46 =
	(TASK_testplusargs___d15 ||
	 TASK_testplusargs___d16 && TASK_testplusargs___d17) &&
	tapstate == 4'd12;
    TASK_testplusargs_5_OR_TASK_testplusargs_6_AND_ETC___d40 =
	(TASK_testplusargs___d15 ||
	 TASK_testplusargs___d16 && TASK_testplusargs___d17) &&
	tapstate == 4'd9;
    TASK_testplusargs_5_OR_TASK_testplusargs_6_AND_ETC___d42 =
	(TASK_testplusargs___d15 ||
	 TASK_testplusargs___d16 && TASK_testplusargs___d17) &&
	tapstate == 4'd10;
    TASK_testplusargs_5_OR_TASK_testplusargs_6_AND_ETC___d44 =
	(TASK_testplusargs___d15 ||
	 TASK_testplusargs___d16 && TASK_testplusargs___d17) &&
	tapstate == 4'd11;
    TASK_testplusargs_5_OR_TASK_testplusargs_6_AND_ETC___d48 =
	(TASK_testplusargs___d15 ||
	 TASK_testplusargs___d16 && TASK_testplusargs___d17) &&
	tapstate == 4'd13;
    TASK_testplusargs_5_OR_TASK_testplusargs_6_AND_ETC___d50 =
	(TASK_testplusargs___d15 ||
	 TASK_testplusargs___d16 && TASK_testplusargs___d17) &&
	tapstate == 4'd14;
    TASK_testplusargs_5_OR_TASK_testplusargs_6_AND_ETC___d80 =
	(TASK_testplusargs___d15 ||
	 TASK_testplusargs___d16 && TASK_testplusargs___d17) &&
	tapstate != 4'd0 &&
	tapstate != 4'd1 &&
	tapstate != 4'd2 &&
	tapstate != 4'd3 &&
	tapstate != 4'd4 &&
	tapstate != 4'd5 &&
	tapstate != 4'd6 &&
	tapstate != 4'd7 &&
	tapstate != 4'd8 &&
	tapstate != 4'd9 &&
	tapstate != 4'd10 &&
	tapstate != 4'd11 &&
	tapstate != 4'd12 &&
	tapstate != 4'd13 &&
	tapstate != 4'd14;
    if (RST_N != `BSV_RESET_VALUE)
      begin
        v__h2627 = $time;
	#0;
      end
    if (RST_N != `BSV_RESET_VALUE)
      if (TASK_testplusargs___d15 ||
	  TASK_testplusargs___d16 && TASK_testplusargs___d17)
	$write("[%10d", v__h2627, "] ");
    if (RST_N != `BSV_RESET_VALUE)
      if (TASK_testplusargs___d15 ||
	  TASK_testplusargs___d16 && TASK_testplusargs___d17)
	$write("\tTAPSTATE: ");
    if (RST_N != `BSV_RESET_VALUE)
      if (TASK_testplusargs_5_OR_TASK_testplusargs_6_AND_ETC___d22)
	$write("TestLogicReset");
    if (RST_N != `BSV_RESET_VALUE)
      if (TASK_testplusargs_5_OR_TASK_testplusargs_6_AND_ETC___d24)
	$write("RunTestIdle");
    if (RST_N != `BSV_RESET_VALUE)
      if (TASK_testplusargs_5_OR_TASK_testplusargs_6_AND_ETC___d26)
	$write("SelectDRScan");
    if (RST_N != `BSV_RESET_VALUE)
      if (TASK_testplusargs_5_OR_TASK_testplusargs_6_AND_ETC___d28)
	$write("CaptureDR");
    if (RST_N != `BSV_RESET_VALUE)
      if (TASK_testplusargs_5_OR_TASK_testplusargs_6_AND_ETC___d30)
	$write("ShiftDR");
    if (RST_N != `BSV_RESET_VALUE)
      if (TASK_testplusargs_5_OR_TASK_testplusargs_6_AND_ETC___d32)
	$write("Exit1DR");
    if (RST_N != `BSV_RESET_VALUE)
      if (TASK_testplusargs_5_OR_TASK_testplusargs_6_AND_ETC___d34)
	$write("PauseDR");
    if (RST_N != `BSV_RESET_VALUE)
      if (TASK_testplusargs_5_OR_TASK_testplusargs_6_AND_ETC___d36)
	$write("Exit2DR");
    if (RST_N != `BSV_RESET_VALUE)
      if (TASK_testplusargs_5_OR_TASK_testplusargs_6_AND_ETC___d38)
	$write("UpdateDR");
    if (RST_N != `BSV_RESET_VALUE)
      if (TASK_testplusargs_5_OR_TASK_testplusargs_6_AND_ETC___d40)
	$write("SelectIRScan");
    if (RST_N != `BSV_RESET_VALUE)
      if (TASK_testplusargs_5_OR_TASK_testplusargs_6_AND_ETC___d42)
	$write("CaptureIR");
    if (RST_N != `BSV_RESET_VALUE)
      if (TASK_testplusargs_5_OR_TASK_testplusargs_6_AND_ETC___d44)
	$write("ShiftIR");
    if (RST_N != `BSV_RESET_VALUE)
      if (TASK_testplusargs_5_OR_TASK_testplusargs_6_AND_ETC___d46)
	$write("Exit1IR");
    if (RST_N != `BSV_RESET_VALUE)
      if (TASK_testplusargs_5_OR_TASK_testplusargs_6_AND_ETC___d48)
	$write("PauseIR");
    if (RST_N != `BSV_RESET_VALUE)
      if (TASK_testplusargs_5_OR_TASK_testplusargs_6_AND_ETC___d50)
	$write("Exit2IR");
    if (RST_N != `BSV_RESET_VALUE)
      if (TASK_testplusargs_5_OR_TASK_testplusargs_6_AND_ETC___d80)
	$write("UpdateIR");
    if (RST_N != `BSV_RESET_VALUE)
      if (TASK_testplusargs___d15 ||
	  TASK_testplusargs___d16 && TASK_testplusargs___d17)
	$write("\tINSTRUCTION: %h", instruction_shiftreg);
    if (RST_N != `BSV_RESET_VALUE)
      if (TASK_testplusargs___d15 ||
	  TASK_testplusargs___d16 && TASK_testplusargs___d17)
	$write("\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_shift_dmiaccess && tapstate == 4'd3 &&
	  instruction == 5'h11 &&
	  response_from_DM_EMPTY_N)
	begin
	  TASK_testplusargs___d225 = $test$plusargs("fullverbose");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_shift_dmiaccess && tapstate == 4'd3 &&
	  instruction == 5'h11 &&
	  response_from_DM_EMPTY_N)
	begin
	  TASK_testplusargs___d226 = $test$plusargs("mjtag");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_shift_dmiaccess && tapstate == 4'd3 &&
	  instruction == 5'h11 &&
	  response_from_DM_EMPTY_N)
	begin
	  TASK_testplusargs___d227 = $test$plusargs("l0");
	  #0;
	end
    response_from_DM_i_notEmpty__86_AND_TASK_testp_ETC___d230 =
	response_from_DM_EMPTY_N &&
	(TASK_testplusargs___d225 ||
	 TASK_testplusargs___d226 && TASK_testplusargs___d227);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_shift_dmiaccess && tapstate == 4'd3 &&
	  instruction == 5'h11 &&
	  response_from_DM_EMPTY_N)
	begin
	  v__h4481 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_shift_dmiaccess && tapstate == 4'd3 &&
	  instruction == 5'h11 &&
	  response_from_DM_i_notEmpty__86_AND_TASK_testp_ETC___d230)
	$write("[%10d", v__h4481, "] ");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_shift_dmiaccess && tapstate == 4'd3 &&
	  instruction == 5'h11 &&
	  response_from_DM_i_notEmpty__86_AND_TASK_testp_ETC___d230)
	$write("\tDTM: Getting response: data %h op: %h",
	       response_from_DM_D_OUT[33:2],
	       response_from_DM_D_OUT[1:0]);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_shift_dmiaccess && tapstate == 4'd3 &&
	  instruction == 5'h11 &&
	  response_from_DM_i_notEmpty__86_AND_TASK_testp_ETC___d230)
	$write("\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_shift_dmiaccess && tapstate == 4'd3 &&
	  instruction == 5'h11 &&
	  response_from_DM_EMPTY_N)
	begin
	  TASK_testplusargs___d234 = $test$plusargs("fullverbose");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_shift_dmiaccess && tapstate == 4'd3 &&
	  instruction == 5'h11 &&
	  response_from_DM_EMPTY_N)
	begin
	  TASK_testplusargs___d235 = $test$plusargs("mjtag");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_shift_dmiaccess && tapstate == 4'd3 &&
	  instruction == 5'h11 &&
	  response_from_DM_EMPTY_N)
	begin
	  TASK_testplusargs___d236 = $test$plusargs("l0");
	  #0;
	end
    response_from_DM_i_notEmpty__86_AND_TASK_testp_ETC___d239 =
	response_from_DM_EMPTY_N &&
	(TASK_testplusargs___d234 ||
	 TASK_testplusargs___d235 && TASK_testplusargs___d236);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_shift_dmiaccess && tapstate == 4'd3 &&
	  instruction == 5'h11 &&
	  response_from_DM_EMPTY_N)
	begin
	  v__h5003 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_shift_dmiaccess && tapstate == 4'd3 &&
	  instruction == 5'h11 &&
	  response_from_DM_i_notEmpty__86_AND_TASK_testp_ETC___d239)
	$write("[%10d", v__h5003, "] ");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_shift_dmiaccess && tapstate == 4'd3 &&
	  instruction == 5'h11 &&
	  response_from_DM_i_notEmpty__86_AND_TASK_testp_ETC___d239)
	$write("\tDTM: New DMIACCESS value: %h", x__h4715);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_shift_dmiaccess && tapstate == 4'd3 &&
	  instruction == 5'h11 &&
	  response_from_DM_i_notEmpty__86_AND_TASK_testp_ETC___d239)
	$write("\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_shift_dmiaccess && tapstate == 4'd3 &&
	  instruction == 5'h11 &&
	  !response_from_DM_EMPTY_N)
	begin
	  TASK_testplusargs___d246 = $test$plusargs("fullverbose");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_shift_dmiaccess && tapstate == 4'd3 &&
	  instruction == 5'h11 &&
	  !response_from_DM_EMPTY_N)
	begin
	  TASK_testplusargs___d247 = $test$plusargs("mjtag");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_shift_dmiaccess && tapstate == 4'd3 &&
	  instruction == 5'h11 &&
	  !response_from_DM_EMPTY_N)
	begin
	  TASK_testplusargs___d248 = $test$plusargs("l0");
	  #0;
	end
    NOT_response_from_DM_i_notEmpty__86_43_AND_TAS_ETC___d251 =
	!response_from_DM_EMPTY_N &&
	(TASK_testplusargs___d246 ||
	 TASK_testplusargs___d247 && TASK_testplusargs___d248);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_shift_dmiaccess && tapstate == 4'd3 &&
	  instruction == 5'h11 &&
	  !response_from_DM_EMPTY_N)
	begin
	  v__h5195 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_shift_dmiaccess && tapstate == 4'd3 &&
	  instruction == 5'h11 &&
	  NOT_response_from_DM_i_notEmpty__86_43_AND_TAS_ETC___d251)
	$write("[%10d", v__h5195, "] ");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_shift_dmiaccess && tapstate == 4'd3 &&
	  instruction == 5'h11 &&
	  NOT_response_from_DM_i_notEmpty__86_43_AND_TAS_ETC___d251)
	$write("\tDTM: RESPONSE NOT AVAILABLE. DMIACCESS: %h",
	       dmiaccess_shiftreg);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_shift_dmiaccess && tapstate == 4'd3 &&
	  instruction == 5'h11 &&
	  NOT_response_from_DM_i_notEmpty__86_43_AND_TAS_ETC___d251)
	$write("\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_shift_dmiaccess && tapstate == 4'd8 &&
	  crossed_instruction_wget__51_EQ_0x11_85_AND_re_ETC___d198)
	begin
	  TASK_testplusargs___d255 = $test$plusargs("fullverbose");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_shift_dmiaccess && tapstate == 4'd8 &&
	  crossed_instruction_wget__51_EQ_0x11_85_AND_re_ETC___d198)
	begin
	  TASK_testplusargs___d256 = $test$plusargs("mjtag");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_shift_dmiaccess && tapstate == 4'd8 &&
	  crossed_instruction_wget__51_EQ_0x11_85_AND_re_ETC___d198)
	begin
	  TASK_testplusargs___d257 = $test$plusargs("l0");
	  #0;
	end
    request_to_DM_i_notFull__90_AND_NOT_dmiaccess__ETC___d260 =
	request_to_DM_FULL_N && dmiaccess_shiftreg[1:0] != 2'd0 &&
	!capture_repsonse_from_dm &&
	(TASK_testplusargs___d255 ||
	 TASK_testplusargs___d256 && TASK_testplusargs___d257);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_shift_dmiaccess && tapstate == 4'd8 &&
	  crossed_instruction_wget__51_EQ_0x11_85_AND_re_ETC___d198)
	begin
	  v__h5441 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_shift_dmiaccess && tapstate == 4'd8 &&
	  instruction == 5'h11 &&
	  request_to_DM_i_notFull__90_AND_NOT_dmiaccess__ETC___d260)
	$write("[%10d", v__h5441, "] ");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_shift_dmiaccess && tapstate == 4'd8 &&
	  instruction == 5'h11 &&
	  request_to_DM_i_notFull__90_AND_NOT_dmiaccess__ETC___d260)
	$write("\tDTM: Sending request to Debug: %h", dmiaccess_shiftreg);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_shift_dmiaccess && tapstate == 4'd8 &&
	  instruction == 5'h11 &&
	  request_to_DM_i_notFull__90_AND_NOT_dmiaccess__ETC___d260)
	$write("\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_shift_dmiaccess && tapstate == 4'd8 &&
	  crossed_instruction_wget__51_EQ_0x11_85_AND_NO_ETC___d267)
	begin
	  TASK_testplusargs___d269 = $test$plusargs("fullverbose");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_shift_dmiaccess && tapstate == 4'd8 &&
	  crossed_instruction_wget__51_EQ_0x11_85_AND_NO_ETC___d267)
	begin
	  TASK_testplusargs___d270 = $test$plusargs("mjtag");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_shift_dmiaccess && tapstate == 4'd8 &&
	  crossed_instruction_wget__51_EQ_0x11_85_AND_NO_ETC___d267)
	begin
	  TASK_testplusargs___d271 = $test$plusargs("l0");
	  #0;
	end
    NOT_request_to_DM_i_notFull__90_64_OR_dmiacces_ETC___d274 =
	(!request_to_DM_FULL_N || dmiaccess_shiftreg[1:0] == 2'd0 ||
	 capture_repsonse_from_dm) &&
	(TASK_testplusargs___d269 ||
	 TASK_testplusargs___d270 && TASK_testplusargs___d271);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_shift_dmiaccess && tapstate == 4'd8 &&
	  crossed_instruction_wget__51_EQ_0x11_85_AND_NO_ETC___d267)
	begin
	  v__h5521 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_shift_dmiaccess && tapstate == 4'd8 &&
	  instruction == 5'h11 &&
	  NOT_request_to_DM_i_notFull__90_64_OR_dmiacces_ETC___d274)
	$write("[%10d", v__h5521, "] ");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_shift_dmiaccess && tapstate == 4'd8 &&
	  instruction == 5'h11 &&
	  NOT_request_to_DM_i_notFull__90_64_OR_dmiacces_ETC___d274)
	$write("\tDTM: REQUEST NOT SERVED capture: %b DMIACCESS: %h",
	       capture_repsonse_from_dm,
	       dmiaccess_shiftreg);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_shift_dmiaccess && tapstate == 4'd8 &&
	  instruction == 5'h11 &&
	  NOT_request_to_DM_i_notFull__90_64_OR_dmiacces_ETC___d274)
	$write("\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (wr_dmireset_generated_whas)
	begin
	  TASK_testplusargs___d139 = $test$plusargs("fullverbose");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (wr_dmireset_generated_whas)
	begin
	  TASK_testplusargs___d140 = $test$plusargs("mjtag");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (wr_dmireset_generated_whas)
	begin
	  TASK_testplusargs___d141 = $test$plusargs("l0");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (wr_dmireset_generated_whas)
	begin
	  v__h3298 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (wr_dmireset_generated_whas &&
	  (TASK_testplusargs___d139 ||
	   TASK_testplusargs___d140 && TASK_testplusargs___d141))
	$write("[%10d", v__h3298, "] ");
    if (RST_N != `BSV_RESET_VALUE)
      if (wr_dmireset_generated_whas &&
	  (TASK_testplusargs___d139 ||
	   TASK_testplusargs___d140 && TASK_testplusargs___d141))
	$write("\tDTM: Received DMIRESET");
    if (RST_N != `BSV_RESET_VALUE)
      if (wr_dmireset_generated_whas &&
	  (TASK_testplusargs___d139 ||
	   TASK_testplusargs___d140 && TASK_testplusargs___d141))
	$write("\n");
  end
  // synopsys translate_on
endmodule  // mkjtagdtm

