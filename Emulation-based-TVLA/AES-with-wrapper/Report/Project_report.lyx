#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date true
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2.5cm
\topmargin 3.5cm
\rightmargin 2.5cm
\bottommargin 2.5cm
\headsep 0.5cm
\footskip 1cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Side-channel evaluation of Shakti's AES accelerators
\end_layout

\begin_layout Author
Surya Prasad S (Guided by Chester Rebeiro)
\end_layout

\begin_layout Standard
\align center
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://github.com/GnosGnas/Side-Channel-Analysis
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing single
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
Table of Contents
\end_layout

\end_inset


\size footnotesize

\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Power Analysis attacks have proven to be fatal to otherwise tamper-proof
 hardware.
 Non-invasive attacks like SPA and DPA are particularly dangerous as they
 can be easily reproduced and scaled.
 So, enter Test Vector Leakage Assessment Methodology (TVLA), a popular
 side-channel testing methodology as it can detect power leakages at any
 time of the operation irrespective of whether an attack can be successfully
 performed or not with that leakage.
 Test Vector Leakage Assessment (TVLA) aims to provide detection of information
 leakage using statistical analysis.
 We have done the TVLA test on Shakti's AES accelerators which can be integrated
 with the Shakti C-Class processor.
 The power consumption of our AES accelerators have been analysed extensively
 and optimisations are made to reduce power leakage.
 
\end_layout

\begin_layout Section
Overview
\end_layout

\begin_layout Subsection
AES Algorithm 
\end_layout

\begin_layout Standard
Advanced Encryption Standard, or AES, is a popular symmetric algorithm for
 encryption.
 Symmetric algorithms are named because they use the same cryptographic
 key for encryption and decryption.
 This comes with both advantages and disadvantages.
 From an implementation point of view, symmetric algorithms process much
 quicker than asymmetric algorithms, and a typical hardware accelerator
 takes only 12 cycles to complete one process.
\end_layout

\begin_layout Standard
The algorithm takes in a 128-bit input and generates a 128-bit output.
 AES is capable of using keys of length 128, 192 or 256 bits.
 The algorithm encrypts or decrypts by repeatedly applying a set of operations
 to the input data.
 The number of rounds of a process is fixed for each length of key:
\end_layout

\begin_layout Itemize
10 rounds for AES-128
\end_layout

\begin_layout Itemize
12 rounds for AES-192
\end_layout

\begin_layout Itemize
14 rounds for AES-256
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset

Figure 1 shows the structure of AES algorithm and specifies the operations
 in each round.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename report_pictures/AES_flow.png
	lyxscale 50
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Algorithmic structure of 128-bit AES
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard

\emph on
SubBytes
\emph default
 and 
\emph on
InvSubBytes
\emph default
 are two critical functions in encryption and decryption.
 They use the transformation function S-box, which consumes a great deal
 of power in the AES algorithm's hardware and software implementations.
\end_layout

\begin_layout Subsubsection
SubBytes
\end_layout

\begin_layout Standard

\emph on
SubBytes
\emph default
 transformation 
\begin_inset CommandInset citation
LatexCommand cite
key "key-1"
literal "false"

\end_inset

 is a non-linear byte substitution that maps one byte to another in 
\begin_inset Formula $GF(2^{8})$
\end_inset

.
 The mapping of each byte is done using an S-box which is defined over the
 irreducible polynomial, 
\begin_inset Formula $R(x)=x^{8}+x^{4}+x^{3}+x+1$
\end_inset

.
 The output of the S-box is defined as follows:
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Formula $SBox(a)=\begin{cases}
\begin{array}{c}
Ma^{-1}+N\\
N
\end{array} & \begin{array}{c}
if\:a\neq0\\
if\:a=0
\end{array}\end{cases}$
\end_inset


\end_layout

\begin_layout Standard
where M is an 
\begin_inset Formula $8x8$
\end_inset

 matrix, 
\begin_inset Formula $NâˆˆGF(2^{8})$
\end_inset

 and 
\begin_inset Formula $a^{-1}$
\end_inset

 is the multiplicative inverse in 
\begin_inset Formula $GF(2^{8})$
\end_inset

.
 
\end_layout

\begin_layout Standard
There exists an isomorphism between 
\begin_inset Formula $GF(2^{8})$
\end_inset

 and composite field of the same cardinality, which we have taken advantage
 of in our implementation.
 
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
AES S-box Table
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename report_pictures/sboxnew.png
	lyxscale 10
	scale 25

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
InvSubBytes 
\end_layout

\begin_layout Standard

\emph on
InvSubBytes
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "key-1"
literal "false"

\end_inset

 is the inverse of the byte substitution transformation and maps one byte
 to another using the inverse S-box.
 Inverse S-box is defined as follows:
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Formula $InvSBox(b)=\begin{cases}
\begin{array}{c}
M^{-1}(b+N)^{-1}\\
0
\end{array} & \begin{array}{c}
if\:b\neq N\\
if\:b=N
\end{array}\end{cases}$
\end_inset


\end_layout

\begin_layout Standard
where similar definitions are followed.
\end_layout

\begin_layout Standard
Here too we can utilize the isomorphism with composite field arithmetic.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
AES Inverse S-box Table
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename report_pictures/invsboxnew.png
	lyxscale 10
	scale 25

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Side-channel attacks
\end_layout

\begin_layout Standard
A side-channel attack attempts to gather information or influence the program
 execution of a system by measuring or exploiting the physical nature of
 the system or its hardware.
 There are various known attacks, and the most common attacks are:
\end_layout

\begin_layout Itemize
Timing attack
\end_layout

\begin_layout Itemize
Electromagnetic (EM) attack
\end_layout

\begin_layout Itemize
Simple Power Analysis (SPA)
\end_layout

\begin_layout Itemize
Differential Power Analysis (DPA)
\end_layout

\begin_layout Itemize
Template attack
\end_layout

\begin_layout Standard
In this section, we shall briefly cover SPA and DPA power attacks.
\end_layout

\begin_layout Subsubsection
Simple Power Analysis (SPA)
\end_layout

\begin_layout Standard
Simple Power Analysis (SPA) is a side-channel attack that involves visual
 examination of graphs of the current used by the device over time.
 Variations in the graph allow the attacker to determine the secret key.
 Very few power traces are required, and usually, a single plaintext is
 passed multiple times, and the mean power trace is analysed.
 Consider a SPA attack on the RSA algorithm, a popular asymmetric algorithm.
 Multiplication is carried out when the 
\begin_inset Formula $i_{th}$
\end_inset

 bit of the private key is one else a square operation is performed.
 So if the power trace of multiplication and square is differentiable, the
 attacker will be able to reveal the 
\begin_inset Formula $i_{th}$
\end_inset

 bit and eventually the attacker will be able to reveal the whole key.
\end_layout

\begin_layout Subsubsection
Differential Power Analysis (DPA)
\end_layout

\begin_layout Standard
Differential Power Analysis (DPA) attacks are among the most popular power
 analysis attacks.
 This is because the implementation details of the attacked device are not
 required in great detail.
 Furthermore, DPA can reveal the secret key even in the presence of a large
 amount of noise.
 In contrast to SPA attacks, DPA attacks would require a large number of
 traces.
 In a DPA attack 
\begin_inset CommandInset citation
LatexCommand cite
key "key-7"
literal "false"

\end_inset

, the attacker analyses how fixed time instances depend on the processed
 data.
 There are five steps involved:
\end_layout

\begin_layout Enumerate
Choose an intermediate result as a function 
\begin_inset Formula $f(d,k)$
\end_inset

, where 
\begin_inset Formula $d$
\end_inset

 is the data value (either plaintext or ciphertext) and 
\begin_inset Formula $k$
\end_inset

 is a byte of the key.
\end_layout

\begin_layout Enumerate
Measure the power consumption while running encryption or decryption on
 the device, and the data set can be represented as a 2-D array S[
\begin_inset Formula $N_{D}$
\end_inset

][
\begin_inset Formula $N_{T}$
\end_inset

], where 
\begin_inset Formula $N_{D}$
\end_inset

 is the total number of data values and 
\begin_inset Formula $N_{T}$
\end_inset

 is the total length of the trace.
\end_layout

\begin_layout Enumerate
Construct a differential average trace T from the data set S.
\end_layout

\begin_layout Enumerate
The intermediate results are then mapped to the hypothetical power consumption
 values, H.
\end_layout

\begin_layout Enumerate
Finally, the hypothetical values H are compared with the measured power
 consumption values using statistical tools like correlation and R matrix
 is generated.
 The indices of the highest values of the matrix R are used to reveal the
 positions at which the chosen intermediate result has been processed and
 the key used by the device.
 If all the values are approximately equal, then more traces are needed.
\end_layout

\begin_layout Subsubsection
NIST's Side-Channel Conformance Test
\end_layout

\begin_layout Standard
No testing program can guarantee resistance against all attacks, but a practical
 approach should be able to validate the security of the hardware implementation.
 The following are the requirements for an effective validation test 
\begin_inset CommandInset citation
LatexCommand cite
key "key-6"
literal "false"

\end_inset

:
\end_layout

\begin_layout Itemize
Effectiveness of tests: Reproducible results and reasonable conditions of
 testing
\end_layout

\begin_layout Itemize
Ease and cost-effectiveness of testing: Should not take an excessive amount
 of time or require exceptional test operator skills
\end_layout

\begin_layout Standard
Test Vector Leakage Assessment (TVLA) is a popular conformance style testing
 methodology recommended by NIST due to its robustness and ease of implementing
 and integrating it for various crypto-implementations with existing methodologi
es.
\end_layout

\begin_layout Subsubsection
Test Vector Leakage Assessment (TVLA)
\end_layout

\begin_layout Standard
TVLA uses Welch's t-test, a PASS/FAIL test that checks if t-value crosses
 a predefined threshold (proposed as 
\begin_inset Formula $\pm4.5$
\end_inset

).
 If the t-value crosses the threshold, there is a possibility of data leakage
 at that particular instant of time.
 It is to be noted that this is not sufficient to objectively tell that
 the device leaks data, which can be confirmed only by performing side-channel
 attacks.
 This is particularly true with processors as they may have multiple power
 leakage sources unrelated to the actual crypto-code that might be running.
 The testing strategy can be summarised as follows.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename report_pictures/TVLA_flow.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Testing methodology for non-specific TVLA
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The ideal TVLA score (maximum t-value) should be 0, and this is the case
 when the mean of two sets of power traces corresponding to a fixed input
 and a random input are equal, which implies that the power consumed by
 different inputs is the same on an average at any point of time.
 The t-values are given using the following equation as shown below.
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Formula $t=\frac{\mu_{A}-\mu_{B}}{\sqrt{\frac{\sigma_{A}^{2}}{n_{A}}+\frac{\sigma_{B}^{2}}{n_{B}}}}$
\end_inset

, where 
\begin_inset Formula $\mu$
\end_inset

 and 
\begin_inset Formula $\sigma$
\end_inset

 are mean and standard deviations of corresponding sets A and B.
\end_layout

\begin_layout Standard
Ideally, the variance for the fixed data should be 0, but there will be
 some variance due to physical randomness.
 High variance for fixed data will lead to a lower TVLA score which is expected
 as it implies higher unpredictability of identifying the immediate values.
 We also note the effect of the number of traces and theoritically the t-value
 increase proportional to 
\begin_inset Formula $\sqrt{n}$
\end_inset

, where 
\begin_inset Formula $n$
\end_inset

 is the number of traces.
\end_layout

\begin_layout Standard
There are two main categories of detection through TVLA.
 There is general, and there is specific detection.
 The general case involves feeding in fixed and random data set as inputs
 to the crypto-module and collecting traces for each cipher process.
 Specific detection usually is targetting an intermediate in a cryptographic
 algorithm.
 The target could be S-box outputs, round outputs, or an add-key operation.
 A random vs random data set is sufficient for this test.
 Both tests use a fixed key.
 We perform general detection on our AES accelerators with a fixed vs random
 data set and a fixed key for this project.
\end_layout

\begin_layout Section
Shakti's AES Accelerator
\end_layout

\begin_layout Standard
There are three implementations of AES Accelerator made for the Shakti C-Class
 processor.
 These three give the same output for the same input, and they vary only
 in their implementation.
 This section will briefly discuss the differences and how we could interface
 them for side-channel analysis.
\end_layout

\begin_layout Subsection
Lookup-table Based Implementation
\end_layout

\begin_layout Standard
This implementation uses an optimised implementation of Lookup-table based
 S-box for AES accelerator.
 Each input byte is mapped to an output byte explicitly in case constructs.
 LUT based S-box uses much higher number of LUTs on the FPGA and are not
 side-channel protected and can show significant differences in power consumptio
n for different inputs.
 Figure 3 shows two traces for different inputs and they are fairly easy
 to distinguish visually.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename report_pictures/snapstvla/sbox1_unmod1.png
	lyxscale 10
	scale 15

\end_inset

 
\begin_inset Graphics
	filename report_pictures/snapstvla/sbox1_unmod2.png
	lyxscale 10
	scale 15

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Plots of two traces of LUT based AES to show how the plots change for different
 inputs
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Composite Field Implementation
\end_layout

\begin_layout Standard
As discussed earlier, here, we use composite field arithmetic to reduce
 the byte-to-byte mapping to simpler operations.
 This allows for modifications for side-channel resistance, and based on
 our previous research 
\begin_inset CommandInset citation
LatexCommand cite
key "key-1"
literal "false"

\end_inset

, we found it to occupy a lesser area.
 Our implementation of Forward S-box uses only 39 LUTs.
 The rest of the modules for both Composite Field and Lookup-table based
 implementations are the same.
\end_layout

\begin_layout Standard
In Composite Field theory, a higher dimension vector is projected to components
 of vectors in the lower dimensions.
 We can then derive efficient computations otherwise cumbersome in the original
 higher dimension space.
 
\begin_inset Formula $GF(2^{8})$
\end_inset

 involves expensive inverse multiplication and can be reduced to inverse
 operations in 
\begin_inset Formula $GF(2^{4})$
\end_inset

.
 
\begin_inset Formula $GF(2^{4})$
\end_inset

 can be further reduced to 
\begin_inset Formula $GF(2^{2})$
\end_inset

, but 
\begin_inset Formula $GF(2^{4})$
\end_inset

 is more suitable for FPGAs for their 4/6-input LUTs and 
\begin_inset Formula $GF(2^{2})$
\end_inset

 operations are more suited for ASICs.
 
\end_layout

\begin_layout Standard
For our composite field 
\begin_inset Formula $GF((2^{4})^{2})$
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "key-1"
literal "false"

\end_inset

, these are the irreducible polynomials used.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename report_pictures/pasted1.png
	lyxscale 30
	scale 30

\end_inset


\end_layout

\begin_layout Standard
where P(y) and Q(z) are the polynomials and g1, g2 are generators for the
 composite and AES field.
\end_layout

\begin_layout Standard
We can see from the plots in Figure 4 how similar the traces are for different
 inputs.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename report_pictures/snapstvla/sbox2_unmod.png
	lyxscale 10
	scale 15

\end_inset

 
\begin_inset Graphics
	filename report_pictures/snapstvla/sbox2_unmod2.png
	lyxscale 10
	scale 15

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Plots of two traces of Composite AES to show how the plots change for different
 inputs
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the 
\emph on
SubBytes
\emph default
 stage, the 128-bit text is split into 16 bytes and each is fed into one
 S-box.
 S-boxes are also used in Key generation modules.
 In our implementation, Key generation is done separately before the cipher
 process as the same set of round keys are used for all the processes.
 The main component of the 11 peaks in the power trace is the 16 S-box transform
ations in each round.
\end_layout

\begin_layout Subsection
Threshold Implementation
\end_layout

\begin_layout Standard
Threshold implementation 
\begin_inset CommandInset citation
LatexCommand cite
key "key-11"
literal "false"

\end_inset

 of AES is built to ensure more security of the S-box.
 Each input to the S-box, 
\begin_inset Formula $X$
\end_inset

, is split across 
\begin_inset Formula $n$
\end_inset

 shares such that they follow the following property:
\end_layout

\begin_layout Standard
\noindent

\size large
\begin_inset Formula 
\begin{equation}
\sum_{i=1}^{n}X_{i}=X
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\noindent

\size large
\begin_inset Formula 
\begin{equation}
\sum_{i=1}^{n}F(X_{i})=F(X)=Y
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Additionally, even the output can be shared across 
\begin_inset Formula $m$
\end_inset

 shares which sum up to give 
\begin_inset Formula $Y$
\end_inset

.
\end_layout

\begin_layout Standard
\noindent

\size large
\begin_inset Formula 
\begin{equation}
\sum_{i=1}^{m}Y_{i}=Y\:whereY_{i}=F_{i}(X_{1},X_{2},X_{3},...,X_{n})
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
The function 
\begin_inset Formula $F_{i}$
\end_inset

 is identified such that it is independent of the input 
\begin_inset Formula $X_{i}$
\end_inset

.
 This ensures that when each share is being executed a particular 
\begin_inset Formula $X$
\end_inset

 component is not revealed.
 This uniform masking makes the leaking signal almost a constant at all
 instants of time.
 
\end_layout

\begin_layout Standard
Plots are added below in Figure 5, but it is difficult to differentiate
 between them due to very low increase in power consumption.
 The low power consumption is because only one S-box runs in a cycle.
 The S-box for threshold implementation consumes more resources than the
 Composite Field based S-box, and hence this strategy was followed.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename report_pictures/snapstvla/thresh_unmod1.png
	lyxscale 10
	scale 15

\end_inset

 
\begin_inset Graphics
	filename report_pictures/snapstvla/thresh_unmod2.png
	lyxscale 10
	scale 15

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Plots of two traces of Threshold AES to show how the plots change for different
 inputs
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Implementation details
\end_layout

\begin_layout Standard
In this section, we briefly describe the implementation aspects of the three
 accelerators.
 Among them, Lookup-table based and Composite Field implementations use
 typical AES top modules while Threshold implementatioon uses a different
 set of top modules.
 As discussed earlier, the only difference between the the top modules is
 that the typical version uses 16 S-boxes in parallel while the other uses
 only one.
 Typical AES accelerator can be embedded with either LUT based or Composite
 S-box.
\end_layout

\begin_layout Standard
The modules for typical AES accelerator have been modified for ease of usage
 so that only the imported module needs to be changed to switch between
 the S-box modules.
 The following figure shows the methods of the top modules which are used
 for one cipher process.
 
\begin_inset Quotes eld
\end_inset

genKeys
\begin_inset Quotes erd
\end_inset

 is used to initiate key generation, 
\begin_inset Quotes eld
\end_inset

encrypt
\begin_inset Quotes erd
\end_inset

 is used to pass the plaintext for processing and 
\begin_inset Quotes eld
\end_inset

ret
\begin_inset Quotes erd
\end_inset

 returns the output of the cipher process.
 Other methods are also present which can be used to check the status of
 the process.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename report_pictures/typical_top.png
	scale 40

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Flow diagram for Typical AES module
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Threshold's top module is slightly different as here the 
\begin_inset Quotes eld
\end_inset

encrypt
\begin_inset Quotes erd
\end_inset

 method additionally checks if the Key received has been expanded before
 and then continues with the cipher process.
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename report_pictures/thresh_top.png
	scale 40

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Flow diagram for Threshold AES module
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
Following table sums up the different physical aspects of each implementation.
 The hardware utilisations and maximum operable frequency of each accelerator
 was found by implementing the accelerators on our FPGA.
 The wrapper module used here is Wrapper2 and details about wrapper modules
 and FPGA are discussed in the next section.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename report_pictures/acc_imp.png
	lyxscale 50
	scale 40

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Side-channel evaluation of accelerators
\end_layout

\begin_layout Standard
\noindent
\align center
This section covers the setup followed for the side-channel evaluation of
 our AES accelerator.
 Similar procedure can be followed for other accelerators too.
 The following are the steps involved:
\end_layout

\begin_layout Itemize
Make a wrapper module for the accelerators to feed the inputs to the crypto-modu
le
\end_layout

\begin_layout Itemize
Configure the module for the FPGA with another Top file
\end_layout

\begin_layout Itemize
Configure the oscilloscope as required and program the FPGA with our module
\end_layout

\begin_layout Itemize
Collect the traces and evaluate the TVLA score using Python scripts
\end_layout

\begin_layout Standard
We begin by making a wrapper module for the accelerators discussed in the
 previous section.
 All the modules of the accelerator and wrapper are written in Bluespec
 SystemVerilog and Verilog files are generated from this.
 The top module for configuring the FPGA is written in Verilog HDL.
\end_layout

\begin_layout Standard
Two wrapper modules were made using different approaches.
 For Wrapper1, we have four stages as shown in Figure 8 and for Wrapper2,
 we have five stages as shown in Figure 9.
 Details about the wrappers have been given later.
\end_layout

\begin_layout Standard
We use the SASEBO-GIII board as the platform for evaluation and the Teledyne
 LeCroy HDO4104 oscilloscope for collecting traces.
 After that, the Python script is run to compute the TVLA score for each
 set of traces.
 More details are provided in the following subsections.
\end_layout

\begin_layout Subsection
AES Wrapper modules
\end_layout

\begin_layout Standard
There are multiple ways to pass the inputs, and we have chosen to create
 a wrapper file for the accelerator to feed fixed and random inputs to the
 core module.
 Random inputs are generated by feeding the cipher output of the previous
 random input.
 This is in conformance with NIST standards.
 We have made two variants to compare the effects: in one (Wrapper1), the
 output of the encryption/decryption was stored in a 128-bit register within
 the trigger along with other register updates, and in the other (Wrapper2),
 the total number of flip-flop changes in the wrapper module was limited
 to 2 bits within the trigger.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename report_pictures/wrapper1.png
	lyxscale 40
	scale 35

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Working of Wrapper1 module 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
As can be seen from Figure 8, Wrapper1 is a simple module with four stages
 and three of them repeating till n inputs have been fed.
 The delay stage is very crucial as the oscilloscope needs some time between
 two traces to properly store the power values.
 In Figure 9, the working of Wrapper2 module is shown and the main difference
 is that the cipher process is repeated twice.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename report_pictures/wrapper2.jpg
	lyxscale 40
	scale 35

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Working of Wrapper2 module
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
SASEBO-GIII board
\end_layout

\begin_layout Standard
The SASEBO-GIII is a successor of the SASEBO-GII board and is for further
 side-channel attack experimentation.
 The basic features of SASEBO-GIII are as follows:
\end_layout

\begin_layout Itemize
200 mm x 150 mm x 1.6mm, FR-4, eight layers
\end_layout

\begin_layout Itemize
Two Xilinx FPGAs:
\end_layout

\begin_deeper
\begin_layout Itemize
Cryptographic FPGA: Kintex-7 XC7K160T-1FBGC (part no.: xc7k160tfbg676-1)
 
\end_layout

\begin_layout Itemize
Control FPGA: Spartan-6 XC6LX45-2FGG484C
\end_layout

\end_deeper
\begin_layout Itemize
Differential clock at frequency of 200 Mhz.
\end_layout

\begin_layout Itemize
1 Gigabit DDR3 SDRAM
\end_layout

\begin_layout Itemize
The external power source supplies the onboard power regulators and the
 FPGAs with 5.0 V
\end_layout

\begin_layout Itemize
A shunt resistor is provided to insert on the core VDD line of the cryptographic
 FPGA for measuring power traces.
 
\end_layout

\begin_layout Standard
The host PC controls and communicates with the board via the J-TAG port.
 The FPGA is default programmed with the vendor's Bit file.
 The default Bit file can be found on the company's website and can be used
 to collect traces using the C# project, SASEBO G-CHECKER.
 
\end_layout

\begin_layout Standard
For this project, Xilinx Vivado 2020.1 was used to program the Kintex-7 FPGA
 with our AES accelerator.
 The SASEBO Board uses a differential clock and it needs to be converted
 into single-ended clock using a clock wizard.
 In Vivado 2020.1, it can be found as the Xilinx IP, clk_wizard.
 The single-ended clock can be configured for frequencies from 4.7 MHz to
 800 MHz.
 Differential clocks have the advantage that it is based on the difference
 between two signals and are less affected by noise, and require lower supply
 voltages.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename report_pictures/single_ended.png
	scale 40

\end_inset

 
\begin_inset Graphics
	filename report_pictures/differential.png
	scale 40

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Distinctions between a single-ended and differential clock
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Oscilloscope
\end_layout

\begin_layout Standard
Teledyne LeCroy HDO4104 was used for collecting the power traces from the
 FPGA.
 Important features of this oscilloscope are as follows:
\end_layout

\begin_layout Itemize
Bandwidth of 
\begin_inset Formula $1GHz$
\end_inset

 
\end_layout

\begin_layout Itemize
Maximum sampling rate of 
\begin_inset Formula $2.5GS/s$
\end_inset

 
\end_layout

\begin_layout Itemize
Resolution of 12 bits
\end_layout

\begin_layout Itemize
Four input channels
\end_layout

\begin_layout Itemize
Processor/CPU - Intel Celeron B810 Dual-Core, 1.6GHz
\end_layout

\begin_layout Itemize
Memory of 4GB RAM and 500GB disk
\end_layout

\begin_layout Itemize
Oscilloscope Operating Software - Teledyne LeCroy MAUI with OneTouch
\end_layout

\begin_layout Standard
Other features also exist, such as trigger types, filters for analysis and
 remote control setup.
 The oscilloscope uses an initial setup file, aes-initial-verilog--00000.lss.
 This uses default configurations and sets all the system variables.
\end_layout

\begin_layout Standard
For collecting traces, both C1 and C2 channels are used.
 C1 is connected to the measuring port of the FPGA and C2 collects the trigger
 signal from the board pins.
 Data is collected whenever the trigger is set high.
 We use a power probe for C1 and a single hook probe for C2.
\end_layout

\begin_layout Standard
We set the sampling rate to 
\begin_inset Formula $10kS$
\end_inset

, which is the number of samples to be collected in each trigger.
 This is not achievable in case of the typical AES accelerator (non-threshold
 AES), and instead, the oscilloscope will reduce the sampling rate on its
 own to around 5000-6000 samples per trigger based on the resolution.
 The sample size will be fixed for all traces provided we ensure in our
 design that the trigger is set for the same number of cycles for each trace.
 The oscilloscope can also synchronise triggers to give a clear and stable
 display of the power traces.
\end_layout

\begin_layout Subsection
Code analysis of Python scripts
\end_layout

\begin_layout Standard
After collecting the traces, the python code TVLA_threaded.py can be used
 to compute the TVLA score.
 This code involves multithreading, and a corresponding sequential code
 was also made and can be found as TVLA_basic.py.
 The scores from the two codes differ only by 0.001% which is occuring due
 to floating point precision errors.
\end_layout

\begin_layout Subsubsection
Libraries imported
\end_layout

\begin_layout Standard
The following libraries are imported:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import os
\end_layout

\begin_layout Plain Layout

import pandas as pd
\end_layout

\begin_layout Plain Layout

import numpy as np
\end_layout

\begin_layout Plain Layout

import csv
\end_layout

\begin_layout Plain Layout

import threading as th
\end_layout

\begin_layout Plain Layout

from time import time
\end_layout

\begin_layout Plain Layout

from joblib import Parallel, delayed
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
TVLA_basic.py
\end_layout

\begin_layout Standard
TVLA_basic.py is a simple sequential code that can read a file iteratively
 and accumulate the total sum and sum of squares for mean and variance computati
on.
 Power consumption at each instant of time is present in consecutive rows,
 and the t-value is found for each row separately.
 The following summations were used so that all the trace files need not
 be read and stored together for processing.
 This was done to prevent RAM from getting full and to also allow parallel
 processing of data which we utilize in the next script.
\end_layout

\begin_layout Standard
\noindent

\size large
\begin_inset Formula 
\begin{equation}
Mean_{j}(\mu_{j})=\frac{1}{N}\sum_{k=1}^{N}row_{k}[j]
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\noindent

\size large
\begin_inset Formula 
\begin{equation}
Variance_{j}(\sigma_{j})=\frac{1}{N}(\sum_{k=1}^{N}row_{k}[j]^{2})-\mu_{j}^{2}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center
where N is the number of traces, k is the kth trace and j is jth instant
 of time during the trigger
\end_layout

\begin_layout Standard
This computation is done separately for dataset 1 and dataset 2.
 T-value is computed at every time instant, and the highest value is displayed
 in the end along with the time taken.
\end_layout

\begin_layout Subsubsection
TVLA_threaded.py
\end_layout

\begin_layout Standard
This code is similar to the previous one but with the added advantage of
 threads.
 Threads are lightweight processes and allow parallel processing of data.
 If we are to use threads, we should try to ensure that the number of threads
 getting generated is some multiple of the number of cores we are using
 so that we get maximum efficiency.
 Threads are introduced using the Joblibs library.
\end_layout

\begin_layout Standard
To compute the total sum and sum of squares, we use reduction sum approach.
 This was found to be significantly faster than each thread returning values
 reading from a file.
 A function, 
\emph on
partial_accumulator()
\emph default
, is defined which takes the parameters 
\emph on
csv_files
\emph default
, loop variable 
\emph on
i
\emph default
, 
\emph on
width
\emph default
 and number of traces.
 Using 
\emph on
Parallel()
\emph default
, we generate threads, and each will perform this function.
\end_layout

\begin_layout Standard
We use a parameter 
\begin_inset Quotes eld
\end_inset


\emph on
width
\emph default

\begin_inset Quotes erd
\end_inset

 for which each thread will compute the partial sums.
 For good efficiency, the total number of traces by 
\emph on
width
\emph default
 should be a multiple of the number of cores.
 Other parameter in this code is the number of cores which ideally should
 be the number of cores in the computing system used.
\end_layout

\begin_layout Section
Evaluation of AES accelerators
\end_layout

\begin_layout Standard
Both encryption and decryption processes were evaluated in separate experiments
 for each of our AES accelerators.
 For the TVLA test, two sets of data 
\begin_inset CommandInset citation
LatexCommand cite
key "key-6"
literal "false"

\end_inset

 are to be passed by the Wrapper modules for both encryption and decryption.
\end_layout

\begin_layout Enumerate
Data-set 1:
\end_layout

\begin_deeper
\begin_layout Enumerate
256-bit Constant Key is set to 0x0123456789abcdef123456789abcdef023456789abcdef0
13456789abcdef012 and Key length is set to Bit128
\end_layout

\begin_layout Enumerate
\begin_inset Formula $n$
\end_inset

 128-bit fixed input is set to 0xda39a3ee5e6b4b0d3255bfef95601890 where
 
\begin_inset Formula $n$
\end_inset

 is the number of times the fixed input is fed
\end_layout

\end_deeper
\begin_layout Enumerate
Data-set 2:
\end_layout

\begin_deeper
\begin_layout Enumerate
256-bit Constant Key is set to 0x0123456789abcdef123456789abcdef023456789abcdef0
13456789abcdef012 and Key length is set to Bit128
\end_layout

\begin_layout Enumerate
\begin_inset Formula $n$
\end_inset

 128-bit inputs: 
\begin_inset Formula $I_{0}$
\end_inset

, 
\begin_inset Formula $I_{1}$
\end_inset

, ..., 
\begin_inset Formula $I_{n}$
\end_inset

, where 
\begin_inset Formula $I_{0}=0x0$
\end_inset

, 
\begin_inset Formula $I_{j}=AES(Key,I_{j},mode)$
\end_inset

 for 
\begin_inset Formula $0<j\leq n$
\end_inset

 where 
\begin_inset Formula $n$
\end_inset

 is the number of inputs and mode is for choosing between encryption and
 decryption
\end_layout

\end_deeper
\begin_layout Standard
As it can be noted, the same Key is used for both the datasets and the same
 number of inputs were fed for both the datasets.
 NIST recommends dispersing the two datasets while emulating them, so we
 passed the inputs from both the datasets alternatively.
 We use only Kintex7 (part no.: xc7k160tfbg676-1) of the SASEBO-GIII board,
 and it was programmed using Xilinx Vivado 2020.1.
 
\end_layout

\begin_layout Standard
The following picture is the setup used for the above three accelerators.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename report_pictures/setup.jpeg
	lyxscale 10
	scale 20

\end_inset


\end_layout

\begin_layout Standard
Two connections were given from the FPGA to the oscilloscope, as shown in
 the above picture.
 C1 of the oscilloscope is connected to the power measuring port, and C2
 of the oscilloscope collects the trigger signal from the board's pins.
 The Xilinx Platform Cable connects to the FPGA via the JTAG interface and
 is used for programming the FPGA using Vivado.
 
\end_layout

\begin_layout Standard
To feed the inputs to the accelerators we use wrapper modules.
 The wrapper files have the following ports:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

input  CLK;
\end_layout

\begin_layout Plain Layout

input  RST_N;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// value method trigger_pin
\end_layout

\begin_layout Plain Layout

output trigger_pin;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// value method done_signal
\end_layout

\begin_layout Plain Layout

output done_signal;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// value method output_fix
\end_layout

\begin_layout Plain Layout

output [127 : 0] output_fix;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the Top module above the wrapper file, we have given just the minimum
 required configurations required for the FPGA.
 To convert the differential clock of the FPGA to a single-ended clock,
 we added a Xilinx IP, clk_wizard.
 This will be present in the Top module which is written in Verilog HDL.
 The input frequency needs to be set to the SASEBO board's frequency of
 200MHz, and the output frequency was set to 5MHz.
 Reset is set as active high.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename report_pictures/clk_wiz1.png
	lyxscale 10
	scale 20

\end_inset


\begin_inset Formula $\:$
\end_inset


\begin_inset Graphics
	filename report_pictures/clk_wiz2.png
	lyxscale 10
	scale 20

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Clk_wizard configuration
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The following constraint file was used for the FPGA.
 Vivado's default settings were used for synthesis and implementation.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

## Clock configuration
\end_layout

\begin_layout Plain Layout

set_property -dict {PACKAGE_PIN AA3 IOSTANDARD LVDS} [get_ports CLK_P] 
\end_layout

\begin_layout Plain Layout

set_property -dict {PACKAGE_PIN AA2 IOSTANDARD LVDS} [get_ports CLK_N]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## RESET configuration
\end_layout

\begin_layout Plain Layout

set_property -dict {PACKAGE_PIN L23 IOSTANDARD LVCMOS25} [get_ports RST_N]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## GPIO configuration
\end_layout

\begin_layout Plain Layout

set_property -dict {PACKAGE_PIN E23 IOSTANDARD LVCMOS25} [get_ports gpio0]
\end_layout

\begin_layout Plain Layout

set_property -dict {PACKAGE_PIN N17 IOSTANDARD LVCMOS25} [get_ports gpio1]
\end_layout

\begin_layout Plain Layout

set_property -dict {PACKAGE_PIN P24 IOSTANDARD LVCMOS25} [get_ports gpio2]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# General configuration
\end_layout

\begin_layout Plain Layout

set_property BITSTREAM.General.UnconstrainedPins {Allow} [current_design]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The oscilloscope is set to sample 
\begin_inset Formula $10kS$
\end_inset

 points for each trigger, and the trigger mode is set to window trigger.
 For the proper collection of traces, a large delay of 600ms is given between
 two traces in the Wrapper module.
 This is about the time required for the oscilloscope to save the collected
 data before sampling the next one.
 The approximate time taken to collect 
\begin_inset Formula $50K$
\end_inset

 traces is 8 hours.
 After generating traces, it is suggested to move the files from one device
 to another in a zip folder to prevent any data loss during transfer.
 After collecting the data, we unzip the folder and set the appropriate
 parameters in the python script and execute the code.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Evaluation of Lookup-table Based Implementation
\end_layout

\begin_layout Standard
For the typical AES accelerator with LUT based S-box, 25,000 inputs were
 given from each dataset.
 We perform four tests: encryption process with both the wrappers and decryption
 process for both the wrappers.
 The number of clock cycles one process takes is 12 for encryption and 13
 for decryption and the FPGA's frequency is set at 5 MHz.
 Using our Teledyne Lecroy oscilloscope we set the maximum sampling rate
 at 10K samples per trigger.
 We set the oscilloscope to resolution of 
\begin_inset Formula $2mV/div$
\end_inset

 and 
\begin_inset Formula $500ns/div$
\end_inset

.
 For the python script, the number of cores is set to 
\begin_inset Formula $10$
\end_inset

 and the width is set to 
\begin_inset Formula $1000$
\end_inset

.
 The following table depicts the implementation details for comparing the
 two wrapper modules.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename report_pictures/LUT.png
	scale 40

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Evaluation with Wrapper1
\end_layout

\begin_layout Standard
Following plots are the TVLA plots for encryption and decryption process
 using Wrapper1.
 The sampling rate was at 5001 samples per trigger for both the processes.
 Note that the x-axis is in sample units.
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename report_pictures/temp_pics/Figure_1b.png
	lyxscale 40
	scale 35

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename report_pictures/temp_pics/Figure_4b.png
	lyxscale 40
	scale 35

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Plots for Encryption and Decryption process for LUT based S-box with Wrapper1
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The same starting random input, 
\begin_inset Formula $0x00$
\end_inset

, was used for both the tests.
 We have also calculated the TVLA score for different number of traces.
 
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
TVLA scores for encryption with LUT based S-box using Wrapper1
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename report_pictures/temp.png
	scale 40

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
TVLA scores for decryption with LUT based S-box using Wrapper1
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename report_pictures/sbox1_decr_w1.png
	scale 40

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
Additionally, we have run the TVLA scripts for different width (same number
 of cores) to see which is the most efficient.
 For this only one set of data with 50K traces, traces for encryption with
 LUT based S-box using Wrapper1, was used.
 Due to optimizations in the memory access patterns, the time taken values
 in Table 5 are smaller than in Table 3.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Analysis of width vs time taken for 50K traces
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename report_pictures/time_50k.png
	scale 40

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Evaluation with Wrapper2
\end_layout

\begin_layout Standard
Following plots are the TVLA plots for encryption and decryption process
 using Wrapper2.
 The sampling rate was at 5001 and 10001 samples per trigger for encryption
 and decryption process respectively.
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename report_pictures/temp_pics/Figure_3b.png
	lyxscale 30
	scale 35

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename report_pictures/temp_pics/Figure_7b.png
	lyxscale 30
	scale 35

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Plots for Encryption and Decryption process for LUT based S-box with Wrapper2
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Similar to previous, the same starting random input, 
\begin_inset Formula $0x00$
\end_inset

, was used for both the tests and TVLA score was calculated for different
 number of traces.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
TVLA scores for encryption with LUT based S-box using Wrapper2
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename report_pictures/sbox1_encr_w2.png
	scale 40

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
TVLA scores for decryption with LUT based S-box using Wrapper2
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename report_pictures/sbox1_decr_w2.png
	scale 40

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Time analysis of workload for each thread is not done for these datasets
 as it gave similar results as the previous one.
\end_layout

\begin_layout Subsection
Evaluation of Composite Field Implementation
\end_layout

\begin_layout Standard
For the typical AES accelerator with Composite S-box too, we give 25,000
 inputs from each dataset and separately conduct four tests for encryption
 and decryption processes with both the wrappers.
 This also takes the same number clock cycles as the previous.
 Using our Teledyne Lecroy oscilloscope we set the maximum sampling rate
 at 10K samples per trigger.
 We set the oscilloscope to resolution of 
\begin_inset Formula $2mV/div$
\end_inset

 and 
\begin_inset Formula $500ns/div$
\end_inset

.
 For the python script, the number of cores is set to 
\begin_inset Formula $10$
\end_inset

 and the width is set to 
\begin_inset Formula $1000$
\end_inset

.
 The following table depicts the implementation details for comparing the
 two wrapper modules.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename report_pictures/Composite.png
	lyxscale 40
	scale 25

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Evaluation with Wrapper1
\end_layout

\begin_layout Standard
Following plots are the TVLA plots for encryption and decryption process
 using Wrapper1.
 The sampling rate was at 5001 samples per trigger for both the processes.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename report_pictures/temp_pics/Figure_8b.png
	lyxscale 30
	scale 35

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename report_pictures/temp_pics/Figure_11b.png
	lyxscale 30
	scale 35

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Plots for Encryption and Decryption process for Composite AES with Wrapper1
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
TVLA scores were also calculated for Wrapper1.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
TVLA scores for encryption with Composite AES using Wrapper1
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename report_pictures/sbox2_encr_w1.png
	scale 40

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
TVLA scores for decryption with Composite AES using Wrapper1
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename report_pictures/sbox2_decr_w1.png
	scale 40

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsubsection*
Evaluation with Wrapper2
\end_layout

\begin_layout Standard
Following plots are the TVLA plots for encryption and decryption process
 using Wrapper2.
 The sampling rate was at 10001 samples per trigger for both the processes.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename report_pictures/temp_pics/Figure_10b.png
	lyxscale 30
	scale 35

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename report_pictures/temp_pics/Sbox2-Decr_modbnew.png
	lyxscale 30
	scale 35

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Plots for Encryption and Decryption process for Composite AES with Wrapper2
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
TVLA scores were also calculated for Wrapper2.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
TVLA scores for encryption with Composite AES using Wrapper2
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename report_pictures/sbox2_encr_w2.png
	scale 40

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
TVLA scores for decryption with Composite AES using Wrapper2
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename report_pictures/sbox2_decr_mod.png
	scale 33

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Evaluation of Threshold Implementation
\end_layout

\begin_layout Standard
For the Threshold AES accelerator, approximately 5,00,000 traces were collected
 for each dataset.
 The oscilloscope has a limit of collecting a maximum of 1 lakh traces in
 each run and so we collected the output in 10 batches by feeding 50,000
 inputs from each dataset.
 The starting random input for each batch was predetermined by simulating
 the Bluespec code.
 Unlike the typical AES accelerator, the Threshold implementation takes
 atleast 181 cycles for one AES process.
 We set the oscilloscope to resolution of 
\begin_inset Formula $5mV/div$
\end_inset

 and 
\begin_inset Formula $5\mu s/div$
\end_inset

 and set the maximum sampling rate at 10K samples per trigger.
 It was difficult to differentiate between the cipher process's power signal
 and noise but at this resolution some small peaks can be observed within
 the trigger range.
 From previous TVLA analysis, we can notice the major impact on TVLA score
 because of storing the AES output into registers within the trigger.
 Hence, for this accelerator only Wrapper2 module was used and it has given
 expected improvements.
 The implementation aspects can be found in Section 3.4.
 For the python script, the number of cores is set to 
\begin_inset Formula $10$
\end_inset

 and the width is set to 
\begin_inset Formula $10000$
\end_inset

.
\end_layout

\begin_layout Standard
Following plots are the TVLA plots for encryption and decryption process
 using Wrapper2.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename report_pictures/temp_pics/Thresh-Encrb.png
	lyxscale 30
	scale 35

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename report_pictures/temp_pics/Thresh-Decrb.png
	lyxscale 30
	scale 35

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Plots for Encryption and Decryption process for Threshold AES with Wrapper2
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
TVLA scores were also calculated for Threshold AES accelerator with Wrapper2.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
TVLA scores for encryption with Threshold AES with Wrapper2
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename report_pictures/thresh_encr.png
	scale 40

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
TVLA scores for decryption with Threshold AES with Wrapper2
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename report_pictures/thresh_decr.png
	scale 40

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Additionally, we have run the TVLA scripts for different width (same number
 of cores) to see which is the most efficient.
 For this we have used only the traces collected during encryption.
 We can see from Table 14 that Width of around 1000 works most efficiently.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Analysis of width vs time taken for 
\begin_inset Formula $\approx$
\end_inset

1 lakh traces
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename report_pictures/time_1lakh.png
	scale 40

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Results and Conclusion
\end_layout

\begin_layout Standard
Thus, we have evaluated three implementations of the AES accelerator using
 the Welch's t-test which is the Lookup-table Based Implementation, Composite
 Field Implementation and Threshold AES Implementation.
 From our previous research 
\begin_inset CommandInset citation
LatexCommand cite
key "key-1"
literal "false"

\end_inset

, Composite Field implementation is expected to be more secure than LUT
 based AES implementation.
 We got the result as expected when we used Wrapper2 but the results were
 ambiguous with Wrapper1.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Results between LUT based and Composite Field implementations for 50K traces
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename report_pictures/conclusion1.png
	lyxscale 40
	scale 30

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In Wrapper1 module, the following registers are changing during the trigger:
\end_layout

\begin_layout Itemize
2-bit 
\emph on
mod_state
\emph default
 changes during output stage and delay stage
\end_layout

\begin_layout Itemize
32-bit 
\emph on
counter
\emph default
 increments once
\end_layout

\begin_layout Itemize
1-bit 
\emph on
switcher
\emph default
, to switch between fixed and random inputs, gets toggled
\end_layout

\begin_layout Itemize
32-bit 
\emph on
delayer
\emph default
 (delay counter) is set to 0
\end_layout

\begin_layout Itemize
128-bit 
\emph on
input_text
\emph default
 is updated with the cipher output if the input was from the fixed dataset
\end_layout

\begin_layout Itemize
1-bit 
\emph on
trigger
\emph default
 bit is also set to low
\end_layout

\begin_layout Standard
In Wrapper2 module, the following registers change during the trigger:
\end_layout

\begin_layout Itemize
1-bit 
\emph on
block
\emph default
 toggles once and is used to schedule the rules in the Cipher Process 1
 in Figure 9
\end_layout

\begin_layout Itemize
1-bit 
\emph on
trigger
\emph default
 bit is set to low
\end_layout

\begin_layout Standard
Practically, we can expect as many registers as in Wrapper1 to get updated
 in each cipher process but for TVLA we need to reduce the role played by
 these dynamic changes in the net power consumption to accurately evaluate
 the accelerator.
 Dynamic power consumption due to register changes is significantly higher
 than power consumption due to transistors 
\begin_inset CommandInset citation
LatexCommand cite
key "key-7"
literal "false"

\end_inset

.
 Though practically we don't see much change in the power plots between
 the two wrappers, the effect on TVLA is very significant.
 Hence, only Wrapper2 was used for Threshold implementation and the result
 we have got is that it performs better than Composite Field implementation.
 So overall, Threshold implementation is the most secure among all three,
 followed by Composite Field implementation.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Comparison of all three implementations using Wrapper2 and with 50K traces
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename report_pictures/conclusion2.png
	lyxscale 40
	scale 30

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
We also conclude that the TVLA score increases with the number of traces
 with the following Log-log plots in Figure 17.
 Threshold AES will likely show more linearity at higher number of traces
 but we can observe the general increase of maximum t-value with the number
 of traces.
 With the values from the tables we can approximately show that 
\begin_inset Formula $t-value\propto\sqrt{N}$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename report_pictures/tvla_LUT.png
	lyxscale 30
	scale 33

\end_inset


\begin_inset Graphics
	filename report_pictures/tvla_Composite.png
	lyxscale 30
	scale 30

\end_inset


\begin_inset Graphics
	filename report_pictures/tvla_thresh.png
	lyxscale 30
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Log-log plots for the three implementations
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Scope of improvement
\end_layout

\begin_layout Enumerate

\series bold
Remote setup for the oscilloscope for viewing the StartDSO application:
\series default
 Instruments operation and trace data collection can be done through remote
 operation using TCP-IP, ActiveDSO, GP-IB, etc.
\end_layout

\begin_layout Enumerate

\series bold
Effect of routing algorithms used:
\series default
 We have used only default synthesis and implementation for our analysis.
 The effect could be significant if, say, Speed Maximized synthesis option
 is used which has higher power consumption 
\begin_inset CommandInset citation
LatexCommand cite
key "key-5"
literal "false"

\end_inset

.
\end_layout

\begin_layout Enumerate

\series bold
Analysis of the dependence of TVLA on the frequency of the FPGA board:
\series default
 Very low frequency was used because of various limitations as stated previously.
 Higher frequency implies higher power consumption and this could have its
 own implications.
\end_layout

\begin_layout Enumerate

\series bold
Practical assessment of accelerators by collecting traces when it is integrated
 with a CPU:
\series default
 The Typical AES accelerator has been integrated with Shakti C-Class and
 system functions have been provided to allow setting of the trigger pin.
 The problem with using a CPU is that it will take more time to synthesise
 and implement as compared to the wrapper modules and modifications to the
 CPU might be necessary to limit the total number of LUT usage to less than
 110,000 LUTs (total number of LUTs in the SASEBO-GIII platform).
\end_layout

\begin_layout Enumerate

\series bold
To improve threshold implementation:
\series default
 Specific operations which are causing the leakage can be identified by
 detailed analysis of the TVLA plots and can be used to improve threshold
 implementation.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Appendix
\end_layout

\begin_layout Standard
Limitations of this study are as follows:
\end_layout

\begin_layout Itemize
TVLA value was not very steady and it is possible that the TVLA score could
 change significantly when a test is run multiple times: A large number
 of tests might be required to get a consistent value.
 The physical conditions of the setup could also play a role in the trace
 collection.
\end_layout

\begin_layout Itemize
Frequency of the FPGA board had to be set to minimum due to the limit on
 the maximum sampling rate: Large number of samples had to be collected
 for a small process which takes only 12 cycles.
 This causes some traces to be skipped in the beginning/end, and the process
 was repeated if sufficient number of traces were not recorded.
\end_layout

\begin_layout Itemize
The limited RAM capacity of the oscilloscope caused intermittent hanging
 of the set up, causing repetition of the validity of collected data and
 loss of time.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-1"

\end_inset

 Aditya Pradeep, Vishal Mohanty, Adarsh Muthuveeru Subramaniam, and Chester
 Rebeiro (2019), â€˜Revisiting AES S-Box Composite Field Implementations for
 FPGAsâ€™, IEEE Embedded System Letters, Vol.11, No.3.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-5"

\end_inset

 Akhil Sai and Chester Rebeiro (2017), â€˜Influence of CAD Routing Algorithms
 on Cryptographic Side Channel Attacksâ€™, Department of Computer Science
 and Engineering, IIT Madras.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-6"

\end_inset

 Gilbert Goodwill, Benjamin Jun, Josh Jaffe and Pankaj Rohatgi, â€˜A testing
 methodology for side-channel resistance validationâ€™, Cryptography Research
 Inc.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-7"

\end_inset

 Stefan Mangard, Elisabeth Oswald and Thomas Popp, â€˜Power Analysis Attacks:
 Revealing the Secrets of Smart Cardsâ€™, Textbook.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-11"

\end_inset

 Vishal Mohanty and Chester Reberio (2019), â€˜Efficient AES Threshold Implementat
ion on FPGAâ€™, UGRC-II report, Department of Computer Science and Engineering,
 IIT Madras.
\end_layout

\end_body
\end_document
