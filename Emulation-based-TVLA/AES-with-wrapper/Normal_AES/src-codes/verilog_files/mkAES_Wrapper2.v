//
// Generated by Bluespec Compiler, version 2021.07-1-gaf77efcd (build af77efcd)
//
// On Sun Apr 10 09:35:17 IST 2022
//
//
// Ports:
// Name                         I/O  size props
// trigger_pin                    O     1 reg
// RDY_trigger_pin                O     1 const
// done_signal                    O     1 reg
// RDY_done_signal                O     1 const
// output_fix                     O   128 reg
// RDY_output_fix                 O     1
// CLK                            I     1 clock
// RST_N                          I     1 reset
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkAES_Wrapper2(CLK,
		      RST_N,

		      trigger_pin,
		      RDY_trigger_pin,

		      done_signal,
		      RDY_done_signal,

		      output_fix,
		      RDY_output_fix);
  input  CLK;
  input  RST_N;

  // value method trigger_pin
  output trigger_pin;
  output RDY_trigger_pin;

  // value method done_signal
  output done_signal;
  output RDY_done_signal;

  // value method output_fix
  output [127 : 0] output_fix;
  output RDY_output_fix;

  // signals for module outputs
  wire [127 : 0] output_fix;
  wire RDY_done_signal,
       RDY_output_fix,
       RDY_trigger_pin,
       done_signal,
       trigger_pin;

  // register block
  reg block;
  wire block$D_IN, block$EN;

  // register counter
  reg [31 : 0] counter;
  wire [31 : 0] counter$D_IN;
  wire counter$EN;

  // register delayer
  reg [31 : 0] delayer;
  wire [31 : 0] delayer$D_IN;
  wire delayer$EN;

  // register done_reg
  reg done_reg;
  wire done_reg$D_IN, done_reg$EN;

  // register input_text
  reg [127 : 0] input_text;
  wire [127 : 0] input_text$D_IN;
  wire input_text$EN;

  // register mod_state
  reg [2 : 0] mod_state;
  reg [2 : 0] mod_state$D_IN;
  wire mod_state$EN;

  // register switcher
  reg switcher;
  wire switcher$D_IN, switcher$EN;

  // register trigger
  reg trigger;
  wire trigger$D_IN, trigger$EN;

  // ports of submodule aes_
  wire [255 : 0] aes_$encrypt_keyyy, aes_$genKeys_keyyy;
  wire [127 : 0] aes_$encrypt_plaintexttt, aes_$ret;
  wire [1 : 0] aes_$encrypt_keyylenn, aes_$genKeys_keyylenn;
  wire aes_$EN_encrypt,
       aes_$EN_genKeys,
       aes_$EN_ret,
       aes_$RDY_encrypt,
       aes_$RDY_genKeys,
       aes_$RDY_ret,
       aes_$encrypt_decrypttt;

  // rule scheduling signals
  wire WILL_FIRE_RL_buffer,
       WILL_FIRE_RL_idle_rule,
       WILL_FIRE_RL_process1_complete,
       WILL_FIRE_RL_process1_start,
       WILL_FIRE_RL_process2_complete,
       WILL_FIRE_RL_process2_start;

  // inputs to muxes for submodule ports
  wire [127 : 0] MUX_aes_$encrypt_1__VAL_2;
  wire [31 : 0] MUX_delayer$write_1__VAL_1;
  wire MUX_delayer$write_1__SEL_2,
       MUX_done_reg$write_1__SEL_1,
       MUX_input_text$write_1__SEL_1,
       MUX_mod_state$write_1__SEL_1,
       MUX_mod_state$write_1__SEL_2;

  // declarations used by system tasks
  // synopsys translate_off
  reg [63 : 0] v__h864;
  reg [63 : 0] v__h960;
  reg [63 : 0] v__h1092;
  // synopsys translate_on

  // remaining internal signals
  wire [31 : 0] counter_5_PLUS_1___d26;
  wire delayer_SLT_3000000___d7;

  // value method trigger_pin
  assign trigger_pin = trigger ;
  assign RDY_trigger_pin = 1'd1 ;

  // value method done_signal
  assign done_signal = done_reg ;
  assign RDY_done_signal = 1'd1 ;

  // value method output_fix
  assign output_fix = aes_$ret ;
  assign RDY_output_fix =
	     WILL_FIRE_RL_process2_complete ||
	     WILL_FIRE_RL_process1_complete ;

  // submodule aes_
  mkAES aes_(.CLK(CLK),
	     .RST_N(RST_N),
	     .encrypt_decrypttt(aes_$encrypt_decrypttt),
	     .encrypt_keyylenn(aes_$encrypt_keyylenn),
	     .encrypt_keyyy(aes_$encrypt_keyyy),
	     .encrypt_plaintexttt(aes_$encrypt_plaintexttt),
	     .genKeys_keyylenn(aes_$genKeys_keyylenn),
	     .genKeys_keyyy(aes_$genKeys_keyyy),
	     .EN_genKeys(aes_$EN_genKeys),
	     .EN_encrypt(aes_$EN_encrypt),
	     .EN_ret(aes_$EN_ret),
	     .RDY_genKeys(aes_$RDY_genKeys),
	     .RDY_encrypt(aes_$RDY_encrypt),
	     .ret(aes_$ret),
	     .RDY_ret(aes_$RDY_ret),
	     .outp_ready(),
	     .RDY_outp_ready(),
	     .can_take_inp(),
	     .RDY_can_take_inp());

  // rule RL_idle_rule
  assign WILL_FIRE_RL_idle_rule = aes_$RDY_genKeys && mod_state == 3'd0 ;

  // rule RL_process1_start
  assign WILL_FIRE_RL_process1_start =
	     aes_$RDY_encrypt && mod_state == 3'd2 && !block && trigger ;

  // rule RL_process1_complete
  assign WILL_FIRE_RL_process1_complete =
	     aes_$RDY_ret && mod_state == 3'd2 && block && trigger ;

  // rule RL_buffer
  assign WILL_FIRE_RL_buffer = mod_state == 3'd2 && block && !trigger ;

  // rule RL_process2_start
  assign WILL_FIRE_RL_process2_start = aes_$RDY_encrypt && mod_state == 3'd3 ;

  // rule RL_process2_complete
  assign WILL_FIRE_RL_process2_complete = aes_$RDY_ret && mod_state == 3'd4 ;

  // inputs to muxes for submodule ports
  assign MUX_delayer$write_1__SEL_2 =
	     WILL_FIRE_RL_process2_complete || WILL_FIRE_RL_idle_rule ;
  assign MUX_done_reg$write_1__SEL_1 =
	     WILL_FIRE_RL_process2_complete && counter == 32'd49999 ;
  assign MUX_input_text$write_1__SEL_1 =
	     WILL_FIRE_RL_process2_complete && switcher ;
  assign MUX_mod_state$write_1__SEL_1 =
	     mod_state == 3'd1 && !delayer_SLT_3000000___d7 ;
  assign MUX_mod_state$write_1__SEL_2 =
	     WILL_FIRE_RL_process2_complete && counter != 32'd49999 ;
  assign MUX_aes_$encrypt_1__VAL_2 =
	     switcher ? input_text : 128'hDA39A3EE5E6B4B0D3255BFEF95601890 ;
  assign MUX_delayer$write_1__VAL_1 =
	     delayer_SLT_3000000___d7 ? delayer + 32'd1 : 32'd0 ;

  // register block
  assign block$D_IN = !WILL_FIRE_RL_buffer ;
  assign block$EN = WILL_FIRE_RL_buffer || WILL_FIRE_RL_process1_start ;

  // register counter
  assign counter$D_IN =
	     WILL_FIRE_RL_process2_complete ? counter_5_PLUS_1___d26 : 32'd0 ;
  assign counter$EN = MUX_delayer$write_1__SEL_2 ;

  // register delayer
  assign delayer$D_IN =
	     (mod_state == 3'd1) ? MUX_delayer$write_1__VAL_1 : 32'd0 ;
  assign delayer$EN =
	     mod_state == 3'd1 || WILL_FIRE_RL_process2_complete ||
	     WILL_FIRE_RL_idle_rule ;

  // register done_reg
  assign done_reg$D_IN = MUX_done_reg$write_1__SEL_1 ;
  assign done_reg$EN =
	     WILL_FIRE_RL_process2_complete && counter == 32'd49999 ||
	     WILL_FIRE_RL_idle_rule ;

  // register input_text
  assign input_text$D_IN = MUX_input_text$write_1__SEL_1 ? aes_$ret : 128'h0 ;
  assign input_text$EN =
	     WILL_FIRE_RL_process2_complete && switcher ||
	     WILL_FIRE_RL_idle_rule ;

  // register mod_state
  always@(MUX_mod_state$write_1__SEL_2 or
	  WILL_FIRE_RL_idle_rule or
	  MUX_mod_state$write_1__SEL_1 or
	  WILL_FIRE_RL_buffer or WILL_FIRE_RL_process2_start)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_mod_state$write_1__SEL_2 || WILL_FIRE_RL_idle_rule:
	  mod_state$D_IN = 3'd1;
      MUX_mod_state$write_1__SEL_1: mod_state$D_IN = 3'd2;
      WILL_FIRE_RL_buffer: mod_state$D_IN = 3'd3;
      WILL_FIRE_RL_process2_start: mod_state$D_IN = 3'd4;
      default: mod_state$D_IN = 3'b010 /* unspecified value */ ;
    endcase
  end
  assign mod_state$EN =
	     mod_state == 3'd1 && !delayer_SLT_3000000___d7 ||
	     WILL_FIRE_RL_process2_complete && counter != 32'd49999 ||
	     WILL_FIRE_RL_idle_rule ||
	     WILL_FIRE_RL_buffer ||
	     WILL_FIRE_RL_process2_start ;

  // register switcher
  assign switcher$D_IN = ~switcher ;
  assign switcher$EN = WILL_FIRE_RL_process2_complete ;

  // register trigger
  assign trigger$D_IN = !WILL_FIRE_RL_process1_complete ;
  assign trigger$EN =
	     mod_state == 3'd1 && !delayer_SLT_3000000___d7 ||
	     WILL_FIRE_RL_process1_complete ||
	     mod_state == 3'd2 && !block && !trigger ;

  // submodule aes_
  assign aes_$encrypt_decrypttt = 1'd1 ;
  assign aes_$encrypt_keyylenn = 2'd0 ;
  assign aes_$encrypt_keyyy =
	     256'h0123456789ABCDEF123456789ABCDEF023456789ABCDEF013456789ABCDEF012 ;
  assign aes_$encrypt_plaintexttt =
	     WILL_FIRE_RL_process2_start ?
	       input_text :
	       MUX_aes_$encrypt_1__VAL_2 ;
  assign aes_$genKeys_keyylenn = 2'd0 ;
  assign aes_$genKeys_keyyy =
	     256'h0123456789ABCDEF123456789ABCDEF023456789ABCDEF013456789ABCDEF012 ;
  assign aes_$EN_genKeys = WILL_FIRE_RL_idle_rule ;
  assign aes_$EN_encrypt =
	     WILL_FIRE_RL_process2_start || WILL_FIRE_RL_process1_start ;
  assign aes_$EN_ret = RDY_output_fix ;

  // remaining internal signals
  assign counter_5_PLUS_1___d26 = counter + 32'd1 ;
  assign delayer_SLT_3000000___d7 = (delayer ^ 32'h80000000) < 32'h802DC6C0 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        block <= `BSV_ASSIGNMENT_DELAY 1'd0;
	counter <= `BSV_ASSIGNMENT_DELAY 32'd0;
	delayer <= `BSV_ASSIGNMENT_DELAY 32'd8;
	done_reg <= `BSV_ASSIGNMENT_DELAY 1'd0;
	input_text <= `BSV_ASSIGNMENT_DELAY 128'd0;
	mod_state <= `BSV_ASSIGNMENT_DELAY 3'd0;
	switcher <= `BSV_ASSIGNMENT_DELAY 1'd0;
	trigger <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (block$EN) block <= `BSV_ASSIGNMENT_DELAY block$D_IN;
	if (counter$EN) counter <= `BSV_ASSIGNMENT_DELAY counter$D_IN;
	if (delayer$EN) delayer <= `BSV_ASSIGNMENT_DELAY delayer$D_IN;
	if (done_reg$EN) done_reg <= `BSV_ASSIGNMENT_DELAY done_reg$D_IN;
	if (input_text$EN)
	  input_text <= `BSV_ASSIGNMENT_DELAY input_text$D_IN;
	if (mod_state$EN) mod_state <= `BSV_ASSIGNMENT_DELAY mod_state$D_IN;
	if (switcher$EN) switcher <= `BSV_ASSIGNMENT_DELAY switcher$D_IN;
	if (trigger$EN) trigger <= `BSV_ASSIGNMENT_DELAY trigger$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    block = 1'h0;
    counter = 32'hAAAAAAAA;
    delayer = 32'hAAAAAAAA;
    done_reg = 1'h0;
    input_text = 128'hAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    mod_state = 3'h2;
    switcher = 1'h0;
    trigger = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_idle_rule) $display("Idle");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_process1_start && switcher)
	begin
	  v__h864 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_process1_start && switcher)
	$display(v__h864,
		 " Random input %d: %h ",
		 $signed(counter_5_PLUS_1___d26),
		 input_text);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_process1_start && !switcher)
	begin
	  v__h960 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_process1_start && !switcher)
	$display(v__h960,
		 " Fixed input %d: %h",
		 $signed(counter_5_PLUS_1___d26),
		 128'hDA39A3EE5E6B4B0D3255BFEF95601890);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_process1_complete)
	begin
	  v__h1092 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_process1_complete)
	$display(v__h1092, " Output of decryption: %h", aes_$ret);
  end
  // synopsys translate_on
endmodule  // mkAES_Wrapper2

