//
// Generated by Bluespec Compiler, version 2021.07-1-gaf77efcd (build af77efcd)
//
// On Sun Apr 17 15:04:48 IST 2022
//
//
// Ports:
// Name                         I/O  size props
// getbyte                        O     8
// RDY_getbyte                    O     1 const
// seed_1                         I    16
// seed_2                         I    24
// seed_3                         I    24
// CLK                            I     1 clock
// RST_N                          I     1 reset
// getbyte_in                     I     8
// EN_getbyte                     I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkinv_sbox_threshold(seed_1,
			    seed_2,
			    seed_3,
			    CLK,
			    RST_N,

			    getbyte_in,
			    EN_getbyte,
			    getbyte,
			    RDY_getbyte);
  input  [15 : 0] seed_1;
  input  [23 : 0] seed_2;
  input  [23 : 0] seed_3;
  input  CLK;
  input  RST_N;

  // actionvalue method getbyte
  input  [7 : 0] getbyte_in;
  input  EN_getbyte;
  output [7 : 0] getbyte;
  output RDY_getbyte;

  // signals for module outputs
  wire [7 : 0] getbyte;
  wire RDY_getbyte;

  // register lfsr_1_r
  reg [15 : 0] lfsr_1_r;
  wire [15 : 0] lfsr_1_r$D_IN;
  wire lfsr_1_r$EN;

  // register lfsr_2_r
  reg [23 : 0] lfsr_2_r;
  wire [23 : 0] lfsr_2_r$D_IN;
  wire lfsr_2_r$EN;

  // register lfsr_3_r
  reg [23 : 0] lfsr_3_r;
  wire [23 : 0] lfsr_3_r$D_IN;
  wire lfsr_3_r$EN;

  // register rg_start_lfsr
  reg rg_start_lfsr;
  wire rg_start_lfsr$D_IN, rg_start_lfsr$EN;

  // ports of submodule isb
  wire [23 : 0] isb$r2, isb$r3;
  wire [15 : 0] isb$r1;
  wire [7 : 0] isb$in, isb$out;

  // inputs to muxes for submodule ports
  wire [23 : 0] MUX_lfsr_2_r$write_1__VAL_2, MUX_lfsr_3_r$write_1__VAL_2;
  wire [15 : 0] MUX_lfsr_1_r$write_1__VAL_2;

  // actionvalue method getbyte
  assign getbyte = isb$out ;
  assign RDY_getbyte = 1'd1 ;

  // submodule isb
  inv_sbox isb(.in(isb$in),
	       .r1(isb$r1),
	       .r2(isb$r2),
	       .r3(isb$r3),
	       .out(isb$out));

  // inputs to muxes for submodule ports
  assign MUX_lfsr_1_r$write_1__VAL_2 =
	     lfsr_1_r[0] ?
	       { 1'd1,
		 lfsr_1_r[15:6],
		 ~lfsr_1_r[5],
		 lfsr_1_r[4],
		 ~lfsr_1_r[3:2],
		 lfsr_1_r[1] } :
	       { 1'd0, lfsr_1_r[15:1] } ;
  assign MUX_lfsr_2_r$write_1__VAL_2 =
	     lfsr_2_r[0] ?
	       { 1'd0,
		 lfsr_2_r[23:21],
		 ~lfsr_2_r[20],
		 lfsr_2_r[19:5],
		 ~lfsr_2_r[4:3],
		 lfsr_2_r[2],
		 ~lfsr_2_r[1] } :
	       { 1'd0, lfsr_2_r[23:1] } ;
  assign MUX_lfsr_3_r$write_1__VAL_2 =
	     lfsr_3_r[0] ?
	       { 1'd0,
		 lfsr_3_r[23:21],
		 ~lfsr_3_r[20],
		 lfsr_3_r[19:5],
		 ~lfsr_3_r[4:3],
		 lfsr_3_r[2],
		 ~lfsr_3_r[1] } :
	       { 1'd0, lfsr_3_r[23:1] } ;

  // register lfsr_1_r
  assign lfsr_1_r$D_IN =
	     rg_start_lfsr ? seed_1 : MUX_lfsr_1_r$write_1__VAL_2 ;
  assign lfsr_1_r$EN = rg_start_lfsr || EN_getbyte ;

  // register lfsr_2_r
  assign lfsr_2_r$D_IN =
	     rg_start_lfsr ? seed_2 : MUX_lfsr_2_r$write_1__VAL_2 ;
  assign lfsr_2_r$EN = rg_start_lfsr || EN_getbyte ;

  // register lfsr_3_r
  assign lfsr_3_r$D_IN =
	     rg_start_lfsr ? seed_3 : MUX_lfsr_3_r$write_1__VAL_2 ;
  assign lfsr_3_r$EN = rg_start_lfsr || EN_getbyte ;

  // register rg_start_lfsr
  assign rg_start_lfsr$D_IN = 1'd0 ;
  assign rg_start_lfsr$EN = rg_start_lfsr ;

  // submodule isb
  assign isb$in = getbyte_in ;
  assign isb$r1 = lfsr_1_r ;
  assign isb$r2 = lfsr_2_r ;
  assign isb$r3 = lfsr_3_r ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        lfsr_1_r <= `BSV_ASSIGNMENT_DELAY 16'd1;
	lfsr_2_r <= `BSV_ASSIGNMENT_DELAY 24'd1;
	lfsr_3_r <= `BSV_ASSIGNMENT_DELAY 24'd1;
	rg_start_lfsr <= `BSV_ASSIGNMENT_DELAY 1'd1;
      end
    else
      begin
        if (lfsr_1_r$EN) lfsr_1_r <= `BSV_ASSIGNMENT_DELAY lfsr_1_r$D_IN;
	if (lfsr_2_r$EN) lfsr_2_r <= `BSV_ASSIGNMENT_DELAY lfsr_2_r$D_IN;
	if (lfsr_3_r$EN) lfsr_3_r <= `BSV_ASSIGNMENT_DELAY lfsr_3_r$D_IN;
	if (rg_start_lfsr$EN)
	  rg_start_lfsr <= `BSV_ASSIGNMENT_DELAY rg_start_lfsr$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    lfsr_1_r = 16'hAAAA;
    lfsr_2_r = 24'hAAAAAA;
    lfsr_3_r = 24'hAAAAAA;
    rg_start_lfsr = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkinv_sbox_threshold

