''' Difference of Mean Attack code
For this we collect N traces for random inputs and we also use the knowledge of what plaintext is fed in.
Cons:- Not a very good attack but very fast
The following is the code used for AES accelerator of Shakti '''
import numpy as np
import matplotlib.pyplot as plt
from tqdm import tnrange
import os
import csv
import sys
from Crypto.Util.number import *

sbox = (
    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16)

def intermediate(pt, keyguess):
    return sbox[pt ^ keyguess]


# Plaintexts are put in this file in the bluespec code. The wrapper module used for TVLA can be slightly modified and used here.
with open('plaintexts.txt') as f:
	textin_array = f.readlines()
	textin_array = [long_to_bytes(int(i)) for i in textin_array]
	textin_array = [d.ljust(16, b'\0') for d in textin_array]

	data = []
	for t in textin_array:
		temp = []
		for b in t:
			_ = int(b)
			temp.append(_)
		data.append(temp)
	textin_array = np.asarray(data)
	#print(textin_array.shape)

# Folder containing all the traces
path_csv = "dpa-test2/"

csv_files = [str(path_csv+f) for f in os.listdir(path_csv)]	
total_traces = len(csv_files)
mean_diffs = np.zeros(255)

key_guess = []
alltraces = []

# Here we read all the traces and store them in a list. This was found to be the fastest way and might need the RAM a lot.
for i in range(total_traces):
	trace = []
	current_file = open(csv_files[i])
	csvreader = csv.reader(current_file)
	for row in csvreader:
		try :
				trace.append(float(row[0]))
		except :
			pass
	alltraces.append(trace)

alltraces = np.asarray(alltraces)


# Attack is being performed here. 
## We go over all the key bytes and each has 256 possible values
for subkey in tnrange (0, 16, desc="Attacking Subkey"):
	for kguess in tnrange (255, desc="Keyguess", leave=False):
		print("Working subkey", subkey,"kguess", kguess)
		one_list = []
		zero_list = []
		
		# For targettng the nth byte of the key we take the intermediate of the nth byte of the plaintext and XOR it with the keyguess
		## They are classified based on if the last digit of the byte is 1 or 0
		for i in range(total_traces):
			trace = alltraces[i]

			if (intermediate(textin_array[i][subkey], kguess) & 1):
				one_list.append(trace)
			else:
				zero_list.append(trace)
		
		one_avg = np.asarray(one_list).mean(axis=0)
		zero_avg = np.asarray(zero_list).mean(axis=0)
		mean_diffs[kguess] = np.max(abs(one_avg - zero_avg))

	guess = np.argsort(mean_diffs)[-1]
	key_guess.append(guess)
	
	print("Predicted value for", subkey", byte is", hex(guess))
	print("Value of DOM", mean_diffs[guess])

print("Total key predicted")
for kg in key_guess:
	print(hex(kg))

